<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Potato Online</title>
  
  <subtitle>Trust , But Verify !</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.kmahyyg.xyz/"/>
  <updated>2019-02-24T12:39:17.218Z</updated>
  <id>https://www.kmahyyg.xyz/</id>
  
  <author>
    <name>Patrick Young</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2019 新年之旅 - 重庆 Day 2</title>
    <link href="https://www.kmahyyg.xyz/2019/cqcd-trip-cqday2/"/>
    <id>https://www.kmahyyg.xyz/2019/cqcd-trip-cqday2/</id>
    <published>2019-02-24T20:36:28.000Z</published>
    <updated>2019-02-24T12:39:17.218Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在正文之前"><a href="#写在正文之前" class="headerlink" title="写在正文之前"></a>写在正文之前</h2><p>刚刚在 <a href="https://www.douyu.com/12479" target="_blank" rel="noopener">洛洛的直播间</a> 参与了一场“解答之书”，一直在等待的一个 PopUp， 得到的答案却是“或许不是问题”，那就果断一些吧。始终在等待那一个 PopUp，看看开学之后一周内会有么…这也就是我留给自己的 Grace Period 了： 1 Week.</p><hr><h1 id="重庆"><a href="#重庆" class="headerlink" title="重庆"></a>重庆</h1><h2 id="Day-2-早晨"><a href="#Day-2-早晨" class="headerlink" title="Day 2 - 早晨"></a>Day 2 - 早晨</h2><h3 id="春森路"><a href="#春森路" class="headerlink" title="春森路"></a>春森路</h3><p>借着早晨爽朗的阳光，我和同伴分道扬镳，前往了不同的目的地。在地图上确认了一下距离之后，走向了今天意外的第一站：春森路社区。这个社区的门口，一直有一个身影佝偻摊位面前，日复一日的劳作老人年事已高，却依然坚守在这里成为一代又一代老重庆人的精神地标。这个摊位并不支持电子支付方式，所以请去的同学自备零钱。</p><p>卖的是糯米团，一层油条干+一层糯米+一层砂糖+一层豆面，配上一杯新鲜的现磨豆浆，8块钱，一个早上都让你饱饱的。糯米团是老人提前一天晚上蒸好的，豆浆是早上现磨的，老人很忙，经常会出现供不应求的情况，早上7点到下午14点，中午12点之后限购。真的非常的实诚，以至于早上8点半到达都排队等待了一个多小时才吃到。 <strong>一个城市的灵魂，或许正是在这些街边小摊和市井民众上体现出来的那一种精神吧。</strong></p><p><img src="https://alicdn.kmahyyg.xyz/asset_files/cqcd2019/cq-day2/2019cq-d2-1.jpg" alt="CSMNMT1"></p><p>略显佝偻的身影</p><p><img src="https://alicdn.kmahyyg.xyz/asset_files/cqcd2019/cq-day2/2019cq-d2-2.jpg" alt="CSMNMT2"></p><p>实在的糯米团外表</p><p><img src="https://alicdn.kmahyyg.xyz/asset_files/cqcd2019/cq-day2/2019cq-d2-3.jpg" alt="CSMNMT3"></p><p>糯米团内在</p><p>拿到糯米团已经是早上十点多，便急忙赶往了磁器口古镇。</p><h3 id="磁器口"><a href="#磁器口" class="headerlink" title="磁器口"></a>磁器口</h3><p>磁器口古镇原名瓷器口镇、白崖镇、白岩场镇，因明帝朱允炆退位后隐居于此，也叫龙隐镇，位于重庆市沙坪坝区，比邻嘉陵江，有“小重庆”之称。自明、清时期以来磁器口一直是重要的水陆码头，为嘉陵江下游物资集散地。现在的磁器口已经是和丽江完全一样的商业化购物街了，没有什么意思，随处飘荡着劣质火锅底料的味道。这里著名的特色小吃有陈麻花、古镇鸡杂、毛血旺等。向来不太喜欢喧嚣闹市的我便选择了一条小径拾级而上。</p><p>磁器口入口与陈麻花</p><p><img src="https://alicdn.kmahyyg.xyz/asset_files/cqcd2019/cq-day2/2019cq-d2-4.jpg" alt="CQKRK"></p><p><img src="https://alicdn.kmahyyg.xyz/asset_files/cqcd2019/cq-day2/2019cq-d2-5.jpg" alt="CQKCMH"></p><p>磁器口的歇脚小栈和一只悠然自得的流浪猫</p><p><img src="https://alicdn.kmahyyg.xyz/asset_files/cqcd2019/cq-day2/2019cq-d2-6.jpg" alt="CQKLittleShop"></p><p><img src="https://alicdn.kmahyyg.xyz/asset_files/cqcd2019/cq-day2/2019cq-d2-7.jpg" alt="CQKCat"></p><p>磁器口的人来人往与变脸艺术</p><p><img src="https://alicdn.kmahyyg.xyz/asset_files/cqcd2019/cq-day2/2019cq-d2-8.jpg" alt="CQKPeople"></p><p><img src="https://alicdn.kmahyyg.xyz/asset_files/cqcd2019/cq-day2/2019cq-d2-9.jpg" alt="CQKBIL"></p><h3 id="重庆记忆"><a href="#重庆记忆" class="headerlink" title="重庆记忆"></a>重庆记忆</h3><p>沿小径而上之后来到了一座博物馆，名字叫做重庆记忆。这里保存了过去几十年的粗瓷精品和脸谱艺术杰作，更有与现代艺术结合的工艺品。</p><p><img src="https://alicdn.kmahyyg.xyz/asset_files/cqcd2019/cq-day2/2019cq-d2-10.jpg" alt="CQJY1"></p><p><img src="https://alicdn.kmahyyg.xyz/asset_files/cqcd2019/cq-day2/2019cq-d2-11.jpg" alt="CQJY2"></p><p><img src="https://alicdn.kmahyyg.xyz/asset_files/cqcd2019/cq-day2/2019cq-d2-12.jpg" alt="CQJY3"></p><p><img src="https://alicdn.kmahyyg.xyz/asset_files/cqcd2019/cq-day2/2019cq-d2-13.jpg" alt="CQJY4"></p><h2 id="Day-2-下午"><a href="#Day-2-下午" class="headerlink" title="Day 2 - 下午"></a>Day 2 - 下午</h2><h3 id="离奇的被动逃票经历-——-南山一棵树"><a href="#离奇的被动逃票经历-——-南山一棵树" class="headerlink" title="离奇的被动逃票经历 —— 南山一棵树"></a>离奇的被动逃票经历 —— 南山一棵树</h3><p>离开重庆记忆之后，实在没找到合适的吃午饭的地方，便只好选择 M 记 <del>作为我家食堂</del>。那天正值周末，又是雾都难得的晴天，便有很多人前往南山。（PS. 土豆君在这里建议有条件的朋友晚上前往，重庆夜间全景更加美丽。因为时间不够，我只能白天去了…）到了上山的半路便堵车了…心急如焚却又想按照约定时间到达的土豆只好选择下车步行，恰好碰上了两个本地人。便决定徒步爬山，抄“近道”尽快到达…(结果走了远道还绕到深山老林中…)</p><p>庆幸小时候经常爬山，爬上的本领在这里派上了用场，一路奋斗之后却不小心来到了接近山顶的位置。而南山一棵树却在山的半山腰…气喘吁吁、先上后下走了接近40分钟之后终于发现了常规人类建筑XD ，意外之中发现已经进入了景区，就这样莫名奇妙爬了个山、逃了个票…</p><p>雾气蒙蒙的南山深处</p><p><img src="https://alicdn.kmahyyg.xyz/asset_files/cqcd2019/cq-day2/2019cq-d2-14.jpg" alt="NSYKSInMountain"></p><h3 id="长江索道"><a href="#长江索道" class="headerlink" title="长江索道"></a>长江索道</h3><p>不废话，直接上图，“行千里 致广大”</p><p><img src="https://alicdn.kmahyyg.xyz/asset_files/cqcd2019/cq-day2/2019cq-d2-15.jpg" alt="CJSD1"></p><p><img src="https://alicdn.kmahyyg.xyz/asset_files/cqcd2019/cq-day2/2019cq-d2-16.jpg" alt="CJSD2"></p><h3 id="晚饭-——-秀孃串串香"><a href="#晚饭-——-秀孃串串香" class="headerlink" title="晚饭 —— 秀孃串串香"></a>晚饭 —— 秀孃串串香</h3><p>深藏于小巷的居民楼深处，又是一座名声大噪的街边小店、到达时接近下午5点，却已需要等位… 还是上面的那句老话： <strong>一个城市的灵魂，或许正是在这些街边小摊和市井民众上体现出来的那一种精神吧。</strong></p><p>(PPS. 重庆的妹子真的很漂亮哎~)</p><p><img src="https://alicdn.kmahyyg.xyz/asset_files/cqcd2019/cq-day2/2019cq-d2-17.jpg" alt="XNCCX"></p><h2 id="Day-2-夜"><a href="#Day-2-夜" class="headerlink" title="Day 2 - 夜"></a>Day 2 - 夜</h2><p>来重庆，没有看过重庆的夜景，就是白来了。夜晚，朝天门码头，两江交汇。未来，希望还有机会和那个 ta 再来一次。</p><hr><p><img src="https://alicdn.kmahyyg.xyz/asset_files/cqcd2019/cq-day2/2019cq-d2-27.jpg" alt="2019cq-d2-27.jpg"></p><p><img src="https://alicdn.kmahyyg.xyz/asset_files/cqcd2019/cq-day2/2019cq-d2-24.jpg" alt="2019cq-d2-24.jpg"></p><p><img src="https://alicdn.kmahyyg.xyz/asset_files/cqcd2019/cq-day2/2019cq-d2-18.jpg" alt="2019cq-d2-18.jpg"></p><p><img src="https://alicdn.kmahyyg.xyz/asset_files/cqcd2019/cq-day2/2019cq-d2-26.jpg" alt="2019cq-d2-26.jpg"></p><p><img src="https://alicdn.kmahyyg.xyz/asset_files/cqcd2019/cq-day2/2019cq-d2-22.jpg" alt="2019cq-d2-22.jpg"></p><p><img src="https://alicdn.kmahyyg.xyz/asset_files/cqcd2019/cq-day2/2019cq-d2-19.jpg" alt="2019cq-d2-19.jpg"></p><p><img src="https://alicdn.kmahyyg.xyz/asset_files/cqcd2019/cq-day2/2019cq-d2-21.jpg" alt="2019cq-d2-21.jpg"></p><p><img src="https://alicdn.kmahyyg.xyz/asset_files/cqcd2019/cq-day2/2019cq-d2-25.jpg" alt="2019cq-d2-25.jpg"></p><p><img src="https://alicdn.kmahyyg.xyz/asset_files/cqcd2019/cq-day2/2019cq-d2-28.jpg" alt="2019cq-d2-28.jpg"></p><p><img src="https://alicdn.kmahyyg.xyz/asset_files/cqcd2019/cq-day2/2019cq-d2-30.jpg" alt="2019cq-d2-30.jpg"></p><p><img src="https://alicdn.kmahyyg.xyz/asset_files/cqcd2019/cq-day2/2019cq-d2-20.jpg" alt="2019cq-d2-20.jpg"></p><p><img src="https://alicdn.kmahyyg.xyz/asset_files/cqcd2019/cq-day2/2019cq-d2-29.jpg" alt="2019cq-d2-29.jpg"></p><p><img src="https://alicdn.kmahyyg.xyz/asset_files/cqcd2019/cq-day2/2019cq-d2-23.jpg" alt="2019cq-d2-23.jpg"></p><hr><p>船内一景</p><p><img src="https://alicdn.kmahyyg.xyz/asset_files/cqcd2019/cq-day2/2019cq-d2-31.jpg" alt="InsideShip"></p><p>The END</p><p>Rev.1 2019.2.23~2.24 于 学校宿舍</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在正文之前&quot;&gt;&lt;a href=&quot;#写在正文之前&quot; class=&quot;headerlink&quot; title=&quot;写在正文之前&quot;&gt;&lt;/a&gt;写在正文之前&lt;/h2&gt;&lt;p&gt;刚刚在 &lt;a href=&quot;https://www.douyu.com/12479&quot; target=&quot;_bla
      
    
    </summary>
    
    
      <category term="Personal" scheme="https://www.kmahyyg.xyz/tags/Personal/"/>
    
  </entry>
  
  <entry>
    <title>2019 新年之旅 - 重庆 Day 1</title>
    <link href="https://www.kmahyyg.xyz/2019/cqcd-trip-cqday1/"/>
    <id>https://www.kmahyyg.xyz/2019/cqcd-trip-cqday1/</id>
    <published>2019-02-24T00:06:21.000Z</published>
    <updated>2019-02-24T12:39:17.218Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重庆"><a href="#重庆" class="headerlink" title="重庆"></a>重庆</h1><h2 id="逛吃逛吃-重庆-Day-1"><a href="#逛吃逛吃-重庆-Day-1" class="headerlink" title="逛吃逛吃 - 重庆 - Day 1"></a>逛吃逛吃 - 重庆 - Day 1</h2><h3 id="糟糕的交通"><a href="#糟糕的交通" class="headerlink" title="糟糕的交通"></a>糟糕的交通</h3><p>这一次的旅行安排的实际非常仓促，因为学习、春运临近的多重压力，并没有太过仔细的看别人之前写过的攻略。导致了很多本可以避免的失误，下次还是做清楚计划再继续吧。 <del> 其实是多带了一位亲人，做详细计划什么的，不存在的（划掉划掉）</del> 原定三天的行程，由于交通原因，实际只剩下两天半。</p><p>第一天早早到达了机场，飞机起飞延误了半个小时，最终导致了整体延误了大约 20 分钟。一到山城，便被这”山”来了个”下楼威”，建议来这里的朋友都尽可能减少行李的体积。地铁站和任何一个你可能会去的知名建筑物总是相隔 700 ～ 800 米的距离，正所谓坐公交什么的都是没意思的。你或许会说有共享单车，很抱歉，由于重庆多山的地势，加之临近江边空气潮湿、道路日常湿滑，基本上你与共享单车是绝缘的。支付宝支持的几家自行车中只有 OFO 有覆盖，然而业已接近破产的 OFO，实际上根本找不到可用车辆。地铁的站内换乘，更多的可以视为跨站换乘，同一站的两条线，乘车站台总是天上和地下，每次都能让你爬得气喘吁吁。安检强制检查液体，也复杂了一些手续，加之整体公共交通接驳不好，走路便成为了日常。这里还请未来需要前往的朋友注意。</p><p><img src="https://alicdn.kmahyyg.xyz/asset_files/cqcd2019/cq-day1/2019cq-1.jpg" alt="Running with the underground"></p><h3 id="AirBNB-in-China"><a href="#AirBNB-in-China" class="headerlink" title="AirBNB in China"></a>AirBNB in China</h3><p>第一天到达住处之后最让我惊讶的就是这次的住所，这次的住所在 AirBNB （然而只有 Bed 并没有 And Breakfest）预定，房东小姐姐非常的热情，人也非常美丽，提前为我们准备了城市一卡通，免去了一些忧虑。房子的布局类似单身公寓，装修非常的有逼格，面对阳台就是江景，你大可晚上买上一些串串在窗边边吃边赏。重庆一卡通可以在任意一个地铁站充值，个人推荐使用，最有用的地方是长江索道，这个我们后面再提，支付宝的乘车码在这里的所有公交是通用的，遗憾的是不含地铁，所以并没有什么卵用。地铁覆盖率非常高，重庆的地面交通规划十分糟糕，单行道+晴天堵车+下雨堵车+平均20点的公交末班，让人毫无出行的心意。出租车起步价 10 元，额外加价 2.3 元/公里，也算是有点诚意吧。当地的交通状况和路况就决定了公交和出租司机都具有 F1 赛车的潜质，请大家务必小心。</p><p><img src="https://alicdn.kmahyyg.xyz/asset_files/cqcd2019/cq-day1/2019cq-2.jpg" alt="AirBNB House"></p><h2 id="Day-1-中午"><a href="#Day-1-中午" class="headerlink" title="Day 1 - 中午"></a>Day 1 - 中午</h2><p>折腾了大半晌之后到达重庆便已经是中午一点多了，肚子早已饿得不行，来到住所放完了行李，便直奔着重庆最大的美食城——八一好吃街而去：</p><p><img src="https://alicdn.kmahyyg.xyz/asset_files/cqcd2019/cq-day1/2019cq-3.jpg" alt="81HCJ"></p><p>来重庆，自然要品尝的第一件事情就是最地道的酸辣粉。整个重庆最为有名的就是这家好又来：</p><p><img src="https://alicdn.kmahyyg.xyz/asset_files/cqcd2019/cq-day1/2019cq-4.jpg" alt="HYLSLF"></p><p>整体来看和本地的酸辣粉相比差别不大，不过感觉更加的辣，米粉偏干，不太适合云南人的口味。</p><p>吃完了辣的， <del>为了弥补味觉的创伤</del> ，便考虑前往寻找一些平和温凉的食物。挑来挑去，苦于没有一个详细的计划，七拐八绕之后，在日月光广场的 -1F 找到了这个地方： 山城老冰粉。</p><p><img src="https://alicdn.kmahyyg.xyz/asset_files/cqcd2019/cq-day1/2019cq-5.jpg" alt="LBFSW"></p><p>淡淡的桂花糖，温暖的芝麻香和一些坚果，凉凉的糍粑粉，让人有一种独特的惊艳感。</p><p><img src="https://alicdn.kmahyyg.xyz/asset_files/cqcd2019/cq-day1/2019cq-6.jpg" alt="LBFDM"></p><p>这家店店面隐藏在商场的一个角落之中，很是难找，毕竟“好事多磨”，希望下次去的时候可以再次体验吧。<br>店家老板曾经在云南学习，十分怀念云南的鲜花、阳光和新鲜的芥菜，在他乡听到这样的一种谈论，也是有些暖暖的欣慰。</p><h2 id="Day-1-下午"><a href="#Day-1-下午" class="headerlink" title="Day 1 - 下午"></a>Day 1 - 下午</h2><p>吃完了冰粉，已经接近下午四点。看了看地图，发现在这该死的山城里 GPS 总是失灵，由于接下来时间安排的限制，只能去走走最近的一些景点了。地图上最近一个 POI 就是新华日报社旧址，旧址现已被翻修一新，内部展览着过去出版的新华日报和报社工作人员的生活环境还有一些当时新华日报的成就。下面两张图是我觉得记忆很深的一部分：（门口的标语我只拍了一半，不知道当时创立新华日报的编辑看到现在的新华日报和这两幅标语，心中会是何种滋味）</p><p><img src="https://alicdn.kmahyyg.xyz/asset_files/cqcd2019/cq-day1/2019cq-7.jpg" alt="OldChinaDaily1"></p><p><img src="https://alicdn.kmahyyg.xyz/asset_files/cqcd2019/cq-day1/2019cq-8.jpg" alt="OldChinaDaily2"></p><p>约莫逛了一个多小时，就又到了饭点，便来到了重庆的解放碑商圈。这座纪念碑，象征了新中国成立之前那几辈人的艰辛，是民国人的“精神堡垒”。</p><p><img src="https://alicdn.kmahyyg.xyz/asset_files/cqcd2019/cq-day1/2019cq-9.jpg" alt="RevolutionMemorial"></p><h2 id="Day-1-晚上"><a href="#Day-1-晚上" class="headerlink" title="Day 1 - 晚上"></a>Day 1 - 晚上</h2><p>晚上，提前和大哥约了晚饭，<a href="https://map.baidu.com/?shareurl=1&amp;poiShareUid=5a993447ac44d6b2b8bd633d" target="_blank" rel="noopener">POI 锅锅筵水八块重庆老火锅</a>。味道很正，没有让重庆人做出“最大的让步” （XD 好像我还是能吃辣的），原本说吃完饭还有时间就去洪崖洞逛逛，结果边吃边聊，吃完就接近 22 点了，直接回了住处，一天就这样结束了。</p><p><img src="https://alicdn.kmahyyg.xyz/asset_files/cqcd2019/cq-day1/2019cq-10.jpg" alt="GGYHotPot"></p><p>店门口夜间漫步一景，略微下着些小雨，对岸的那个建筑就是重庆大剧院。</p><p>THE END</p><h2 id="DEPRECATED"><a href="#DEPRECATED" class="headerlink" title="DEPRECATED"></a>DEPRECATED</h2><p>由于时间安排不当，当天的行程被 DEPRECATED 了下列 POI：</p><ul><li>洪崖洞</li><li>南山一棵树</li></ul><p>Rev.1 2019.1.20 于 G8710 次列车<br>Rev.2 2019.1.24 于 家中<br>Rev.3 2019.2.23 于 学校宿舍 终稿</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;重庆&quot;&gt;&lt;a href=&quot;#重庆&quot; class=&quot;headerlink&quot; title=&quot;重庆&quot;&gt;&lt;/a&gt;重庆&lt;/h1&gt;&lt;h2 id=&quot;逛吃逛吃-重庆-Day-1&quot;&gt;&lt;a href=&quot;#逛吃逛吃-重庆-Day-1&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="Personal" scheme="https://www.kmahyyg.xyz/tags/Personal/"/>
    
  </entry>
  
  <entry>
    <title>2019 新年之旅 - 前言也是结尾</title>
    <link href="https://www.kmahyyg.xyz/2019/cqcd-trip/"/>
    <id>https://www.kmahyyg.xyz/2019/cqcd-trip/</id>
    <published>2019-02-22T21:06:04.000Z</published>
    <updated>2019-02-24T12:39:17.218Z</updated>
    
    <content type="html"><![CDATA[<iframe src="https://open.spotify.com/embed/track/7AofxV7mKRmUf8AT0lclMy" width="300" height="380" frameborder="0" allowtransparency="true" allow="encrypted-media" autoplay="true"></iframe><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><blockquote><p>夫景以情合，憎以景生，初不相离，唯意所适，截分两杨，则情不足兴，而景非其景。</p></blockquote><p>2019 年到来的是如此的快，不知不觉间大学已经来到了第二学年的中间。经过了大二上半期各个方面的磨难，终究是苦尽甘来。等待成绩出炉的日子是那么的忐忑，还好最终的结果并不让人那么失望。18 号早晨，起得很早，来到了重庆，开始了这一年的旅行。</p><h2 id="见到大哥这个意外的惊喜"><a href="#见到大哥这个意外的惊喜" class="headerlink" title="见到大哥这个意外的惊喜"></a>见到大哥这个意外的惊喜</h2><p>一直以一种程序猿固有的印象在猜测大哥应该会是一个五大三粗的程序猿吧，实际见到之后发现是一个开朗的大帅哥。奇妙般的相识带来了这次数年之后的奇遇，感谢缘分吧。非常开心快乐的一次旅行。</p><h2 id="莫名其妙的想到了自己的感情"><a href="#莫名其妙的想到了自己的感情" class="headerlink" title="莫名其妙的想到了自己的感情"></a>莫名其妙的想到了自己的感情</h2><blockquote><p>All that really matters is don’t stop trying.</p></blockquote><p>期间不经意的想到最近一些事情，心里总是有一些莫名的担心，谁知道下一个学期会发生什么呢。和大哥一起吃完饭的那天也晚上微醺之后回到住处，忽然也提到了一些相关的东西。大哥提醒了我，到底我和我的 Mate 想要的过程还是结果，这是一个需要认真思考的问题。”越担心失去，越容易失去”，真的是一语成谶。人，本就是一个矛盾与统一的结合体。还是想明白上面的问题之后就不要想太多的东西了吧，毕竟选择已经做下，唯一剩下就是全身心的投入。再放下一点点吧，真的那么爱她。剩下的，或许，时间会告诉我答案吧。</p><h2 id="把感受放到这里"><a href="#把感受放到这里" class="headerlink" title="把感受放到这里"></a>把感受放到这里</h2><p>咕咕咕了很久之后，这几篇游记博客终于开始动工了。最近总是在心里想一个人，想来想去，别人都不把你放在心上，那也没必要太过折腾了。最近在忙着考驾照，从周围的朋友那里听了不少故事，让人觉得还是独自一人的宇宙更加广大。</p><p>之前答应了一个人，这个假期和 ta 一起去游历祖国的大好河山，我原本打算现在就开始做下各种积累和准备，现在看起来也没必要了。回来之后遇到了一个小姐姐，有些事情也不太方便在这里写出，只能感叹一句，陌生人有时候比你想象中温暖的太多太多。接下来，我会更加的向事业方向发展，考虑斩断一些完全没有必要的社交链，还是浪费了太多心去维护一段感情了。</p><p>某天在 <a href="https://kirikira.moe/post/34/" target="_blank" rel="noopener">kiri 大佬的博客</a> 看到了 ta 的年末感想，有这样几段，特摘录在此，不做太多的评论和解释了：</p><blockquote><p>九月底的时候，我突然觉得反正已经孤单一人了，不如干点没有一个人干过的事吧！于是直接订下了去长沙和重庆的国庆机票/车票，联系上在这两个地方的同学做免费导游，开始了第一次的一人旅游。在长沙招待我的是曾经一段不成功的恋情的对象和中学时代最好的朋友。与她重逢时，庆幸的是面对面的气氛并没有那么尴尬，尽管已经有一年多没见，还是能找到一些话题扯东扯西，从过去扯到现在，从其他人扯到自己；但不幸的是，她还是我喜欢的那个她，曾经让我着迷的她的可爱之处一点没变，在稚气的底下还多了几分成熟，一想到我们已经不可能重来了这件事就让我有些许伤感。</p></blockquote><blockquote><p>在这样的念头起来的时候，我确信了几件事情。对我这种人来说，行动总比空坐着纠结犹豫要好，一旦开始纠结的话，不如马上按照第一感觉行动起来，不给大脑迟疑的机会；我也不是会后悔的人，不论现在的处境如何，都是自己过去的一个一个选择累计起来得到的结果，如果当时的选择在那个时刻看来是合情合理的，那么即使再给我一次机会消除记忆回到过去，我也肯定是会做出同样的选择来，既然如此就没什么好后悔的了。</p></blockquote><blockquote><p><strong>“不是两个人就不好，而是我一个人就很好。”这句话从以前开始我就经常念叨，但在最近一两年我才确信了这件事。两个人是很美好，但是要找到另一个志同道合、两厢情愿的异性也是一件非常难的事。与其每天被发情所苦，或陷入不可能的单恋中浪费人生，再以自己感动自己收尾，不如发现一个人的好处。一个人可以省下一次约会一顿饭就三位数的钱，可以不用上班打卡一样的定期见面和晚安，可以来一场毫无规划的到处乱走的旅行，可以当一回傻逼，在跨年的夜里走到人山人海的江滩，等着不存在的烟花。</strong></p></blockquote><h2 id="下一次旅行"><a href="#下一次旅行" class="headerlink" title="下一次旅行"></a>下一次旅行</h2><p><img src="https://alicdn.kmahyyg.xyz/asset_files/cqcd2019/2019cqcd-preface.jpg" alt="LOVE TO YU"></p><p>本来是和我心里那个人一起去游山玩水，现在看起来只能呵呵。下一个目的地，或许是某个现代化大都市，亦或许是某个寂静的小镇吧。这次除了重庆的前两天的行程之外，过得很不愉快，我讨厌那种喧嚣吵闹的所谓“旅游热点”，只想一个人在人烟稀少的地方，观察生活和自然的那份纯净空灵的美好。再也不会去所谓的旅游热点了…</p><p>The END</p><p>Rev.1 2019.1.20 于 G8710 次列车<br>Rev.2 2019.1.24 于 家中<br>Rev.3&amp;4&amp;5 2019.2.22 于 学校宿舍 终稿</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;iframe src=&quot;https://open.spotify.com/embed/track/7AofxV7mKRmUf8AT0lclMy&quot; width=&quot;300&quot; height=&quot;380&quot; frameborder=&quot;0&quot; allowtransparency=&quot;true&quot; 
      
    
    </summary>
    
    
      <category term="Personal" scheme="https://www.kmahyyg.xyz/tags/Personal/"/>
    
  </entry>
  
  <entry>
    <title>2018 汇编大作业</title>
    <link href="https://www.kmahyyg.xyz/2019/ASM-BigHomework/"/>
    <id>https://www.kmahyyg.xyz/2019/ASM-BigHomework/</id>
    <published>2019-02-08T09:24:00.000Z</published>
    <updated>2019-02-24T12:39:17.218Z</updated>
    
    <content type="html"><![CDATA[<h2 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h2><p><img src="https://alicdn.kmahyyg.xyz/asset_files/2019-asmbighw-flow.webp" alt="workflow chart"></p><p>Storage:</p><ul><li>Test</li></ul><p>Encrypt:</p><ul><li>Test</li></ul><p>Decrypt:</p><ul><li>Test</li></ul><p>MBR PlaceHolder:</p><h2 id="Source-code"><a href="#Source-code" class="headerlink" title="Source code"></a>Source code</h2><p>Check <a href="https://github.com/kmahyyg/MBRLock" target="_blank" rel="noopener">Github Repository</a> , Please.</p><p>All source codes are well-commented. If you have any questions, please open a Issue in GitHub.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>观察发现 MS-DOS 7.11 和 WinXP 的 磁盘，1～31 扇区均为空！（0 扇区为 MBR）</p><ul><li><a href="https://stackoverflow.com/questions/21463908/x86-instructions-to-power-off-computer-in-real-mode" target="_blank" rel="noopener">https://stackoverflow.com/questions/21463908/x86-instructions-to-power-off-computer-in-real-mode</a></li><li><a href="https://wiki.osdev.org/APM" target="_blank" rel="noopener">https://wiki.osdev.org/APM</a></li><li><a href="https://stackoverflow.com/questions/1396909/ret-retn-retf-how-to-use-them" target="_blank" rel="noopener">https://stackoverflow.com/questions/1396909/ret-retn-retf-how-to-use-them</a></li><li><a href="https://stackoverflow.com/questions/39474332/assembly-difference-between-var-and-var/39474660" target="_blank" rel="noopener">https://stackoverflow.com/questions/39474332/assembly-difference-between-var-and-var/39474660</a></li><li><a href="https://sourcegraph.com/github.com/sunnyden/MBRLock@master/" target="_blank" rel="noopener">https://sourcegraph.com/github.com/sunnyden/MBRLock@master/</a></li><li><a href="https://www.felixcloutier.com/x86/" target="_blank" rel="noopener">https://www.felixcloutier.com/x86/</a></li><li><a href="https://asminst.kmahyyg.xyz/" target="_blank" rel="noopener">https://asminst.kmahyyg.xyz/</a></li><li><a href="https://blog.csdn.net/u013630349/article/details/50370227" target="_blank" rel="noopener">https://blog.csdn.net/u013630349/article/details/50370227</a></li><li><a href="https://docs.microsoft.com/en-us/cpp/cpp/argument-passing-and-naming-conventions?view=vs-2017" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/cpp/cpp/argument-passing-and-naming-conventions?view=vs-2017</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;整体思路&quot;&gt;&lt;a href=&quot;#整体思路&quot; class=&quot;headerlink&quot; title=&quot;整体思路&quot;&gt;&lt;/a&gt;整体思路&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://alicdn.kmahyyg.xyz/asset_files/2019-asmbighw
      
    
    </summary>
    
    
      <category term="Tech" scheme="https://www.kmahyyg.xyz/tags/Tech/"/>
    
      <category term="School" scheme="https://www.kmahyyg.xyz/tags/School/"/>
    
  </entry>
  
  <entry>
    <title>YNU - 汇编语言程序设计实验报告 4-5</title>
    <link href="https://www.kmahyyg.xyz/2019/ASM-exp-report2/"/>
    <id>https://www.kmahyyg.xyz/2019/ASM-exp-report2/</id>
    <published>2019-01-11T20:58:01.000Z</published>
    <updated>2019-02-24T12:39:17.218Z</updated>
    
    <content type="html"><![CDATA[<h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>如未署名，所有 *.kmahyyg.xyz 的域名下的版权均为本人所有，遵循对应站点下的授权协议。</p><p>本篇文章授权 采用 CC BY-NC-ND 3.0 Unported 协议，禁止转载。</p><h1 id="Experiment-4"><a href="#Experiment-4" class="headerlink" title="Experiment 4"></a>Experiment 4</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>使用虚拟机 Qemu-KVM 和调试器 Bochs，执行，调试 MBR 扇区代码，了解计算机启动的原理和 MBR 扇区代码的功能。</p><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><ol><li>阅读参考源程序并增加注释；</li><li>在参考源程序中增加指令(不要改变原程序的功能)，为程序增加功能：输出你的学号和姓名拼音；</li></ol><p>SRC:     <a href="https://gist.github.com/kmahyyg/ce0d0e3079363f7be5d91f7ace0d9c0d" target="_blank" rel="noopener">https://gist.github.com/kmahyyg/ce0d0e3079363f7be5d91f7ace0d9c0d</a></p><ol start="3"><li>使用 NASM 工具将修改后的实验源程序编译为 .bin 文件；</li><li>将 .bin 文件用 dd 写入虚拟机硬盘 MBR 扇区；</li><li>使用 Qemu-KVM 虚拟机观察写入 .bin 文件的执行结果；</li></ol><p>Tutorial:    <a href="https://blog.kmahyyg.xyz/2018/ASM-exp-report/#%E5%AE%9E%E9%AA%8C%E6%93%8D%E4%BD%9C%EF%BC%9A%E7%BC%96%E8%AF%91%E5%AE%8C%E6%88%90%E5%90%8E%E7%9A%84-BOCHS-%E5%AF%BC%E5%85%A5" target="_blank" rel="noopener">https://blog.kmahyyg.xyz/2018/ASM-exp-report/#%E5%AE%9E%E9%AA%8C%E6%93%8D%E4%BD%9C%EF%BC%9A%E7%BC%96%E8%AF%91%E5%AE%8C%E6%88%90%E5%90%8E%E7%9A%84-BOCHS-%E5%AF%BC%E5%85%A5</a></p><ol start="6"><li>关闭 Qemu-KVM，使用 BochsDBG 虚拟机调试写入在虚拟硬盘 MBR 扇区中的程序；</li></ol><p><img src="https://alicdn.kmahyyg.xyz/asset_files/2018-asmexp3-02.webp" alt="2018-asmexp3-02.png"></p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ol><li>计算机如何在屏幕上显示字符？</li></ol><p><a href="https://asm.kmahyyg.xyz/exps/exp7-transfer.html#quiz-2%EF%BC%9A-%E6%A0%B9%E6%8D%AE%E6%9D%90%E6%96%99%E7%BC%96%E7%A8%8B" target="_blank" rel="noopener">https://asm.kmahyyg.xyz/exps/exp7-transfer.html#quiz-2%EF%BC%9A-%E6%A0%B9%E6%8D%AE%E6%9D%90%E6%96%99%E7%BC%96%E7%A8%8B</a></p><ol start="2"><li>如何输入输出 10 进制数据？如何输入数字、字符串？</li></ol><p><a href="https://computer.howstuffworks.com/bios1.htm" target="_blank" rel="noopener">https://computer.howstuffworks.com/bios1.htm</a></p><p><a href="https://blog.csdn.net/qq_28598203/article/details/51081368" target="_blank" rel="noopener">https://blog.csdn.net/qq_28598203/article/details/51081368</a></p><p>结合中断向量表实现。</p><ol start="3"><li>MBR 扇区有什么特点？MBR 扇区中的代码实现什么功能？</li></ol><p><a href="https://wiki.osdev.org/MBR_(x86)" target="_blank" rel="noopener">https://wiki.osdev.org/MBR_(x86)</a></p><ol start="4"><li>简述计算机复位后的启动过程。</li></ol><p><a href="https://wiki.osdev.org/Boot_Sequence" target="_blank" rel="noopener">https://wiki.osdev.org/Boot_Sequence</a></p><h1 id="Experiment-5"><a href="#Experiment-5" class="headerlink" title="Experiment 5"></a>Experiment 5</h1><h2 id="实验目的-1"><a href="#实验目的-1" class="headerlink" title="实验目的"></a>实验目的</h2><p>了解计算机屏幕显示的原理，编程实现显存映射与中断 <code>int 10H</code> 式。</p><h2 id="实验内容-1"><a href="#实验内容-1" class="headerlink" title="实验内容"></a>实验内容</h2><ol><li>使用控制显存显示内容。</li></ol><blockquote><p>略，之前的实现均使用的这种方式。MASM 与 NASM 的差异，在使用这种方式时差异不大，此处略去不表。</p></blockquote><ol start="2"><li>使用 <code>int 10H</code> 方式显示数据。</li></ol><p>看这里！这里有代码： </p><p>MASM: <a href="https://gist.github.com/kmahyyg/4e8dc523f513ff78a53c18e4234460af" target="_blank" rel="noopener">https://gist.github.com/kmahyyg/4e8dc523f513ff78a53c18e4234460af</a></p><p>NASM: <a href="https://gist.github.com/kmahyyg/4e8dc523f513ff78a53c18e4234460af" target="_blank" rel="noopener">https://gist.github.com/kmahyyg/4e8dc523f513ff78a53c18e4234460af</a></p><h2 id="思考题-1"><a href="#思考题-1" class="headerlink" title="思考题"></a>思考题</h2><ol><li>注释源程序</li></ol><p>已经注释了，懒得多写废话，具体的详细文档自己看后面的 Reference。这里略微一提， BIOS 是一个最小型的系统，在硬件支持 int 13h 对应的显示模式的前提下，可以通过 BIOS 中断向量 int 10h 调用显示 API。</p><p>具体参考这里 <a href="https://protas.pypt.lt/informatika/assembler/writing_to_the_screen" target="_blank" rel="noopener">https://protas.pypt.lt/informatika/assembler/writing_to_the_screen</a></p><p>2.显示字符的方式</p><p>就两种，实验目的里写的很清楚，具体的自己去查资料。</p><h1 id="Experiment-6"><a href="#Experiment-6" class="headerlink" title="Experiment 6"></a>Experiment 6</h1><h2 id="实验目的-2"><a href="#实验目的-2" class="headerlink" title="实验目的"></a>实验目的</h2><p>接受键盘输入，保存到磁盘；从磁盘读取，显示到屏幕。</p><h2 id="实验实现"><a href="#实验实现" class="headerlink" title="实验实现"></a>实验实现</h2><p>目前问题：</p><p>Can： 接受输入、保存到 FDD，从磁盘读取，读取到指定的具体的固定 RAM 地址并显示。</p><p><del>Cannot： 读取到变量对应的地址并显示，读取 FDD 成功但写入 RAM 失败… 已修复： dx 和 bx 两个寄存器中传入的地址存在问题</del></p><p>接受输入，写入 FDD 的代码：</p><pre class="line-numbers language-asm6502"><code class="language-asm6502">dataarea segment    buffer db 64   ; max 63 bytes string           db ?    string db 64 dup ('$')  ; preallocated with '$', int 21h/0ah outputdataarea endscodesg segment;START PROCmain proc far    assume cs:codesg,ds:dataareastart:;SAVE THE CURRENT SITUATION FOR RET    push ds    sub ax,ax    push ax;POINT CORRESPONDING DATA REGISTER    mov ax,dataarea    mov ds,ax;GET INPUT FROM KEYBOARD    lea dx,buffer    mov ah,0ah    int 21h;PREPARE ES:BX to where data to be wrote into    mov ax,dataarea    mov es,ax    lea bx,string;WRITE DATA TO FDD, 0 Cylinder: 0 Track: 4 Sector;Each sector has 512 bytes    mov ah,3  ; 3 for write    mov al,1  ; how many sectors to write    mov dh,0  ; cylinder    mov ch,0  ; track    mov cl,4  ; sector    mov dl,0  ; drive no.     ;0:FDD-A, 1:FDD-B, 80H:HDD-C, 81H:HDD-D    int 13h     retmain endpcodesg ends    end start <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从 FDD 中读取内容并显示在屏幕上：</p><pre class="line-numbers language-asm6502"><code class="language-asm6502">datasg segment    readout db 512 dup ('$')datasg endscodesg segmentstart:        mov ax,datasg        mov ds,ax        mov es,ax        lea bx,readout   ;ready for read buffer        mov ah,2        mov al,1        mov dh,0        mov ch,0        mov cl,4        mov dl,0        int 13h        mov dx,offset readout        mov ah,9        int 21h        mov ax,4c00h        int 21hcodesg endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>接受输入之后回显打印：</p><pre class="line-numbers language-asm6502"><code class="language-asm6502">;sudo mount -o loop,offset=$(python -c 'print(512*63)') /var/lib/libvirt/images/dosdata.img /mnt/nfs1dataarea segment    buffer db 64           db ?    string db 64 dup ('$')    hint   db 10,13,'$'dataarea endscodesg segmentmain proc far    assume cs:codesg,ds:dataareastart:    push ds    sub ax,ax    push ax    mov ax,dataarea    mov ds,ax    lea dx,buffer    mov ah,0ah    int 21h    mov cx,2newl:    lea dx,hint    mov ah,9h    int 21h    loop newl    lea dx,string    mov ah,9h    int 21h    retmain endpcodesg ends    end start <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>不要忘记打末尾的 <code>h</code></strong></p><pre><code>INT 13h / AH = 02h - read disk sectors into memory.INT 13h / AH = 03h - write disk sectors.    input:AL = number of sectors to read/write (must be nonzero)CH = cylinder number (0..79).CL = sector number (1..18).DH = head number (0..1).DL = drive number (0..3 , for the emulator it depends on quantity of FLOPPY_ files).ES:BX points to data buffer.    return:CF set on error.CF clear if successful.AH = status (0 - if successful).AL = number of sectors transferred. Note: each sector has 512 bytes.</code></pre><pre><code>INT 21h / AH=9 - output of a string at DS:DX. String must be terminated by &#39;$&#39;. example:        org 100h        mov dx, offset msg        mov ah, 9        int 21h        ret        msg db &quot;hello world $&quot;</code></pre><pre><code>INT 21h / AH=0Ah - input of a string to DS:DX, fist byte is buffer size, second byte is number of chars actually read. this function does not add &#39;$&#39; in the end of string. to print using INT 21h / AH=9 you must set dollar character at the end of it and start printing from address DS:DX + 2. </code></pre><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1><p>本学期的汇编课程所有的的随堂实验就到此告一段落，感谢 王逍 老师的精心付出。<br>和 钰 在各方面的帮助，爱你！</p><p>Updated on 2019-01-11 20:58:01<br>Rev. 11</p><h1 id="Reference-1"><a href="#Reference-1" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://thestarman.pcministry.com/asm/mbr/STDMBR.htm" target="_blank" rel="noopener">https://thestarman.pcministry.com/asm/mbr/STDMBR.htm</a></p><p><a href="https://thestarman.pcministry.com/asm/bios/index.html" target="_blank" rel="noopener">https://thestarman.pcministry.com/asm/bios/index.html</a></p><p><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-823-computer-system-architecture-fall-2005/index.htm" target="_blank" rel="noopener">https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-823-computer-system-architecture-fall-2005/index.htm</a></p><p><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-828-operating-system-engineering-fall-2012/index.htm" target="_blank" rel="noopener">https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-828-operating-system-engineering-fall-2012/index.htm</a></p><p><a href="https://stackoverflow.com/questions/41196376/int-10h-13h-bios-string-output-not-working" target="_blank" rel="noopener">https://stackoverflow.com/questions/41196376/int-10h-13h-bios-string-output-not-working</a></p><p><a href="http://www.ablmcc.edu.hk/~scy/CIT/8086_bios_and_dos_interrupts.htm" target="_blank" rel="noopener">http://www.ablmcc.edu.hk/~scy/CIT/8086_bios_and_dos_interrupts.htm</a></p><p><a href="https://wiki.osdev.org/ATA_PIO_Mode" target="_blank" rel="noopener">https://wiki.osdev.org/ATA_PIO_Mode</a></p><p><a href="https://stackoverflow.com/questions/8461363/access-harddrive-using-assembly" target="_blank" rel="noopener">https://stackoverflow.com/questions/8461363/access-harddrive-using-assembly</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;License&quot;&gt;&lt;a href=&quot;#License&quot; class=&quot;headerlink&quot; title=&quot;License&quot;&gt;&lt;/a&gt;License&lt;/h2&gt;&lt;p&gt;如未署名，所有 *.kmahyyg.xyz 的域名下的版权均为本人所有，遵循对应站点下的授权协议。&lt;
      
    
    </summary>
    
    
      <category term="Tech" scheme="https://www.kmahyyg.xyz/tags/Tech/"/>
    
      <category term="School" scheme="https://www.kmahyyg.xyz/tags/School/"/>
    
  </entry>
  
  <entry>
    <title>2018 学年度第二学期既年终总结</title>
    <link href="https://www.kmahyyg.xyz/2019/2018-EndofYear/"/>
    <id>https://www.kmahyyg.xyz/2019/2018-EndofYear/</id>
    <published>2019-01-11T11:55:00.000Z</published>
    <updated>2019-02-24T12:39:17.218Z</updated>
    
    <content type="html"><![CDATA[<p>BGM: 范玮琪 - 蒲公英 (Offered by Spotify)</p><iframe src="https://open.spotify.com/embed/track/2xLr6lYJV01kfzVpeFYM5a" width="300" height="380" frameborder="0" allowtransparency="true" allow="encrypted-media"></iframe><h1 id="2018-年的年终"><a href="#2018-年的年终" class="headerlink" title="2018 年的年终"></a>2018 年的年终</h1><p>一年又在眨眼间悄然逝去，这一年中经历的起伏跌宕，让人难以琢磨，伤心欲绝却又欢天喜地。 2019 年的 1 月 1 日的钟声早已响过，2012 所谓的 “世界末日” 也已经过去了六个年头。</p><h2 id="年终盘点"><a href="#年终盘点" class="headerlink" title="年终盘点"></a>年终盘点</h2><p><del>支付宝和微信、各种银行卡账单什么的就算了。依旧剁手买了很多东西XD，包括 iPad 乞丐版什么的。另外嘛，就是我这个以前从来不知道买东西给姑娘的，现在也会送礼物了。真的很喜欢ta呢。</del><br>这一年可以说是挫折很多，忙到根本没有办法顾及自己休息的一年。<br>在过去的一年里：</p><ul><li>我考了驾照的科目一，却因为学业繁忙没有完成后面的考试。</li><li>Github 上，积极参与了开源项目，将我的绝大部分代码托管到了 Github。</li></ul><p>根据 Github Profile 页的 Contribution 显示，过去的一年中，我完成了 1126 Contribution，其中最忙的单日完成了 34 个 Contribution，平均每天 3.08 次，最长的一次连击发生在 12.10～12.25。</p><ul><li>学业上算是小有成就，勉强算是刚刚踩在达成目标的及格线上吧。</li></ul><p>简略的来说，就这些。</p><h2 id="2018-年的最后一个学期-学习与朋友"><a href="#2018-年的最后一个学期-学习与朋友" class="headerlink" title="2018 年的最后一个学期 @学习与朋友"></a>2018 年的最后一个学期 @学习与朋友</h2><p>这一年中的最后一个学习非常的繁忙，基本上一直维持着连轴转的程度，平均每两个月给自己放一次假也是非常的爆炸，大部分的时间都花在了逍爷的课程上，也算是学有所得。一些令人无奈的数学也是让人烦恼，<br>主要的问题就是找出一个侧重点、安排好自己的时间，不然压根没时间复习其他科目，平常的各科也要齐头并进才好啊。毕竟期末抱佛脚不是长久之技。</p><p>新的一年了，总之还是要把各种薄弱项加强过、理解过才行。</p><p>一个朋友，今年因为异地高考问题，被迫退学，在异乡漂泊了半年多，现在也回来了，不知道他现在怎么样了。</p><h2 id="2018-年跨年的“惊吓”-技术"><a href="#2018-年跨年的“惊吓”-技术" class="headerlink" title="2018 年跨年的“惊吓” @技术"></a>2018 年跨年的“惊吓” @技术</h2><p>在 2018 年的最后几个小时里，学长在陪我高数跨年，一把辛酸泪。好消息是，迎来了逍爷的“惊吓”，一直在等，还算是等来了。</p><h2 id="2019-年的旅行"><a href="#2019-年的旅行" class="headerlink" title="2019 年的旅行"></a>2019 年的旅行</h2><p>开年之初，便是寒假的到来，今年的寒假让人觉得格外的难受，又冷又短，提心吊胆。早早就安排了旅行，重庆和成都。</p><p>顺道去看看哥们，体验一下重庆美的让人窒息的夜景，感受下带不走的成都。</p><p>唯一令人伤心的就是亲爱的钰并不能与我同行。（具体的安排还没做，XD）</p><h2 id="2018-2019-的情感"><a href="#2018-2019-的情感" class="headerlink" title="2018-2019 的情感"></a>2018-2019 的情感</h2><p>这一年的情感生活可以说是五味杂陈。这样的做事显然不符合我一向快刀斩乱麻的风格。不过，天命这种东西，谁知道呢。</p><p>一直都很喜欢钰，可惜去晚了几步。现在嘛，过去的事情就让它过去吧。</p><p>最后的这个月里，真的了解到自己真的用心去喜欢一个人是什么样的从未有过的感觉。为 ta 欢喜，为 ta 忧，仿佛世界没有了 ta，也就没有了中心。</p><p>每天都想见到 ta 甜甜的笑容，想和 ta 去做一些开开心心的事情。</p><p>最重要的一点，我也慢慢开始相信别人。ta 曾经对我说，怕辜负了我的期望。其实这些都是潜移默化之后最终我才发现的，我的唯一的期望或许只是能开开心心的和你长久下去。</p><p>喜欢 ta 的撒娇，喜欢 ta 的可爱，喜欢 ta 甜美的笑容和独特的香味，最喜欢的却是 ta 那天真无暇却又纯洁动人的心灵。</p><h3 id="番外"><a href="#番外" class="headerlink" title="番外"></a>番外</h3><p>一开始那段时间也是不信任的，我就一直在尝试告诉自己无论发生什么事，都是必须以第一信任自己选择的人为前提，所以我一直压在心里。那一段时间真的非常难受。</p><p>现在，这段时间已经度过，或许下一步我该想想怎么和她有更多开心的共同经历了吧。么么哒，钰。</p><h2 id="2019-年的期望"><a href="#2019-年的期望" class="headerlink" title="2019 年的期望"></a>2019 年的期望</h2><ul><li>继续和我深爱的钰甜甜蜜蜜</li><li>上帝保佑，不要挂科</li><li>以战养学，努力学习</li><li>多去几个好玩的地方，多认识其他地方的朋友 </li><li>买个 iPad Pro + Pencil 2 （估计不可能，穷死了）</li><li>练练我的 Djembe，赶快把驾照考完</li><li>还没想到</li></ul><p>好了，就先这样吧。</p><p>2019.1.11 @ AH</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;BGM: 范玮琪 - 蒲公英 (Offered by Spotify)&lt;/p&gt;
&lt;iframe src=&quot;https://open.spotify.com/embed/track/2xLr6lYJV01kfzVpeFYM5a&quot; width=&quot;300&quot; height=&quot;380
      
    
    </summary>
    
    
      <category term="School" scheme="https://www.kmahyyg.xyz/tags/School/"/>
    
      <category term="Personal" scheme="https://www.kmahyyg.xyz/tags/Personal/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络期末复习稿</title>
    <link href="https://www.kmahyyg.xyz/2019/ynu-networkbasic/"/>
    <id>https://www.kmahyyg.xyz/2019/ynu-networkbasic/</id>
    <published>2019-01-09T00:06:43.000Z</published>
    <updated>2019-02-24T12:39:17.218Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Computer-Network-Chapter-1-Basic-Concepts"><a href="#Computer-Network-Chapter-1-Basic-Concepts" class="headerlink" title="Computer Network - Chapter 1 - Basic Concepts"></a>Computer Network - Chapter 1 - Basic Concepts</h1><p>Host: End System.</p><p>Routers: Forward packets(chunks) of data through network.</p><p>Protocols: Control sending and receiving of messages. A protocol is a set of rules that govern data communication. It is an agreement between the communication entities. The elements of protocol are syntax, semantics, and timing.  </p><ul><li>Syntax: Data structure or format. </li><li>Semantics: the meaning of each section of bits. </li><li>Timing: When to send and how fast it should be.</li></ul><p>C/S: Client/Server Model: Client host requests, receives service from server.</p><p>Peer2Peer model: Minimal (or no) use of dedicated server.</p><h2 id="Level-5-7-Layers-Important"><a href="#Level-5-7-Layers-Important" class="headerlink" title="Level 5/7 Layers (Important)"></a>Level 5/7 Layers (Important)</h2><p>Level 5:</p><p>TCP/IP Layer:</p><table><thead><tr><th style="text-align:center">Application Layer</th><th style="text-align:center">Message</th></tr></thead><tbody><tr><td style="text-align:center">Transport Layer</td><td style="text-align:center">Segment</td></tr><tr><td style="text-align:center">Network Layer</td><td style="text-align:center">Datagram</td></tr><tr><td style="text-align:center">Link Layer</td><td style="text-align:center">Frame</td></tr></tbody></table><p>ISO/OSI Layer:</p><table><thead><tr><th style="text-align:center">Application Layer</th><th style="text-align:center">应用软件接口</th></tr></thead><tbody><tr><td style="text-align:center">Presentation Layer</td><td style="text-align:center">转换格式并封包</td></tr><tr><td style="text-align:center">Session Layer</td><td style="text-align:center">维护会话状态</td></tr><tr><td style="text-align:center">Transport Layer</td><td style="text-align:center">添加传输表头形成片</td></tr><tr><td style="text-align:center">Network Layer</td><td style="text-align:center">形成数据报，决定路径选择与转发</td></tr><tr><td style="text-align:center">Data link Layer</td><td style="text-align:center">网络寻址，错误纠正，形成帧</td></tr><tr><td style="text-align:center">Physical Layer</td><td style="text-align:center">与硬件直接互通</td></tr></tbody></table><h2 id="Store-and-Forward-Important"><a href="#Store-and-Forward-Important" class="headerlink" title="Store and Forward (Important)"></a>Store and Forward (Important)</h2><p>Circuit Switching: A dedicated circuit per call as telephone net.</p><ul><li>End to end resources served for “call”</li><li>Link Bandwidth, Switch Capacity</li><li>Dedicated Resouces</li><li>Circuit-like (guaranteed) performance</li><li>Call setup required</li></ul><p>Example: TDM&amp;FDM, Datagram network <strong>is neither connection-oriented or connection-less</strong></p><p>Packet Switching: Data sent through net in discrete “chunks”</p><p>Pros:</p><ul><li>Divided data stream into packets</li><li>Shared network resources</li><li>each packet uses full link bandwidth</li><li>resources used as needed</li></ul><p>Cons:</p><ul><li>Aggregate resource demand can exceed amount available</li><li>Congestion Control</li><li>Node receives complete packet before forwarding, store and forward</li></ul><h3 id="Delay-Important"><a href="#Delay-Important" class="headerlink" title="Delay (Important)"></a>Delay (Important)</h3><p>Transmission 传输 Delay: From the first sent bit to the last sent bit (Check header and calculate checksum)</p><p>Propagation 传播 Delay: From the first sent bit to the first received bit</p><p>Queuing Delay: From entering queue to send</p><p>Processing Delay: From Send process to queue entrance</p><p>Total delay: the sum of the four delays above.</p><h2 id="Communication"><a href="#Communication" class="headerlink" title="Communication"></a>Communication</h2><p>Full Duplex: Client&amp;Server transfer in 2 directions at the same time.</p><p>Half Deplex: Only Client/Server can transfer at the same time but allow 2 directions.</p><p>Simplex: Only single directions can be used for transmission. (eg. Radio Station)</p><p>Connection Media: </p><p>UnGuided media: </p><ul><li>Wireless network</li><li>Satellite radio</li></ul><p>Guided media:</p><ul><li>Twisted-Pair Wire</li><li>Coaxial cable</li><li>Fiber optics</li></ul><h1 id="Computer-network-Chapter-2-Application-Layer"><a href="#Computer-network-Chapter-2-Application-Layer" class="headerlink" title="Computer network - Chapter 2 - Application Layer"></a>Computer network - Chapter 2 - Application Layer</h1><p>Due to the well-known, this part will be simplified.</p><h2 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h2><p>Process: Progam running within a host, a instance.</p><p>Two processes communicate through IPC. Inter-process communicate by exchanging message.</p><h2 id="Application-Service-you-may-need-to-know"><a href="#Application-Service-you-may-need-to-know" class="headerlink" title="Application Service you may need to know"></a>Application Service you may need to know</h2><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>URL: Protocol + Hostname + Path name</p><p>Pipeline + Connection-alive(Persistent HTTP with single TCP conn) + Stateless</p><p><strong>RTT</strong> : Round-Trip Time. 1 RTT = Send out and get back. Total RTT for HTTP: 2 RTT(1 for initiate conn, one for first request) + Transfer.</p><p>Request Packet Format:</p><pre><code>[METHOD] [PATH NAME] [HTTP Version][\r\n][Headers][\r\n][Data body][\r\n]</code></pre><p>Response Packet Format:</p><pre><code>[HTTP Version] [Status code] [Status Phrase][\r\n][Headers][\r\n][Data: Entity body][\r\n]</code></pre><p>Authentication:<br><img src="https://mdn.mozillademos.org/files/14689/HTTPAuth.png" alt="MDN HTTP 403"></p><p>Conditional GET:<br>Related Header: <code>If-modified-since:</code> <code>304 Not Modified / 200 OK</code></p><h3 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h3><p>Out of band communication: Port 20 for data transfer, Port 21 for command transfer</p><h2 id="Email"><a href="#Email" class="headerlink" title="Email"></a>Email</h2><p>Major Components: User agents + Mail server + DNS + Protocol (SMTP/IMAP/POP3)</p><p>SMTP(25 / 465 SSL / 587 TLS): Push to server. (Send only for now)</p><p>IMAP(143/ 993 Encrypted) &amp; POP3(110/ 995 Encrypted): Pull from client. (Receive at client, IMAP recommended)</p><p>Message in SMTP: 7-bit ASCII Code with Extended S/MIME via Base64 Encode</p><p>SMTP: </p><pre><code>-- Header lines --To:   From:  Subject:   -- Header lines --DATA BODY  [\r\n][\r\n]</code></pre><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>Provide: </p><ul><li>Distributed database based name resolver (Map from domain name to IP address)</li><li>Host aliasing via CNAME</li><li>Mail server aliasing via MX and PTR</li><li>Load distribution</li></ul><p>53/UDP with iterated query, 8 Global Root Server.</p><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>Socket: The interface (sends to / receives from), middle-man in process and system TCP buffers.<br>Socket Pair: [IP Address:Port]</p><p>Server:</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> socket<span class="token keyword">import</span> sys<span class="token keyword">import</span> timeHOST <span class="token operator">=</span> <span class="token string">'0.0.0.0'</span>PORT <span class="token operator">=</span> <span class="token number">23301</span>lsock <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># Define protocal stack as IPV4</span>lsock<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span>HOST<span class="token punctuation">,</span> PORT<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># Bind IP and port</span>lsock<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token number">65535</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># max connection number</span>conn<span class="token punctuation">,</span> addr <span class="token operator">=</span> lsock<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># Accept Connection</span>data <span class="token operator">=</span> conn<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1492</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># receive data with MTU 1492</span>conn<span class="token punctuation">.</span>sendall<span class="token punctuation">(</span>data<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># send data</span>conn<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Client:</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> socket<span class="token keyword">import</span> sys<span class="token keyword">import</span> timeHOST <span class="token operator">=</span> <span class="token string">'127.0.0.1'</span>PORT <span class="token operator">=</span> <span class="token number">23301</span>recsock <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">)</span> recsock<span class="token punctuation">.</span>connect_ex<span class="token punctuation">(</span><span class="token punctuation">(</span>HOST<span class="token punctuation">,</span>PORT<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># Connect to server</span>recsock<span class="token punctuation">.</span>sendall<span class="token punctuation">(</span>b<span class="token string">'HelloWorld!'</span><span class="token punctuation">)</span>data<span class="token operator">=</span>recsock<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1492</span><span class="token punctuation">)</span>recsock<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Computer-Network-Chapter-3-Transport-layer-Really-matters"><a href="#Computer-Network-Chapter-3-Transport-layer-Really-matters" class="headerlink" title="Computer Network - Chapter 3 - Transport layer (Really matters)"></a>Computer Network - Chapter 3 - Transport layer (Really matters)</h1><p>Transport layer: logical communication between processes</p><p>Network layer: logical communication between hosts</p><h2 id="Multiplex-and-Demultiplex"><a href="#Multiplex-and-Demultiplex" class="headerlink" title="Multiplex and Demultiplex"></a>Multiplex and Demultiplex</h2><p>Demultiplex: delivering received segments to correct socket.</p><p>Multiplex: Gather data from multi sockets and enveloping data with header.</p><p>IP Datagram format: <code>Header fields | 32 Bits SRC IP | 32 Bits DEST IP | DATA</code></p><p>UDP socket: identified by <code>dest IP | dest port</code><br>TCP socket: identified by <code>src IP | src port</code></p><h2 id="Transport-service"><a href="#Transport-service" class="headerlink" title="Transport service"></a>Transport service</h2><p>An app needed:</p><ul><li>Data loss control</li><li>Bandwidth</li><li>Timing(Low delay)</li></ul><h3 id="TCP-Service-Important"><a href="#TCP-Service-Important" class="headerlink" title="TCP Service (Important)"></a>TCP Service (Important)</h3><ul><li>Connection-oriented, full duplex data, pipeline</li><li>Reliable Transport with point to point and in-order</li><li>Flow control</li><li>Congestion control with buffers</li></ul><p>MSS: Max segment size, default 536 Bytes</p><p>Segment Structure:</p><pre><code>| source port | dest port || sequence no | ack no    || head len  | 0 | UAPRSF  ||Receive window | checksum||Urg data pointer| options||        body : data      |</code></pre><h4 id="Reliable-data-transfer"><a href="#Reliable-data-transfer" class="headerlink" title="Reliable data transfer"></a>Reliable data transfer</h4><p>Sequence No. = 第一个字节号</p><p>Piggybacked &amp; Cumulative ACKs: ACK No.: 下一个待传字节号</p><p>TCP 超时重传： Timeout events &amp; Duplicate ACKs</p><p>MSL: Max segment lifetime</p><p><img src="https://alicdn.kmahyyg.xyz/asset_files/tcp-handshake-conn.jpg" alt="TCP_CONN"></p><p>SYN_SENT -&gt; SYN_RCVD -&gt; ESTABLISHED -&gt; ESTABLISHED</p><p><img src="https://alicdn.kmahyyg.xyz/asset_files/tcp-handshake-disconn.jpg" alt="TCP_DISCONN"></p><p>FIN_WAIT_1 -&gt; CLOSE_WAIT -&gt; FIN_WAIT_2 -&gt; LAST_ACK -&gt; TIME_WAIT -&gt; CLOSED</p><h4 id="Checksum"><a href="#Checksum" class="headerlink" title="Checksum"></a>Checksum</h4><p>IEEE 802.3 CRC32</p><h3 id="UDP-Service-Important"><a href="#UDP-Service-Important" class="headerlink" title="UDP Service (Important)"></a>UDP Service (Important)</h3><ul><li>Unreliable, unordered delivery (data may be lost)</li><li>Connection-less (no handshake, each segment handled by app): Simple and smaller header</li><li>No congestion control with best-effort</li></ul><p>Used for:</p><ul><li>Loss tolerant, rate sensitive(streaming and multimedia)</li><li>DNS &amp; SNMP</li></ul><p>Packet format:</p><pre><code>        src port        |    dest port    |length including header |    checksum     |</code></pre><p>Checksum:</p><p>Divided data into 16-bit groups and add each one, wrap around if additional bit get.<br>checksum is sum get reversed.</p><h1 id="Computer-network-Chapter-4-Network-Layer"><a href="#Computer-network-Chapter-4-Network-Layer" class="headerlink" title="Computer network - Chapter 4 - Network Layer"></a>Computer network - Chapter 4 - Network Layer</h1><h2 id="Network-Layer-Function"><a href="#Network-Layer-Function" class="headerlink" title="Network Layer Function"></a>Network Layer Function</h2><ul><li>Routing: determine which route should be taken</li><li>Forwarding: process to next hop</li></ul><p>BTW, Virtual circuit networking: router must maintain connection state information, contains path from src to desc, vc no, entries in fwd tables.</p><h2 id="IP-Internet-protocol"><a href="#IP-Internet-protocol" class="headerlink" title="IP: Internet protocol"></a>IP: Internet protocol</h2><h3 id="Data-structure"><a href="#Data-structure" class="headerlink" title="Data structure"></a>Data structure</h3><pre><code>version | head length | type of service |       length      |identifier      |        flags      |   fragment offset     |  TTL     |     Upper Layer         |   IP Checksum         |                            SRC IP                          |                            DEST IP                         |                            Options                         |                            DATA                            |</code></pre><p>Identifier: Used for reassemale segment</p><p>Header len: Min 20 Bytes = 5, Max 60 Bytes = 15;</p><p>Flag: | Reserved 0 | Don’t Fragment (1,DF) | Last Fragment (0,More_F)|</p><p>Type of service: Used for QOS,<br>| Precendence (0-2 bits) | Normal delay (0) | High throughput (1) | High Reliability(1) | Reserved (6-7 Bits) |</p><p>Fragment Offset:</p><p><strong>数据部分切割，不含报头长度</strong> = (PacketLength - HeaderLength) / 8</p><h3 id="Addr"><a href="#Addr" class="headerlink" title="Addr"></a>Addr</h3><p>IPv4 Addr is 32 Bits.</p><p>In binary: </p><p>Class A = 0 + Netid + Hostid<br>Class B = 10 + Netid + Hostid<br>Class C = 110 + Netid + Hostid</p><p>Class D = 1110 + xx (Multicast Addr)<br>Class E = 1111 + yy (Reserved Addr) </p><p>CIDR: 192.168.200.0/24  24:Network mask, previous 24 bits of mask is 1.</p><p>Minimum IP is Subnet Addr, Last IP is multicast IP.</p><p>IP Address AND network mask is CIDR ADDR.</p><h3 id="Hierarchical-Addressing-Route-Aggregation"><a href="#Hierarchical-Addressing-Route-Aggregation" class="headerlink" title="Hierarchical Addressing: Route Aggregation"></a>Hierarchical Addressing: Route Aggregation</h3><p>Autonomous System: An aggregation of routers that they run the same routing algorithm, and one or more of the routers ( is called gateway router) can routing packets to other networks. Use Intra-AS routing protocol for peering with another AS.</p><h2 id="Routing-Algorithms"><a href="#Routing-Algorithms" class="headerlink" title="Routing Algorithms"></a>Routing Algorithms</h2><p>Global: Link state algorithm (Dijkstra)</p><p>Decentralized: Distance vector Algorithm (Bellman-Ford Equation)</p><h3 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h3><p>TALK IS CHEAP, SHOW ME THE CODE!</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!/usr/bin/env python3</span><span class="token comment" spellcheck="true"># -*- encoding:utf-8 -*-</span><span class="token keyword">import</span> sys<span class="token keyword">class</span> <span class="token class-name">Graph</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>vertices<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>V <span class="token operator">=</span> vertices   <span class="token comment" spellcheck="true"># initiate 2D arrays with the number of vertexes</span>        self<span class="token punctuation">.</span>graph <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> column <span class="token keyword">in</span> range<span class="token punctuation">(</span>vertices<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> row <span class="token keyword">in</span> range<span class="token punctuation">(</span>vertices<span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">printSolution</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>dist<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"  Vertex\tDistance from src"</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># print the solution, loop all vertexes</span>        <span class="token keyword">for</span> node <span class="token keyword">in</span> range<span class="token punctuation">(</span>self<span class="token punctuation">.</span>V<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\t"</span><span class="token punctuation">,</span>node<span class="token punctuation">,</span><span class="token string">"\t\t\t"</span><span class="token punctuation">,</span>dist<span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">minDistance</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>dist<span class="token punctuation">,</span>sptSet<span class="token punctuation">)</span><span class="token punctuation">:</span>        min <span class="token operator">=</span> sys<span class="token punctuation">.</span>maxsize  <span class="token comment" spellcheck="true"># assume that all paths have the maximum length</span>        min_index <span class="token operator">=</span> None   <span class="token comment" spellcheck="true"># initial var to avoid non-sense error</span>        <span class="token keyword">for</span> v <span class="token keyword">in</span> range<span class="token punctuation">(</span>self<span class="token punctuation">.</span>V<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># find the vertex with minDist from not in sTree</span>            <span class="token keyword">if</span> dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">&lt;</span> min <span class="token operator">and</span> sptSet<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">False</span><span class="token punctuation">:</span>                min <span class="token operator">=</span> dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span>                min_index <span class="token operator">=</span> v        <span class="token keyword">if</span> min_index <span class="token operator">==</span> None<span class="token punctuation">:</span>            <span class="token keyword">raise</span> NotImplementedError        <span class="token keyword">return</span> min_index    <span class="token keyword">def</span> <span class="token function">dijkstra</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>src<span class="token punctuation">)</span><span class="token punctuation">:</span>        dist <span class="token operator">=</span> <span class="token punctuation">[</span>sys<span class="token punctuation">.</span>maxsize<span class="token punctuation">]</span> <span class="token operator">*</span> self<span class="token punctuation">.</span>V        dist<span class="token punctuation">[</span>src<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment" spellcheck="true"># vertex to itself should be zero</span>        sptSet <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">False</span><span class="token punctuation">]</span> <span class="token operator">*</span> self<span class="token punctuation">.</span>V  <span class="token comment" spellcheck="true"># Shortest path tree set, initiate</span>        <span class="token comment" spellcheck="true"># choose a vertex</span>        <span class="token keyword">for</span> cout <span class="token keyword">in</span> range<span class="token punctuation">(</span>self<span class="token punctuation">.</span>V<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># pick the minDist vertex from not accessed vertexes, first time == src</span>            u <span class="token operator">=</span> self<span class="token punctuation">.</span>minDistance<span class="token punctuation">(</span>dist<span class="token punctuation">,</span>sptSet<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># the minDist vertex put into shortest path tree</span>            sptSet<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>            <span class="token comment" spellcheck="true"># only when current vertex > new vertex, and the vertex not in sptset,</span>            <span class="token comment" spellcheck="true"># update the picked vertex's neighbor's distance (new distance with new node as a relay)</span>            <span class="token keyword">for</span> v <span class="token keyword">in</span> range<span class="token punctuation">(</span>self<span class="token punctuation">.</span>V<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> self<span class="token punctuation">.</span>graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">and</span> sptSet<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">False</span> <span class="token operator">and</span> dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">></span> dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">:</span>                    dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span>        self<span class="token punctuation">.</span>printSolution<span class="token punctuation">(</span>dist<span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    g <span class="token operator">=</span> Graph<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>    g<span class="token punctuation">.</span>graph <span class="token operator">=</span> <span class="token punctuation">[</span>        <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">#A, and no-route should be zero.</span>        <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">#B</span>        <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">#C</span>        <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">#D</span>        <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">#E</span>        <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">#F</span>    <span class="token punctuation">]</span>    g<span class="token punctuation">.</span>dijkstra<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># source is A</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Distance-vector-Algorithm-Bellman-Ford-Equation"><a href="#Distance-vector-Algorithm-Bellman-Ford-Equation" class="headerlink" title="Distance vector Algorithm (Bellman-Ford Equation)"></a>Distance vector Algorithm (Bellman-Ford Equation)</h3><p>D (X to Y) = min {neiborhood V} -&gt; cost(x,v) + cost(v,y)<br>重点：结点获得最短路径的下一跳, 该信息用于转发表中！</p><p>异步迭代:</p><ul><li>引发每次局部迭代的因素</li><li>局部链路费用改变</li><li>来自邻居的DV更新</li></ul><p>分布式:</p><ul><li>每个结点只当DV变化时才通告给邻居</li><li>邻居在必要时（其DV更新后发生改变）再通告它们的邻居</li></ul><h1 id="Computer-Network-Chapter-5-Link-Layer"><a href="#Computer-Network-Chapter-5-Link-Layer" class="headerlink" title="Computer Network - Chapter 5 - Link Layer"></a>Computer Network - Chapter 5 - Link Layer</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Nodes: Hosts and routers</p><p>Links: Communication channels that connect adjacent nodes along communication path.</p><p>Farme: Layer-2 Packet, PDF, encapsulates datagram. </p><p>Responsible for : transfer datagram from one node to adjacent node over a link</p><h2 id="Error-Detection-and-Correlation"><a href="#Error-Detection-and-Correlation" class="headerlink" title="Error Detection and Correlation"></a>Error Detection and Correlation</h2><h3 id="Parity-Bit"><a href="#Parity-Bit" class="headerlink" title="Parity Bit"></a>Parity Bit</h3><p>奇校验 是 奇数个 1 得到的校验位为 0，偶校验 是 偶数个 1 得到的校验位 为 0</p><h3 id="CRC-Cyclic-Redundancy-Check"><a href="#CRC-Cyclic-Redundancy-Check" class="headerlink" title="CRC: Cyclic Redundancy Check"></a>CRC: Cyclic Redundancy Check</h3><p>G:1001=x^3+x^0=x^3+1 D:101110</p><p>G 的最高位恒为 1, D 左移 (len(G)-1) 位后对 G 作 XOR 除法运算，最终得到余数即为 Checksum.</p><p>检验无误： D 左移 (len(G)-1) 位后加上 Checksum 对 G 作 XOR 除法，余数为 0 则正常。</p><h2 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h2><p>Address Resolution Protocol: IP/MAC address mapping for lan nodes</p><p>ARP Table builder:</p><ul><li>A Broadcast: B’s IP Addr is blahblah，but I don’t know B’s MAC (Dest IP: 192.168.200.255, Dest MAC: FFFFFFFFFFFF)</li><li>B Receive, then replies to A with B’s MAC (unicast)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Computer-Network-Chapter-1-Basic-Concepts&quot;&gt;&lt;a href=&quot;#Computer-Network-Chapter-1-Basic-Concepts&quot; class=&quot;headerlink&quot; title=&quot;Computer N
      
    
    </summary>
    
    
      <category term="School" scheme="https://www.kmahyyg.xyz/tags/School/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法课程 - Chap 10 排序</title>
    <link href="https://www.kmahyyg.xyz/2019/ynu-datastru-c10/"/>
    <id>https://www.kmahyyg.xyz/2019/ynu-datastru-c10/</id>
    <published>2019-01-06T14:49:29.000Z</published>
    <updated>2019-02-24T12:39:17.218Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构复习-Chapter-10-排序"><a href="#数据结构复习-Chapter-10-排序" class="headerlink" title="数据结构复习 - Chapter 10 排序"></a>数据结构复习 - Chapter 10 排序</h1><h2 id="相关概念："><a href="#相关概念：" class="headerlink" title="相关概念："></a>相关概念：</h2><p>按主关键字排序：结果唯一；按次关键字可以结果不唯一。</p><p>排序稳定性：同样的重复数据，排序前后的重复数据的相对顺序不变。</p><p>内部排序：在计算机的内存即可完成（RAM），外部排序由于数据过大，必须访问外部存储才可以解决。</p><p>排序的两种基本操作：比较大小，移动数据。</p><p>存储方式：</p><ul><li>存储在数组中，排序时按需移动。</li><li>存储在静态链表中，只需修改指针。</li><li>存储在地址连续的一组存储单元中，另设向量用于记录数据的存储位置，只需修改向量中的存储地址即可。</li></ul><h2 id="各种排序算法"><a href="#各种排序算法" class="headerlink" title="各种排序算法"></a>各种排序算法</h2><ul><li>直接插入排序：数组的 [0] 位用于临时存储数据以备交换之用。在 r[1.. i-1]中查找 r[i] 的插入位置; 对于在查找过程中找到的那些关键字不小于 r[i].key 的记录，在查找的同时实现记录向后移动；之后插入 r[i] 即可。</li><li>折半插入排序：对原数据进行二分查找，当出现 low &gt; high OR low == high OR high &lt; low （此处均指指针的所在位置而非元素）时，根据元素大小关系插入到对应指针的前后。</li></ul><h3 id="二路插入排序"><a href="#二路插入排序" class="headerlink" title="二路插入排序"></a>二路插入排序</h3><p>用空间换时间，需要存储 n 个记录的辅助空间数组 D。将初始数据数组 L[1] = D[1]，然后比较大小，将 L 视为环形数组，D 其中的数据大于 L 中的最大元素，则插入到尾部；若小于 L 中最小的元素则插入至头部，否则折半查找，移动一部分的元素。</p><p>其中 L 中的第一个是 min， 最后一个是 max。 初始状态 <code>first = final = 1</code> ，修改：<code>first = (first - 1 + length) % length</code>, <code>final += 1</code>。</p><h3 id="表插入排序"><a href="#表插入排序" class="headerlink" title="表插入排序"></a>表插入排序</h3><p>使用静态链表保存排序，排序完成后一次性调整所在位置。数据节点与头节点构成循环列表，头节点： <code>index = 0 | data = MAXINT | nextidx = SMALLEST ONE</code>，然后将剩下的数据根据非递减排序，依次修改各数据节点的 nextidx 域，确保各节点对应的 nextidx 值指向下一个更大的量，头节点保存数据最小的节点所在的指针。</p><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>分割所有元素为若干个子序列，不断缩小子序列之间的间隔。每产生一次子序列就插入排序一次。数组的第 0 位用于插入排序的暂存。</p><p>eg. 按照子序列中各元素大小不停交换： </p><table><thead><tr><th style="text-align:center">在原数据中相隔x个取出一个构成子序列</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">65</td><td style="text-align:center">49</td><td style="text-align:center">97</td><td style="text-align:center">25</td><td style="text-align:center">25^</td><td style="text-align:center">13</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">65A</td><td style="text-align:center">49B</td><td style="text-align:center">97C</td><td style="text-align:center">25A</td><td style="text-align:center">25^B</td><td style="text-align:center">13C</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">25A</td><td style="text-align:center">25^B</td><td style="text-align:center">13AC</td><td style="text-align:center">65BD</td><td style="text-align:center">49C</td><td style="text-align:center">97D</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">13</td><td style="text-align:center">25^</td><td style="text-align:center">25</td><td style="text-align:center">65</td><td style="text-align:center">49</td><td style="text-align:center">97</td></tr></tbody></table><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>实质：双重嵌套循环，从第 i 个数据起，与之后的 i + 1 个数据比较，i++，若更大或更小就交换;<br>对 i 进行长度为 len 的循环，重复比较。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>L1<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> L1<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> L1<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            L1<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> L1<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> L1<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> L1<span class="token punctuation">[</span>j<span class="token punctuation">]</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><ul><li>选择枢轴，以枢轴作为基准值。</li><li>设指针 low 、high 指向第一个和最后一个记录</li><li>从 high 开始向前搜索，找到一个 &lt;= 基准值的记录，并与之交换</li><li>从 low 开始向后搜索，找到一个 &gt;= 基准值的记录，并与之交换</li><li>重复直到 low == high</li></ul><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><p>选择排序的思想在于：每次循环都选出一个最记录并与 i 位置交换。需要用的一个数据暂存单元。</p><p>实质仍然是冒泡排序，区别在于：找到最值之后再交换，而不是每次都交换。</p><h3 id="树形选择排序"><a href="#树形选择排序" class="headerlink" title="树形选择排序"></a>树形选择排序</h3><p>类似 Huffman Tree：</p><ul><li>将各数据置于底层，</li><li>选出较小者依次向上构建排序二叉树。</li><li>输出最小或最大数据之后，将输出的数据在底层叶子节点的数据置为 INTMAX。</li><li>重复上述过程，直至底层叶子节点全为 INTMAX。</li></ul><p>需要注意的是： <strong>该排序是稳定排序，左右相同左者先。</strong></p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆：对应的每个数据，DATA[i] &lt;= DATA[2i] AND DATA[i+1] &lt;= DATA[2i+1]，反之亦成立。</p><p>解释：上述数据元素依次排成完全二叉树，堆顶（ROOT）必然最大（MAX 大根堆）或最小（MIN 小根堆），树中所有节点的值均大于（OR 均小于）左右孩子。</p><p>依然满足 <strong>先左后右，左大右小，恒小于根</strong> 的原则。建堆和筛选过程注意：向上、向下双重比较。</p><p>堆排序使用 BFS 遍历，得到的结果就是排序字符串。</p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><ul><li>deltax = 2; 每 deltax 个元素形成一个子序列，并进行内部排序。</li><li>deltax ×= 2; 重复排序过程，组合子序列。</li><li>最终组合成完整序列。</li></ul><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>分类：</p><ul><li>Most Significant Digit first (MSD)</li><li>Least Significant Digit first (LSD)</li></ul><p>根据存储结构分为：普通基数排序和链式基数排序。</p><p>关键字按不同的位值进行排序。本质是多关键字排序思想在单逻辑关键字上的应用。实际是一种嵌套排序。</p><p>这里没有太好的归纳，直接上例子吧：</p><p>——- 普通的 基数排序 ——–</p><ul><li>每个记录的 关键码 长度 为 n，视为 n 元组， 每一位的取值 有 r 种，称 r 为基数。</li><li>设置 r 个队列，将 n 中元素的最低位按照要求，（以 LSD 为例），按 LSD 放入对应队列，然后顺序出队  <strong>分配再收集</strong></li><li>将 n 中的剩余元素重复上述过程，继续 <strong>分配再收集</strong> ，直到排序完成。</li></ul><hr><p>——– 链式 基数排序 ——–</p><ul><li>数据使用链表存储。</li><li>每一队列置一队头、一队尾指针，然后按照上述 步骤重复排序。</li><li>出队过程改为将队头队尾指针链接起来。</li></ul><hr><h2 id="各种算法的时间复杂度"><a href="#各种算法的时间复杂度" class="headerlink" title="各种算法的时间复杂度"></a>各种算法的时间复杂度</h2><p><img src="https://alicdn.kmahyyg.xyz/asset_files/2019-sort-complexity.webp" alt="时间复杂度表"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据结构复习-Chapter-10-排序&quot;&gt;&lt;a href=&quot;#数据结构复习-Chapter-10-排序&quot; class=&quot;headerlink&quot; title=&quot;数据结构复习 - Chapter 10 排序&quot;&gt;&lt;/a&gt;数据结构复习 - Chapter 10 排序&lt;/
      
    
    </summary>
    
    
      <category term="School" scheme="https://www.kmahyyg.xyz/tags/School/"/>
    
      <category term="Datastru" scheme="https://www.kmahyyg.xyz/tags/Datastru/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法课程 - Chap 9 查找</title>
    <link href="https://www.kmahyyg.xyz/2019/ynu-datastru-c9/"/>
    <id>https://www.kmahyyg.xyz/2019/ynu-datastru-c9/</id>
    <published>2019-01-05T20:00:44.000Z</published>
    <updated>2019-02-24T12:39:17.218Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构复习-Chapter-9-查找"><a href="#数据结构复习-Chapter-9-查找" class="headerlink" title="数据结构复习 - Chapter 9 查找"></a>数据结构复习 - Chapter 9 查找</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>查找表是由同一类型的具有相同可辨认特性/属性的数据元素（或记录）构成的集合。查找操作的数据结构。</p><p>基础操作：</p><ul><li>查询是否在表</li><li>查询数据属性</li><li>插入数据元素</li><li>删除数据元素</li></ul><p>根据是否修改查找表，分为 静态查找表 和 动态查找表 。</p><p>平均查找长度 Average Search Length：关键字对应的期望值 之和 = 第 i 个关键字 == 给定值时经过的比较次数 × 查找表中第 i 个记录的概率。</p><h2 id="静态查找"><a href="#静态查找" class="headerlink" title="静态查找"></a>静态查找</h2><h3 id="静态顺序查找"><a href="#静态顺序查找" class="headerlink" title="静态顺序查找"></a>静态顺序查找</h3><ol><li>逐个比较</li><li>数组第 0 位存储最后一个数据元素，称为 “监视哨”，避免每步都去判断是否结束。</li></ol><p>ASL：</p><blockquote><p>Part 1: 查找成功 <code>n+1/2</code><br>Part 2: 查找失败 <code>n+1</code><br>Total: <code>3(n+1)/4</code></p></blockquote><h3 id="静态二分查找-Bisect"><a href="#静态二分查找-Bisect" class="headerlink" title="静态二分查找 Bisect"></a>静态二分查找 Bisect</h3><ol><li>low=0,high=n,mid=(low+high)/2</li><li>待查找 key &lt; mid, high = mid - 1，重新计算 mid</li><li>待查找 key &gt; mid, low = mid + 1，重新计算 mid</li><li>直到 mid == key (成功) 或 low/high == mid != key (失败)</li></ol><p>mid 作为根节点，左子区间作为左子树，右子区间作为右子树，建立判定树。</p><p><strong>具有n个结点的完全二叉树的高度为 <code>[log2n] + 1</code> </strong></p><p>ASL = <code>(1+1/n)log2(n+1)</code></p><h3 id="静态分块查找"><a href="#静态分块查找" class="headerlink" title="静态分块查找"></a>静态分块查找</h3><p>特点：块间有序，块内无序。</p><p>索引表的建立： <code>MAX KEY | POINTER</code>, <code>POINTER</code> -&gt; 索引表中的各项关键字有序，指针指向块内的第一个记录的位置。</p><p>稠密索引：数据表中的一个对象对应一个索引， <strong>不一定</strong> 有序存放。</p><p>步骤：确定待查记录所在块，再在块内查找。</p><p>分块查找的 ASL 取决于 查找所在块 的算法：</p><p>数据表长为 n 均分成 b 块，每块含 s 个记录，每块查找的概率： 1/b，每个记录的查找概率是 1/s。</p><ul><li>顺序查找： <code>1/2 * (n/s + s) + 1</code></li><li>二分查找： <code>log2(b+1) - 1 + (s+1)/2</code></li></ul><p>分块查找的 ASL：小于顺序、大于二分。</p><h2 id="动态查找"><a href="#动态查找" class="headerlink" title="动态查找"></a>动态查找</h2><h3 id="动态查找表"><a href="#动态查找表" class="headerlink" title="动态查找表"></a>动态查找表</h3><p>特点：表结构在查找过程中，存在则返回，不存在则插入</p><h4 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h4><p>左子树 &lt; 根节点，右子树 &gt; 根节点</p><p>查找：从根节点出发，直至找到。否则逐层向下直至指空。</p><p>插入：空树则直接插入为根节点，非空则比较后插入。</p><p><strong>中序遍历</strong> 可得到关键字的有序序列</p><p>删除： 左右子树都存在时，用直接前驱或者直接后继取代。其他则直接继承。</p><h4 id="平衡二叉树-AVL"><a href="#平衡二叉树-AVL" class="headerlink" title="平衡二叉树 AVL"></a>平衡二叉树 AVL</h4><p>重点：左右子树平衡，深度之差绝对值 &lt;= 1</p><p>节点的数据域： 左右子树深度之差，只能取 0、1、-1，否则不平衡</p><p>查找性能：复杂度 O(log2n)</p><h5 id="平衡旋转"><a href="#平衡旋转" class="headerlink" title="平衡旋转"></a>平衡旋转</h5><p>在左子树的左子树插入 左边过剩： LL 平衡旋转： 最上方节点顺时针旋转 pi/2。<br>在右子树的右子树插入 右边过剩： RR 平衡旋转： 最上方节点逆时针旋转 pi/2。<br>在左子树的右子树插入： LR 平衡旋转： 最上方节点做 LL 旋转，新插入的节点成为新根。<br>在右子树的左子树插入： RL 平衡旋转： 最上方节点做 RR 旋转，新插入的节点成为新根。</p><h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B- Tree"></a>B- Tree</h3><p>至多有 m 棵子树，共计 m 阶， m 分叉，是一种二叉查找树的推广。</p><p>非终端节点： <code>关键字个数 | 子树根节点指针Pk | 关键字 Ki</code>，每一棵子树的 Pk 中的所有关键字小于 Ki 元素。</p><p>插入： 根据定义判断是否大于 m 分叉，大于则分裂为新节点。根据定义判断即可。</p><p>删除： 合并子节点至双亲节点（如果必要）。保证符合定义。</p><h3 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+ Tree"></a>B+ Tree</h3><p>n 棵子树的节点含有 n 个关键字，是一种多路索引表的体现。</p><p>所有关键字都在叶子节点的链节点出现，中间节点仅作为索引指针。</p><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>存储位置由 Hash 函数计算得知，数字关键字的常用构造方法：</p><ul><li>直接定址：地址 == ax+b</li><li>数字分析：各种符号出现的频率大致相同，且关键字位数比地址数大，基本关键字可以提前预知。选用 key 中的某几位作为关键字。</li><li>平方取中：平方 key，取中间几位，适合部分数字高频重复。</li></ul><h4 id="折叠："><a href="#折叠：" class="headerlink" title="折叠："></a>折叠：</h4><p>移位叠加：分割后低位对齐相加。（切成部分后相加）</p><p>间界叠加：分割之后，蛇形对齐相加（在高位切割，切割相邻位为低位；以此类推）</p><h3 id="哈希表-1"><a href="#哈希表-1" class="headerlink" title="哈希表"></a>哈希表</h3><ul><li>除留余数：key mod p，p 一般选 小于等于最大长度的质数或不含 20 以下的质数因子的合数。</li><li>乘余取整：key × A （A为0～1之间的小数），取小数部分；用 m 乘以小数，取整数部分为 index。</li><li>随机数： index = random(key)</li></ul><p>构造的原则是冲突可能尽量小。</p><h4 id="冲突处理"><a href="#冲突处理" class="headerlink" title="冲突处理"></a>冲突处理</h4><ul><li>开放地址——线性探测： index + 1</li><li>开放地址——二次探测： index +- n^2 (n为大于0常数)</li><li>伪随机： index + randint()</li><li>链地址： 同 index，数据域使用链表存储。</li><li>再哈希： 使用另一个 Hash 函数 R，再次计算 R(index)。</li><li>溢出区法：发生冲突时存入单独的溢出表。</li></ul><p>ASL = 探查次数之和 / 元素个数</p><p>哈希表的 ASL 依赖于 Hash 表的装填程度，不论多大的装填程度，总有一个适合值可将 ASL 限定在合理范围内。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据结构复习-Chapter-9-查找&quot;&gt;&lt;a href=&quot;#数据结构复习-Chapter-9-查找&quot; class=&quot;headerlink&quot; title=&quot;数据结构复习 - Chapter 9 查找&quot;&gt;&lt;/a&gt;数据结构复习 - Chapter 9 查找&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="School" scheme="https://www.kmahyyg.xyz/tags/School/"/>
    
      <category term="Datastru" scheme="https://www.kmahyyg.xyz/tags/Datastru/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法课程 - Chap 7 图</title>
    <link href="https://www.kmahyyg.xyz/2019/ynu-datastru-c7/"/>
    <id>https://www.kmahyyg.xyz/2019/ynu-datastru-c7/</id>
    <published>2019-01-05T01:16:11.000Z</published>
    <updated>2019-02-24T12:39:17.218Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构复习-Chapter-7-图"><a href="#数据结构复习-Chapter-7-图" class="headerlink" title="数据结构复习 - Chapter 7 图"></a>数据结构复习 - Chapter 7 图</h1><h2 id="图的相关概念"><a href="#图的相关概念" class="headerlink" title="图的相关概念"></a>图的相关概念</h2><p>图是由顶点集合和顶点间的关系集合构成的一种数据结构。</p><p>图的 ADT:</p><pre><code>ADT Graph {  数据对象V：    V是具有相同特性的数据元素的集合，称为顶点集。  数据关系R：    R={ VR }    VR={&lt;v,w&gt;|v,w∈V且P(v,w)，&lt;v,w&gt;表示从v到w的弧，谓词P(v,w)定义了弧&lt;v,w&gt;的意义或信息}  基本操作P：    CreateGraph(&amp;G,V,VR); // 按V和V R的定义构造图G    DestroyGraph(&amp;G);     // 销毁图G    LocateVex(G, u);  // 若G中存在顶点u，则返回该顶点在图中位置；    GetVex(G, v);         // 返回 v 的值    PutVex(&amp;G, v, value);   // 对 v 赋值value    FirstAdjVex(G, v);  // 返回v的第一个邻接点。否则，则返回“空”}ADT Graph</code></pre><p>图的术语：</p><ul><li>有向图 &amp; 无向图</li><li>完全图：图中任意两个顶点间都有一条边相连接，无向完全图的边数是 n(n-1)/2，有向完全图的边数是 n(n-1)</li><li>稠密图/稀疏图：边数的判定界限为 nlogn</li><li>网络：带权图，路径上带有权值，其中非带权图的路径长度是指此路径上边的条数，带权图的路径长度是指路径上的各边的权之和。</li><li>(非)简单路径：路径上的顶点不重复出现。</li></ul><p>关于连通图：</p><ul><li>连通图：（不一定直接连通）任意两顶点之间有路径可达，图中所有顶点均连通。</li><li>强连通图： 任意一对顶点存在正向路径也存在反向路径。</li><li>非（强）连通图的极大连通子图称为（强）连通分量。</li></ul><p>关于邻接：</p><ul><li>无向图：邻接、关联、依附于边：都是说边的两个顶点</li><li>有向图：从起点邻接到终点，终点邻接自起点，弧与顶点相关联</li></ul><p>关于度：</p><ul><li>度：无向图：和对应顶点关联的边的数目</li><li>出度：以 v 为终点的有向边数</li><li>入度：以 v 为起点的有向边数</li></ul><p>生成：</p><ul><li>生成树：极小连通子图，包含图的全部顶点，只能生成树的 n-1 条边，图中每个顶点间均存在路径。</li><li>生成森林： 有向图的一个顶点的入度为 0, 其他的顶点入度为 1, 则为有向树。生成森林包含若干个有向树</li></ul><h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><ol><li>无向图： <code>edge[i][j]</code> 表示 i 到 j 之间有弧或边。（具有对称性，完全图的邻接矩阵中，对角线为 0，其他均为 1。）</li><li>有向图： 第 i 行，表示出度边（尾）；第 j 列，表示入度边（头）。</li></ol><h3 id="邻接链表"><a href="#邻接链表" class="headerlink" title="邻接链表"></a>邻接链表</h3><ol><li>无向：<code>vertex | pointer</code> -&gt; <code>pointer</code> == <code>neighbor vertex | pointer</code></li><li>有向：<code>vertex | pointer</code> -&gt; <code>pointer</code> == <code>dest vertex | pointer</code>  (出边)<br><code>vertex | pointer</code> -&gt; <code>pointer</code> == <code>src vertex | pointer</code>  (入边)</li></ol><h2 id="图的遍历-aka-搜素"><a href="#图的遍历-aka-搜素" class="headerlink" title="图的遍历(aka. 搜素)"></a>图的遍历(aka. 搜素)</h2><p>遍历的定义：从某一顶点出发，遍历其余顶点，且每个顶点仅被访问一次。实质是寻找邻接点。<br>其实与二叉树三序遍历等价。</p><p>DFS：计算机实现需借用辅助的 <code>visited[]</code> ，整体思路是先沿指针访问，访问后置 visited = 1, 然后直到到达的所有邻接节点都被访问过，回退，直到所有图中节点均被实现。</p><p>BFS： <em>NON-RECURSIVE</em>  辅助存储： <code>visited[] &amp; Queue(Visited)</code> 。实现思路：从起点顺序访问，访问路径长度为 1 的节点，然后置节点为 visited = 1，并将该节点入队，当队列非空时，将队头元素出队，并置出队节点为当前节点，访问与出队节点距离为 1 的点并逐个入队，之后依次出队，将出队后的节点作为起始节点，重复上述过程。</p><h2 id="图的连通性"><a href="#图的连通性" class="headerlink" title="图的连通性"></a>图的连通性</h2><h3 id="Kruskal-算法"><a href="#Kruskal-算法" class="headerlink" title="Kruskal 算法"></a>Kruskal 算法</h3><ol><li>添加所有顶点</li><li>选择最小权重边，不产生回路，直至完全连通。</li></ol><h3 id="Prim-算法"><a href="#Prim-算法" class="headerlink" title="Prim 算法"></a>Prim 算法</h3><ol><li>选择起始顶点，建立 <code>founded[]</code></li><li>将初始的辅助数组中各项元素初始化为 0 ，辅助数组结构为：</li></ol><table><thead><tr><th style="text-align:center">Index</th><th style="text-align:center">AdjVertex</th><th style="text-align:center">LowCost</th></tr></thead><tbody><tr><td style="text-align:center">网中的节点v</td><td style="text-align:center">相邻点u</td><td style="text-align:center">u与v之间的边的权重</td></tr></tbody></table><p>其中第一次的网中节点为除了起点之外的其他节点。起始节点的 founded == 1。</p><ol start="3"><li>在对应的邻接矩阵的各点中找到最小权重的边。接下来以找到的最近的邻接点为起点，重复上述过程，直到所有节点的 founded == 1。 </li></ol><p>时间复杂度：O(n^2)</p><h2 id="有向无环图"><a href="#有向无环图" class="headerlink" title="有向无环图"></a>有向无环图</h2><h3 id="Activity-on-Vertices-AOV"><a href="#Activity-on-Vertices-AOV" class="headerlink" title="Activity on Vertices (AOV)"></a>Activity on Vertices (AOV)</h3><p>顶点表示活动，弧的起点和终点表示终点的活动必须先于起点进行。</p><h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><p>目的：用于判断是否存在有向环</p><p>本质：重复选择没有直接前驱的结点</p><p>方法：</p><ul><li>输入 AOV 网。</li><li>在 AOV 中选择没有直接前驱的点并输出，删除该顶点和发出的所有有向边。</li><li>重复，直至全部节点均被输出或跳出循环</li></ul><p>若剩余有节点未被输出，则必然存在有向环。该排序方法为不稳定排序，结果不唯一。</p><h3 id="Activity-on-Edges-AOE"><a href="#Activity-on-Edges-AOE" class="headerlink" title="Activity on Edges (AOE)"></a>Activity on Edges (AOE)</h3><p>顶点表示事件(Event)，有向边表示活动(Activity)，边上权值表示活动持续时间(Duration)。</p><p>入度为 0, 为 SRC，源点（开始点）；出度为 0, 为 DEST， 汇点（终点）。</p><p>Event 节点表示在 该节点之前所有活动已经完成，在它之后的活动可以开始。每边的起点为开始事件，终点为结束事件，可以看作进度条。</p><h4 id="事件之最"><a href="#事件之最" class="headerlink" title="事件之最"></a>事件之最</h4><p>事件的 最早开始时间： 最长路径<br>事件的 最晚开始时间： 最长路径 - 出边的权值（结果取最小）</p><h4 id="活动之最"><a href="#活动之最" class="headerlink" title="活动之最"></a>活动之最</h4><p>活动的 最早开始时间： 起始事件 的 最早开始时间<br>活动的 最迟开始时间（最长拖延时间）： 末尾事件的最晚开始时间 - 出边的权值</p><h4 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h4><p><strong>活动</strong> 的 <strong>最早开始时间 == 最迟开始时间</strong> 的路径</p><h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><p><a href="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/dijkstra.html" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/easy-learn-algorithm/dijkstra.html</a></p><p><a href="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/floyd.html" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/easy-learn-algorithm/floyd.html</a></p><h3 id="Floyd-Warshall-非负图的多源最短路径"><a href="#Floyd-Warshall-非负图的多源最短路径" class="headerlink" title="Floyd-Warshall 非负图的多源最短路径"></a>Floyd-Warshall 非负图的多源最短路径</h3><p>时间复杂度：O(n^3)</p><ol><li>数组第 0 维，存储初始数据。 <code>[i][j]</code> 表示从 i 到 j 的 最短路径长度。最短路径经过的点使用链表方式，保存在另一个数组中。</li><li>只允许经过一个特定的顶点 k 中转，重复上述过程。 从 i 到 j 只需判断 <code>[i][k] + [k][j] ?? [i][j]</code> 即可。</li><li>推广到允许经过所有顶点中转。基本思想就是：最开始只允许经过 1 号顶点进行中转，接下来只允许经过 1 和 2 号顶点进行中转……允许经过 1~n 号所有顶点进行中转，求任意两点之间的最短路程。用一句话概括就是：从 i 号顶点到 j 号顶点只经过前k号点的最短路程。</li></ol><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> e<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> n<span class="token punctuation">,</span> m<span class="token punctuation">,</span> t1<span class="token punctuation">,</span> t2<span class="token punctuation">,</span> t3<span class="token punctuation">;</span>    <span class="token keyword">int</span> inf <span class="token operator">=</span> <span class="token number">99999999</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//用inf(infinity的缩写)存储一个我们认为的正无穷值</span>    <span class="token comment" spellcheck="true">//读入n和m，n表示顶点个数，m表示边的条数</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d %d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//初始化</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> j<span class="token punctuation">)</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> inf<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//读入边</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d %d %d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>t1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t2<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t3<span class="token punctuation">)</span><span class="token punctuation">;</span>        e<span class="token punctuation">[</span>t1<span class="token punctuation">]</span><span class="token punctuation">[</span>t2<span class="token punctuation">]</span> <span class="token operator">=</span> t3<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//Floyd-Warshall算法核心语句</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> e<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                    e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> e<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//输出最终的结果</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%10d"</span><span class="token punctuation">,</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Dijkstra-非负图的单源最短路径"><a href="#Dijkstra-非负图的单源最短路径" class="headerlink" title="Dijkstra 非负图的单源最短路径"></a>Dijkstra 非负图的单源最短路径</h3><p>时间复杂度：O(n^2)</p><blockquote><p>Talk is cheap, show me the code.  —- Linus Torvalds</p></blockquote><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!/usr/bin/env python3</span><span class="token comment" spellcheck="true"># -*- encoding:utf-8 -*-</span><span class="token comment" spellcheck="true"># http://wiki.jikexueyuan.com/project/easy-learn-algorithm/dijkstra.html</span><span class="token comment" spellcheck="true"># https://blog.csdn.net/qq_35644234/article/details/60870719</span><span class="token comment" spellcheck="true"># https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/</span><span class="token keyword">from</span> sys <span class="token keyword">import</span> maxsize <span class="token keyword">as</span> maxintgraph <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true"># 0A, and no-route should be zero.</span>    <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true"># 1B</span>    <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true"># 2C</span>    <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true"># 3D</span>    <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true"># 4E</span>    <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 5F</span><span class="token punctuation">]</span><span class="token keyword">global</span> distsrc <span class="token operator">=</span> int<span class="token punctuation">(</span><span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token string">"Input Source: "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># start from source</span>vtx <span class="token operator">=</span> <span class="token number">6</span>  <span class="token comment" spellcheck="true"># total vertexes</span>dist <span class="token operator">=</span> <span class="token punctuation">[</span>maxint <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>vtx<span class="token punctuation">)</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># distance should be max at initial</span>foundset <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># if shortest path found, append to here</span>prev <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> vtx  <span class="token comment" spellcheck="true"># initate all front-driven == -1, if still -1, non-accessable</span><span class="token keyword">def</span> <span class="token function">str2Path</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">:</span>    path <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    n <span class="token operator">=</span> node    <span class="token keyword">while</span> n <span class="token operator">!=</span> src<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># insert a dest-node at front of the list, and insert its front-driven at the first</span>        path<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span>        n <span class="token operator">=</span> prev<span class="token punctuation">[</span>n<span class="token punctuation">]</span>    path<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> src<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># finally, insert src at the list.</span>    <span class="token keyword">return</span> <span class="token string">'->'</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>str<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># return built result string</span><span class="token keyword">def</span> <span class="token function">printsol</span><span class="token punctuation">(</span>dist<span class="token punctuation">,</span> vtx<span class="token punctuation">,</span> src<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Source:"</span><span class="token punctuation">,</span> src<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\t Destination \t Length \t Shortest Path"</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>vtx<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">" \t\t"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token string">"   \t\t  "</span><span class="token punctuation">,</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">" \t\t  "</span><span class="token punctuation">,</span> str2Path<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">mind</span><span class="token punctuation">(</span>dist<span class="token punctuation">,</span> foundset<span class="token punctuation">,</span> vtx<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">from</span> sys <span class="token keyword">import</span> maxsize <span class="token keyword">as</span> maxint    min_idx <span class="token operator">=</span> maxint    min_dist <span class="token operator">=</span> maxint    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>vtx<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> i <span class="token keyword">in</span> foundset<span class="token punctuation">:</span>            <span class="token keyword">continue</span>        <span class="token keyword">if</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> min_dist<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># find the minimal distance in not found vertexes</span>            min_dist <span class="token operator">=</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            min_idx <span class="token operator">=</span> i    <span class="token keyword">return</span> min_idx<span class="token keyword">def</span> <span class="token function">dj</span><span class="token punctuation">(</span>dist<span class="token punctuation">,</span> foundset<span class="token punctuation">,</span> graph<span class="token punctuation">,</span> vtx<span class="token punctuation">,</span> src<span class="token punctuation">)</span><span class="token punctuation">:</span>    dist<span class="token punctuation">[</span>src<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>vtx<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> graph<span class="token punctuation">[</span>src<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>            prev<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> src  <span class="token comment" spellcheck="true"># if have route src->i, initate all front-driven with source</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>vtx<span class="token punctuation">)</span><span class="token punctuation">:</span>        u <span class="token operator">=</span> mind<span class="token punctuation">(</span>dist<span class="token punctuation">,</span> foundset<span class="token punctuation">,</span> vtx<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># find the nearest neighbor</span>        foundset<span class="token punctuation">.</span>append<span class="token punctuation">(</span>u<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># set found</span>        <span class="token keyword">for</span> node <span class="token keyword">in</span> range<span class="token punctuation">(</span>vtx<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># for all destination</span>            <span class="token keyword">if</span> <span class="token operator">not</span> node <span class="token keyword">in</span> foundset<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># if that the shortest way to  destination have not found</span>                <span class="token keyword">if</span> graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>node<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># and have a way to destination</span>                    <span class="token keyword">if</span> dist<span class="token punctuation">[</span>node<span class="token punctuation">]</span> <span class="token operator">></span> dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">:</span>                        dist<span class="token punctuation">[</span>node<span class="token punctuation">]</span> <span class="token operator">=</span> dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>node<span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># update the shortest way with relay included</span>                        prev<span class="token punctuation">[</span>node<span class="token punctuation">]</span> <span class="token operator">=</span> u  <span class="token comment" spellcheck="true"># if have shorter path, then modify its front-driven with relay vertex</span>    printsol<span class="token punctuation">(</span>dist<span class="token punctuation">,</span> vtx<span class="token punctuation">,</span> src<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># print solution and shortest path length</span>dj<span class="token punctuation">(</span>dist<span class="token punctuation">,</span> foundset<span class="token punctuation">,</span> graph<span class="token punctuation">,</span> vtx<span class="token punctuation">,</span> src<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据结构复习-Chapter-7-图&quot;&gt;&lt;a href=&quot;#数据结构复习-Chapter-7-图&quot; class=&quot;headerlink&quot; title=&quot;数据结构复习 - Chapter 7 图&quot;&gt;&lt;/a&gt;数据结构复习 - Chapter 7 图&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
    
      <category term="School" scheme="https://www.kmahyyg.xyz/tags/School/"/>
    
      <category term="Datastru" scheme="https://www.kmahyyg.xyz/tags/Datastru/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法课程 - Chap 6 树和二叉树</title>
    <link href="https://www.kmahyyg.xyz/2019/ynu-datastru-c6/"/>
    <id>https://www.kmahyyg.xyz/2019/ynu-datastru-c6/</id>
    <published>2019-01-05T01:16:05.000Z</published>
    <updated>2019-02-24T12:39:17.218Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构复习-Chapter-6-树和二叉树"><a href="#数据结构复习-Chapter-6-树和二叉树" class="headerlink" title="数据结构复习 - Chapter 6 树和二叉树"></a>数据结构复习 - Chapter 6 树和二叉树</h1><h2 id="树的相关概念"><a href="#树的相关概念" class="headerlink" title="树的相关概念"></a>树的相关概念</h2><p>树定义： </p><ol><li>有限集合</li><li>子集为互不相交的有限集</li></ol><p>树表示：</p><ul><li>图形、嵌套集合（Venn 图）、目录表示法</li><li>广义表表示法：根作为由子树森林组成的表的名字写在表的左边<blockquote><p>(A(B(E(K,L),F),C(G),D(H(M),I,J))) </p></blockquote></li><li>左孩子、右兄弟表示</li></ul><p>节点定义：</p><ul><li>根节点：没有前驱</li><li>叶子节点：没有后继（度 == 0）</li><li>森林：指 m 棵不相交的树的集合</li><li>有序树：各子树从左至右有序，不可互换</li><li>节点的度： 节点挂接的子树的数目</li><li>节点的层次：从根（01 层）到该节点的层数</li><li>树的度： Max({各节点的度})</li><li>树的深度： Max({各节点的层次})</li></ul><h2 id="树的存储"><a href="#树的存储" class="headerlink" title="树的存储"></a>树的存储</h2><ul><li>顺序存储：从上至下，从左至右，无法复原、没有实用价值。</li><li><p>链式存储：一个前驱、n 个后继，过于浪费存储空间、结构和定义的数据类型过于复杂。</p></li><li><p>双亲表示：数组存储，根节点的 index 为 0,双亲 为 -1； 其他节点的双亲为 对应双亲的数组下标。</p></li><li>孩子表示：双亲存于数组，每个对应元素的指针域指向孩子，孩子与孩子间通过指针相连，没孩子则为 NULL。</li><li>带双亲的孩子表示法：数组的双亲节点可能同时是另一个节点的孩子，增加一个数据域存储双亲对应的数组下标。</li><li>孩子兄弟表示发： <code>firstchild | data | nextsibling</code>，左存储孩子，右存储兄弟，中间为数据。</li></ul><h2 id="重点：树到二叉树的转换"><a href="#重点：树到二叉树的转换" class="headerlink" title="重点：树到二叉树的转换"></a>重点：<strong>树到二叉树的转换</strong></h2><ol><li>对每个孩子进行从左到右的排序；</li><li>在兄弟之间加一条连线；</li><li>对每个结点，除了左孩子外，去除其与其余孩子之间的联系；</li><li>以根结点为轴心，将整个树顺时针转45°。</li></ol><h2 id="次重点：-森林到二叉树的转换"><a href="#次重点：-森林到二叉树的转换" class="headerlink" title="次重点： 森林到二叉树的转换"></a>次重点： <strong>森林到二叉树的转换</strong></h2><p>兄弟相连 长兄为父 孩子靠左 头根为根</p><h2 id="次重点：-二叉树到森林的转换"><a href="#次重点：-二叉树到森林的转换" class="headerlink" title="次重点： 二叉树到森林的转换"></a>次重点： <strong>二叉树到森林的转换</strong></h2><p>把最右边的子树变为森林，其余右子树变为兄弟</p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>所有树都能转为唯一对应的二叉树。 <strong>是一种有序树</strong></p><p>满二叉树：深度为 k 且含有 2k-1 个结点的二叉树。</p><p>完全二叉树：树中所含的 n 个结点和满二叉树中编号为 1 至 n 的结点一一对应。上面的要满，左边的要满，只有最右边 1 个不满或空。具有 n 个结点的完全二叉树的高度为 <code>[log2n] + 1</code> 。</p><h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><ul><li>数组，BFS 遍历，顺序存储，但无法唯一复原</li><li>二叉链表： <code>lchild | data | rchild</code></li><li>三叉链表： <code>lchild | data | parent | rchild</code></li></ul><h3 id="重点：二叉树的遍历与重建"><a href="#重点：二叉树的遍历与重建" class="headerlink" title="重点：二叉树的遍历与重建"></a><strong>重点：二叉树的遍历与重建</strong></h3><p>对于森林的遍历，从左到右依次对每棵树进行遍历即可。</p><h4 id="DFS-深度优先"><a href="#DFS-深度优先" class="headerlink" title="DFS 深度优先"></a>DFS 深度优先</h4><p>3.1.1 先根次序遍历</p><p>先根次序遍历按照“根结点-左孩子-右孩子”的顺序进行访问。</p><p>（1）递归实现</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//先根递归遍历</span><span class="token keyword">void</span> <span class="token function">preOrderRecursion</span><span class="token punctuation">(</span>BinaryTreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>root<span class="token operator">-</span><span class="token operator">></span>m_key<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//visit</span>    <span class="token function">preOrderRecursion</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>m_pLeft<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">preOrderRecursion</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>m_pRight<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）非递归实现 </p><p>根据前序遍历访问的顺序，优先访问根结点，然后再分别访问左孩子和右孩子。即对于任一结点，其可看做是根结点，因此可以直接访问，访问完之后，若其左孩子不为空，按相同规则访问它的左子树；当访问完左子树时，再访问它的右子树。因此其处理过程如下：</p><p>给定二叉树的根节点R： </p><p>(a)并将根节点R入栈；</p><p>(b)判断栈是否为空，若不为空，取栈顶元素cur访问并出栈。然后先将cur的右子节点入栈，再将cur的左子节点入栈；</p><p>(c)重复(b)直到栈为空，则遍历结束。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//先根非递归遍历，需要使用栈</span><span class="token keyword">void</span> <span class="token function">preOrderStack</span><span class="token punctuation">(</span>BinaryTreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>     stack<span class="token operator">&lt;</span>BinaryTreeNode<span class="token operator">*</span><span class="token operator">></span> stack<span class="token punctuation">;</span>    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    BinaryTreeNode<span class="token operator">*</span> cur<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cur<span class="token operator">=</span>stack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cout<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>cur<span class="token operator">-</span><span class="token operator">></span>m_key<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//visit</span>        stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">-</span><span class="token operator">></span>m_pRight<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token operator">-</span><span class="token operator">></span>m_pRight<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">-</span><span class="token operator">></span>m_pLeft<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token operator">-</span><span class="token operator">></span>m_pLeft<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.1.2中根次序遍历</p><p>中序遍历按照“左孩子-根结点-右孩子”的顺序进行访问。 </p><p> （1）递归实现</p><pre><code>//中根递归遍历void midOrderRecursion(BinaryTreeNode* root){    if(root==NULL)        return;    midOrderRecursion(root-&gt;m_pLeft);    cout&lt;&lt;&quot; &quot;&lt;&lt;root-&gt;m_key;   //visit    midOrderRecursion(root-&gt;m_pRight);}</code></pre><p>（2）非递归实现 </p><p>根据中序遍历的顺序，对于任一结点，先访问其左孩子，而左孩子结点又可以看做一根结点，然后继续访问其左孩子结点，直到遇到左孩子结点为空的结点才进行访问，然后按相同的规则访问其右子树。因此其处理过程如下：</p><p>对于给定的二叉树根节点R， </p><p> (a)若其左孩子不为空，循环将R以及R左子树中的所有节点的左孩子入栈； </p><p> (b)取栈顶元素cur，访问cur并将cur出栈。然后对cur的右子节点进行步骤（a）那样的处理； </p><p> (c)重复（a）和（b）的操作，直到cur为空切栈为空。</p><pre><code>//中根非递归遍历，需要使用栈void midOrderStack(BinaryTreeNode* root){    if(root==NULL)        return;     stack&lt;BinaryTreeNode*&gt; stack;    BinaryTreeNode* cur=root;    while(!stack.empty()||cur!=NULL){          while(cur){              stack.push(cur);              cur=cur-&gt;m_pLeft;          }          cur=stack.top();          cout&lt;&lt;&quot; &quot;&lt;&lt;cur-&gt;m_key;   //visit        stack.pop();          cur=cur-&gt;m_pRight;      }              }</code></pre><p>3.1.3后根次序遍历</p><p>后序遍历按照“左孩子-右孩子-根结点”的顺序进行访问。 </p><p> （1）递归实现</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//后根递归遍历</span><span class="token keyword">void</span> <span class="token function">postOrderRecursion</span><span class="token punctuation">(</span>BinaryTreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token function">postOrderRecursion</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>m_pLeft<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">postOrderRecursion</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>m_pRight<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>root<span class="token operator">-</span><span class="token operator">></span>m_key<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//visit</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）非递归实现 </p><p>后序遍历的非递归实现是三种遍历方式中最难的一种。因为在后序遍历中，要保证左孩子和右孩子都已被访问并且左孩子要在右孩子前被访问，才能访问根节点。这就为流程的控制带来了难题。</p><p>对于任一结点P，将其入栈，然后沿其左子树一直往下搜索，直到搜索到没有左孩子的结点，此时该结点出现在栈顶，但是此时不能将其出栈并访问，因此其右孩子还为被访问。所以接下来按照相同的规则对其右子树进行相同的处理，当访问完其右孩子时，该结点又出现在栈顶，此时可以将其出栈并访问。这样就保证了正确的访问顺序。可以看出，在这个过程中，每个结点都两次出现在栈顶，只有在第二次出现在栈顶时，才能访问它。因此需要多设置一个变量标识该结点是否是第一次出现在栈顶。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//非递归后序遍历，版本1</span><span class="token keyword">void</span> <span class="token function">postOrderStack1</span><span class="token punctuation">(</span>BinaryTreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>     stack<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span>BinaryTreeNode<span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token operator">></span> s<span class="token punctuation">;</span>    pair<span class="token operator">&lt;</span>BinaryTreeNode<span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">bool</span><span class="token operator">></span> cur<span class="token operator">=</span><span class="token function">make_pair</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>first<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token operator">||</span><span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>first<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token comment" spellcheck="true">//沿左子树一直往下搜索，直至出现没有左子树的结点 </span>            s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>            cur<span class="token operator">=</span><span class="token function">make_pair</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>first<span class="token operator">-</span><span class="token operator">></span>m_pLeft<span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token operator">==</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//表示是第一次出现在栈顶 </span>                s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span>                cur<span class="token operator">=</span><span class="token function">make_pair</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token operator">-</span><span class="token operator">></span>m_pRight<span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将当前节点的右节点入栈</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">//第二次出现在栈顶 </span>                cout<span class="token operator">&lt;&lt;</span>s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token operator">-</span><span class="token operator">></span>m_key<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>                s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="BFS-深度优先"><a href="#BFS-深度优先" class="headerlink" title="BFS 深度优先"></a>BFS 深度优先</h4><p>广度优先周游的方式是按层次从上到下，从左到右的逐层访问，不难想到，可以利用一个队列来实现。基本思想是：<br> （1）首先把二叉树的根节点送入队列；<br> （2）队首的节点出队列并访问之，然后把它的右子节点和左子节点分别入队列；<br> （3）重复上面两步操作，直至队空。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//广度优先遍历二叉树，使用队列实现</span><span class="token keyword">void</span> <span class="token function">breadthFirstOrder</span><span class="token punctuation">(</span>BinaryTreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    queue<span class="token operator">&lt;</span>BinaryTreeNode<span class="token operator">*</span><span class="token operator">></span> queue<span class="token punctuation">;</span>    queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        BinaryTreeNode<span class="token operator">*</span> cur<span class="token operator">=</span>queue<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cout<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>cur<span class="token operator">-</span><span class="token operator">></span>m_key<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//visit</span>        queue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">-</span><span class="token operator">></span>m_pLeft<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span>            queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token operator">-</span><span class="token operator">></span>m_pLeft<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">-</span><span class="token operator">></span>m_pRight<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span>            queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token operator">-</span><span class="token operator">></span>m_pRight<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="先序-中序-重建"><a href="#先序-中序-重建" class="headerlink" title="先序+中序 重建"></a>先序+中序 重建</h4><p>构建过程：<br> （1）前序遍历序列中的第一个数字为根节点，构造根节点；<br> （2）找到根节点在中序遍历序列中的位置，中序中根节点左右两边分别为左子树和有子树，前序序列根节点后面为左子树+右子树；<br> （3）递归处理处理左右子树，返回根节点，完成构造。</p><p>由于在中序遍历中，有三个左子树节点的值，因此在前序遍历的序列中，根节点后面的3个数字就是3个左子树节点的值，再后面的所有数字都是右子树节点的值。这样子我们就在前序序列和中序序列中找到了左右子书对应的子序列，然后再递归处理即可。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//二叉树节点结构体</span><span class="token keyword">struct</span> BinaryTreeNode<span class="token punctuation">{</span>    <span class="token keyword">int</span> m_key<span class="token punctuation">;</span>    BinaryTreeNode<span class="token operator">*</span> m_pLeft<span class="token punctuation">;</span>    BinaryTreeNode<span class="token operator">*</span> m_pRight<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/****************************************func:根据前序序列和中序序列构建二叉树para:preOrder:前序序列;midOrder:中序序列;len:节点数****************************************/</span>BinaryTreeNode<span class="token operator">*</span> <span class="token function">construct</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> preOrder<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">*</span> midOrder<span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>preOrder<span class="token operator">==</span><span class="token constant">NULL</span><span class="token operator">||</span>midOrder<span class="token operator">==</span><span class="token constant">NULL</span><span class="token operator">||</span>len<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//先根遍历（前序遍历）的第一个值就是根节点的键值</span>    <span class="token keyword">int</span> rootKey<span class="token operator">=</span>preOrder<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    BinaryTreeNode<span class="token operator">*</span> root<span class="token operator">=</span><span class="token keyword">new</span> BinaryTreeNode<span class="token punctuation">;</span>    root<span class="token operator">-</span><span class="token operator">></span>m_key<span class="token operator">=</span>rootKey<span class="token punctuation">;</span>    root<span class="token operator">-</span><span class="token operator">></span>m_pLeft<span class="token operator">=</span>root<span class="token operator">-</span><span class="token operator">></span>m_pRight<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>len<span class="token operator">==</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>preOrder<span class="token operator">==</span><span class="token operator">*</span>midOrder<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//只有一个节点</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//在中根遍历（中序遍历）中找到根节点的值</span>    <span class="token keyword">int</span><span class="token operator">*</span> rootMidOrder<span class="token operator">=</span>midOrder<span class="token punctuation">;</span>    <span class="token keyword">int</span> leftLen<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//左子树节点数</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">*</span>rootMidOrder<span class="token operator">!=</span>rootKey<span class="token operator">&amp;&amp;</span>rootMidOrder<span class="token operator">&lt;=</span><span class="token punctuation">(</span>midOrder<span class="token operator">+</span>len<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token operator">++</span>rootMidOrder<span class="token punctuation">;</span>        <span class="token operator">++</span>leftLen<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">*</span>rootMidOrder<span class="token operator">!=</span>rootKey<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//在中根序列未找到根节点,输入错误</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>leftLen<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//构建左子树</span>        root<span class="token operator">-</span><span class="token operator">></span>m_pLeft<span class="token operator">=</span><span class="token function">construct</span><span class="token punctuation">(</span>preOrder<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>midOrder<span class="token punctuation">,</span>leftLen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>len<span class="token operator">-</span>leftLen<span class="token number">-1</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//构建右子树</span>        root<span class="token operator">-</span><span class="token operator">></span>m_pRight<span class="token operator">=</span><span class="token function">construct</span><span class="token punctuation">(</span>preOrder<span class="token operator">+</span>leftLen<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>rootMidOrder<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token operator">-</span>leftLen<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> root<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p><strong>遍历的实质是对非线性结构的二叉树进行线性化处理</strong></p><p>存储结构： <code>lchild | ltag | data | rtag | rchild</code></p><p> Tag == 0, 正常指向孩子；Tag == 1, lchild 指向前驱，rchild 指向后继。(前驱和后继由遍历获得)</p><p>为解决悬空，在线索链表中添加了一个“头结点”，头结点的左指针指向二叉树的根结点，其右线索指向遍历序列中的最后一个结点，即头结点的 LTag =0; RTag = 1。遍历序列中第一个结点的 lchild 域和最后一个结点的 rchild 域都指向头结点。（没有头节点，则最后一个左孩子的 lchild 和 最后一个右孩子的 rchild 为 NULL 指针，悬空状态。 <strong>实现过程注意检测是否为叶子节点即可</strong> ）</p><h3 id="非常重要：-Huffman-Tree"><a href="#非常重要：-Huffman-Tree" class="headerlink" title="非常重要： Huffman Tree"></a>非常重要： <strong>Huffman Tree</strong></h3><p>这是最优二叉树，带权路径最短。</p><ul><li>树的带权路径长度：树中所有叶子结点的带权路径长度之和。</li><li>结点带权路径长度 WPL(Weighted Path Length)：结点到根的路径长度与结点上权的乘积。</li><li>路径长度：路径上的分支数目。</li><li>树的路径长度：从树根到每一结点的路径长度之和。</li></ul><p>Huffman 编码：利用 Huffman 树可以构造一种不等长的二进制编码，并且构造所得的 Huffman 编码是一种最优前缀编码，即：需要传输的电文的总长度最短。任何一个字符的编码都不是同一字符集中另一个字符的编码的前缀。”左 0 右 1”</p><p><img src="https://alicdn.kmahyyg.xyz/asset_files/Huffman_tree_2.svg" alt="huffman_tree"></p><p><strong>权重最低的为叶子节点，叶子节点的双亲节点为孩子的权重之和，依此类推，根节点的孩子节点的权重最高，对应单字符的权重最高、使用频率最高、电文最短。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据结构复习-Chapter-6-树和二叉树&quot;&gt;&lt;a href=&quot;#数据结构复习-Chapter-6-树和二叉树&quot; class=&quot;headerlink&quot; title=&quot;数据结构复习 - Chapter 6 树和二叉树&quot;&gt;&lt;/a&gt;数据结构复习 - Chapter 6
      
    
    </summary>
    
    
      <category term="School" scheme="https://www.kmahyyg.xyz/tags/School/"/>
    
      <category term="Datastru" scheme="https://www.kmahyyg.xyz/tags/Datastru/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法课程 - Chap 5 数组和广义表</title>
    <link href="https://www.kmahyyg.xyz/2019/ynu-datastru-c5/"/>
    <id>https://www.kmahyyg.xyz/2019/ynu-datastru-c5/</id>
    <published>2019-01-05T01:15:56.000Z</published>
    <updated>2019-02-24T12:39:17.218Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构复习-Chapter-5-数组和广义表"><a href="#数据结构复习-Chapter-5-数组和广义表" class="headerlink" title="数据结构复习 - Chapter 5 数组和广义表"></a>数据结构复习 - Chapter 5 数组和广义表</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>高级语言中的数组一定是顺序结构，元素的值并非原子类型，可以再分解。 <strong>广义的线性表包括线性表元素组成的线性表</strong></p><p><strong>这里的数组中的每一维度的元素长度是不相同的。</strong></p><h3 id="数组的顺序保存结构的地址计算"><a href="#数组的顺序保存结构的地址计算" class="headerlink" title="数组的顺序保存结构的地址计算"></a>数组的顺序保存结构的地址计算</h3><ol><li>多维数组的元素存储反复故事： 行优先/列优先。</li><li>数组寻址格式： 起始位置 + 数组 A 前面保存的元素 × 元素的长度。</li><li>画图！画图啊！</li></ol><h3 id="广义的数组顺序表示"><a href="#广义的数组顺序表示" class="headerlink" title="广义的数组顺序表示"></a>广义的数组顺序表示</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property">#<span class="token directive keyword">define</span> MAX_ARRAY_DIM 8</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>    ElemType <span class="token operator">*</span>baseaddr<span class="token punctuation">;</span>    <span class="token keyword">int</span> dim<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>bounds<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>constants<span class="token punctuation">;</span><span class="token punctuation">}</span>Array<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Baseaddr: 存储数组的内存空间的基地址<br>Dim: 数组的最高维度<br>Bounds： 存储每一维数组长度的内存空间的基地址<br>Constants： 存放各数据的内存空间的基地址</p><h3 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h3><h4 id="可变长参数列表-stdarg-h"><a href="#可变长参数列表-stdarg-h" class="headerlink" title="可变长参数列表 stdarg.h"></a>可变长参数列表 stdarg.h</h4><p><a href="https://www.kmahyyg.xyz/2018/DS04-Maze-EXP/#stdarg-h-%E5%9C%A8-C-%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8">https://www.kmahyyg.xyz/2018/DS04-Maze-EXP/#stdarg-h-%E5%9C%A8-C-%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8</a></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdarg.h></span></span><span class="token keyword">int</span> <span class="token function">echoinfo</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>strNotice<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> noti<span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">strcpy</span><span class="token punctuation">(</span>noti<span class="token punctuation">,</span><span class="token string">"The printout is"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">echoinfo</span><span class="token punctuation">(</span>noti<span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">echoinfo</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>strNotice<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span>str0 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>str1 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>str2 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    va_list stArgv<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// define a param list</span>    <span class="token function">va_start</span><span class="token punctuation">(</span>stArgv<span class="token punctuation">,</span> strNotice<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// pass the fixed param to the function</span>    str0 <span class="token operator">=</span> <span class="token function">va_arg</span><span class="token punctuation">(</span>stArgv<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    str1 <span class="token operator">=</span> <span class="token function">va_arg</span><span class="token punctuation">(</span>stArgv<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    str2 <span class="token operator">=</span> <span class="token function">va_arg</span><span class="token punctuation">(</span>stArgv<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s: %s %s %s"</span><span class="token punctuation">,</span> strNotice<span class="token punctuation">,</span> str0<span class="token punctuation">,</span> str1<span class="token punctuation">,</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">va_end</span><span class="token punctuation">(</span>stArgv<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="矩阵的压缩存储"><a href="#矩阵的压缩存储" class="headerlink" title="矩阵的压缩存储"></a>矩阵的压缩存储</h4><ul><li>为多值相同的元素只分配一个存储空间</li><li>对 0 元素不分配存储空间</li><li>值相同或 0 元素在矩阵中的分布有一定规律，则称其为特殊矩阵，否则称之为稀疏矩阵。（也就是说正常的矩阵应当是稀疏的）</li><li>保存格式 &lt;行，列，值&gt;</li></ul><h2 id="特殊矩阵"><a href="#特殊矩阵" class="headerlink" title="特殊矩阵"></a>特殊矩阵</h2><h3 id="三角矩阵"><a href="#三角矩阵" class="headerlink" title="三角矩阵"></a>三角矩阵</h3><p>数组保存的下标：</p><ul><li>上三角：[列*(列-1)]/2+行</li><li>下三角：[行*(行-1)]/2+列</li></ul><h4 id="重点：矩阵的转置"><a href="#重点：矩阵的转置" class="headerlink" title="重点：矩阵的转置"></a>重点：矩阵的转置</h4><p>快速转置算法： </p><p>每一列第一个非零元素保存个数位置 = 上一列第一个非零元素保存位置 + 上一列非零元素。</p><p>num 数组 存储 M 中 第 col 列中非 0 元素个数<br>cpot 数组 存储 M 中 第 col 列的非 0 元素在 T.data 中的保存位置。</p><p>把转置后的位置放到 cpot 数组对应的位置，然后 cpot++;</p><h4 id="稀疏矩阵的乘法"><a href="#稀疏矩阵的乘法" class="headerlink" title="稀疏矩阵的乘法"></a>稀疏矩阵的乘法</h4><p>矩阵乘法 = <strong>M 矩阵该行所有元素对应与 N 矩阵该列所有元素分别相乘之和</strong></p><h4 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h4><p>[所在行，所在列，非零元素，向右域，向下域]</p><h2 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h2><p>表头 = 头元素，第一个元素<br>表尾 = <strong>后面的所有元素，表尾必须是一个广义表</strong></p><p>广义表特点：有次序性、有长度、有深度、可以递归定义、可以共享。<br>广义表的长度：最外层括号的元素个数<br>广义表的深度：括号层数（有多少括号匹配）</p><p>数据保存时，需要添加 tag 标志域，区分表节点与数据 (Atom) 节点。</p><p>[tag=0,data=atom]<br>[tag=1,headptr=head,endptr=tail]</p><p>headptr 永远指向表或者表元素，也是唯一一个可以直接指向 atom 元素的指针。</p><p>广义表中的数据元素有数据的相对次序，一个直接前驱、一个直接后继。</p><p>广义表的 ADT 表示，借此复习 ADT 的表示方法：</p><pre class="line-numbers language-cpp"><code class="language-cpp">ADT Glist <span class="token punctuation">{</span>    数据对象：    D＝<span class="token punctuation">{</span>ei <span class="token operator">|</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span>n<span class="token punctuation">;</span> n≥<span class="token number">0</span><span class="token punctuation">;</span> ei∈AtomSet或ei∈Glist<span class="token punctuation">}</span>    数据关系：    LR＝<span class="token punctuation">{</span><span class="token operator">&lt;</span>ei<span class="token number">-1</span><span class="token punctuation">,</span> ei<span class="token operator">></span><span class="token operator">|</span> ei<span class="token number">-1</span> <span class="token punctuation">,</span>ei ∈D<span class="token punctuation">,</span>  <span class="token number">2</span>≤i≤n <span class="token punctuation">}</span>    基本操作：    <span class="token function">InitGList</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//创建空的广义表L。</span>    <span class="token function">DestroyGList</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>L<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//销毁广义表L。</span>    <span class="token function">CreateGList</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>L<span class="token punctuation">,</span> S<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">//由串S创建广义表L。</span>    <span class="token function">CopyGList</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>T<span class="token punctuation">,</span> L<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 由广义表L复制得到广义表T。</span>    <span class="token function">GListLength</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">GListDepth</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">GListEmpty</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 判深、判空、判长</span>    <span class="token function">GetHead</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//取表头 (可能是原子或列表);</span>    <span class="token function">GetTail</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//取表尾 (一定是列表) </span>    <span class="token function">InsertFirst_GL</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>L<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//插入元素e作为广义表L的第一元素。</span>    <span class="token function">DeleteFirst_GL</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>L<span class="token punctuation">,</span> <span class="token operator">&amp;</span>e<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//删除广义表L的第一元素，并用e返回其值。</span><span class="token punctuation">}</span>ADT Glist<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据结构复习-Chapter-5-数组和广义表&quot;&gt;&lt;a href=&quot;#数据结构复习-Chapter-5-数组和广义表&quot; class=&quot;headerlink&quot; title=&quot;数据结构复习 - Chapter 5 数组和广义表&quot;&gt;&lt;/a&gt;数据结构复习 - Chapte
      
    
    </summary>
    
    
      <category term="School" scheme="https://www.kmahyyg.xyz/tags/School/"/>
    
      <category term="Datastru" scheme="https://www.kmahyyg.xyz/tags/Datastru/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法课程 - Chap 4 串</title>
    <link href="https://www.kmahyyg.xyz/2019/ynu-datastru-c4/"/>
    <id>https://www.kmahyyg.xyz/2019/ynu-datastru-c4/</id>
    <published>2019-01-05T01:15:48.000Z</published>
    <updated>2019-02-24T12:39:17.218Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构复习-Chapter-4-串"><a href="#数据结构复习-Chapter-4-串" class="headerlink" title="数据结构复习 - Chapter 4 串"></a>数据结构复习 - Chapter 4 串</h1><h2 id="本质区分-（C-语言）"><a href="#本质区分-（C-语言）" class="headerlink" title="本质区分 （C 语言）"></a>本质区分 （C 语言）</h2><p>字符串：  “ “ 中间，本质是 <strong>字符数组</strong> ，本质是线性表结构，结尾 ‘\0’ 不计入长度<br>字符： ‘ ‘ 中间的元素</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><pre class="line-numbers language-c"><code class="language-c"><span class="token function">StrAssign</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>T<span class="token punctuation">,</span> chars<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 给字符串赋值</span><span class="token function">StrCpy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>T<span class="token punctuation">,</span> S<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 复制 S 到 T</span><span class="token function">StrCmp</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 比较二进制的字符串是否符合</span><span class="token function">StrConcat</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>T<span class="token punctuation">,</span> S1<span class="token punctuation">,</span> S2<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 链接 S1 S2 至 T</span><span class="token function">Strlen</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 字符串长度</span><span class="token function">SubStr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Sub<span class="token punctuation">,</span>S<span class="token punctuation">,</span> Pos<span class="token punctuation">,</span>Len<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 返回 S 中 pos 位（含）起长度为 len 的子串至 Sub</span><span class="token function">StrDestroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 销毁串 S</span><span class="token function">StrIsEmpty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 串 S 判空</span><span class="token function">StrIndex</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> T<span class="token punctuation">,</span> pos<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 返回 T 在 S 的 pos 位置之后第一次出现的位置</span><span class="token function">StrIns</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">,</span> pos<span class="token punctuation">,</span> T<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 串 S 的第 pos 个字符之前插入串 T</span><span class="token function">StrReplace</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">,</span>T<span class="token punctuation">,</span>V<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 用 V 替换 S 中 符合 T 的串</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="表示与实现"><a href="#表示与实现" class="headerlink" title="表示与实现"></a>表示与实现</h2><h3 id="机内表示"><a href="#机内表示" class="headerlink" title="机内表示"></a>机内表示</h3><ul><li>定长顺序表示： 静态存储，地址连续的存储单元。</li><li>堆分配存储： 动态分配的一块地址连续的存储单元。</li><li>串的块链存储表示：链式存储，块链存储，以 <strong>“串的整体”作为操作对象</strong> 。</li></ul><h4 id="块链结构"><a href="#块链结构" class="headerlink" title="块链结构"></a>块链结构</h4><ol><li>每个节点存放多个字符合理，多个是几个？存储密度计算：串值存储位/实际分配存储位。</li></ol><p>块链结构描述：</p><ul><li>每个结点存放多个字符</li><li>结点中空位采用特殊符号填充</li><li>设置 tail 指针指向链表中的最后一个节点位置，方便进行串链接操作，需要注意处理串尾的第一个无效字符。</li></ul><h2 id="模式匹配算法"><a href="#模式匹配算法" class="headerlink" title="模式匹配算法"></a>模式匹配算法</h2><p>BruteForce &amp; KMP:</p><p><a href="https://www.kmahyyg.xyz/2018/KMP-BF-DataStru/">https://www.kmahyyg.xyz/2018/KMP-BF-DataStru/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据结构复习-Chapter-4-串&quot;&gt;&lt;a href=&quot;#数据结构复习-Chapter-4-串&quot; class=&quot;headerlink&quot; title=&quot;数据结构复习 - Chapter 4 串&quot;&gt;&lt;/a&gt;数据结构复习 - Chapter 4 串&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
    
      <category term="School" scheme="https://www.kmahyyg.xyz/tags/School/"/>
    
      <category term="Datastru" scheme="https://www.kmahyyg.xyz/tags/Datastru/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法课程 - Chap 3 栈与队列</title>
    <link href="https://www.kmahyyg.xyz/2019/ynu-datastru-c3/"/>
    <id>https://www.kmahyyg.xyz/2019/ynu-datastru-c3/</id>
    <published>2019-01-05T01:15:40.000Z</published>
    <updated>2019-02-24T12:39:17.218Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构复习-Chapter-3-栈与队列"><a href="#数据结构复习-Chapter-3-栈与队列" class="headerlink" title="数据结构复习 - Chapter 3 栈与队列"></a>数据结构复习 - Chapter 3 栈与队列</h1><p>区分：</p><p>L = (a1 … an)</p><p>线性表: 表头、表尾均可插入删除。</p><p>栈：只能在表尾进行插入和删除。Last-in-First-Out.</p><p>队列：表尾插入，表头删除。 First-in-First-Out.</p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p><strong>栈顶指针：总是指向栈顶元素之上的数组下标位置（最上一个可用空间）</strong><br>top == base 指针，则栈空。</p><h2 id="函数调用问题"><a href="#函数调用问题" class="headerlink" title="函数调用问题"></a>函数调用问题</h2><ol><li>将当前函数的控制转移到被调用函数的入口</li><li>为被调用函数的局部变量分配存储区</li><li>将实在参数、返回地址等信息传递给被调用参数保存</li></ol><h3 id="递归调用"><a href="#递归调用" class="headerlink" title="递归调用"></a>递归调用</h3><p>一个直接调用或通过一系列语句间接调用自己的函数成为递归函数。运行规则： <strong>后调用先返回</strong> ，被调用的函数占有的存储管理应当实行 “栈式存储”。</p><p>调用顺序： F -&gt; F1 -&gt; F2<br>返回顺序： F2 -&gt; F1 -&gt; F</p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>空队列：队头和队尾指针都指向头节点。<br>队头指针：永远指向出队的第一个元素位置<br>队尾：永远指向出队的最后一个元素，判空方法 <code>Queue.rear == CurrentPtr</code></p><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>循环队列：即 设数组维数为 M，使数组下标为 M-1 的结点的指针域，指向数组下标为 0 的结点，从而连成一个环。</p><p>若 rear+1 == M, 则令 rear == 0  ( mod 运算)</p><p><strong>注：front 指向队首元素，rear 指向队尾元素的下一个位置</strong></p><p>操作实现:</p><pre><code>入队：sq[rear]=x    rear=(rear+1) % M出队：x=sq[front]   front=(front+1) % M区分队空队满：（用修改后的与不变的做比较）队空：rear==front        出队操作时才需判断队空队满：rear==(rear+1)% M  入队时判断队满，即 队头指针在队尾指针的下一个位置 （另外一个解决方案：Q.rear 所指向的单元恒为 NULL）              ↑        入队操作修改后的队列长度： [(Queue.rear - Queue.front + MaxQueueSize) % MaxQueueSize]</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据结构复习-Chapter-3-栈与队列&quot;&gt;&lt;a href=&quot;#数据结构复习-Chapter-3-栈与队列&quot; class=&quot;headerlink&quot; title=&quot;数据结构复习 - Chapter 3 栈与队列&quot;&gt;&lt;/a&gt;数据结构复习 - Chapter 3 栈与
      
    
    </summary>
    
    
      <category term="School" scheme="https://www.kmahyyg.xyz/tags/School/"/>
    
      <category term="Datastru" scheme="https://www.kmahyyg.xyz/tags/Datastru/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法课程 - Chap 2 线性表</title>
    <link href="https://www.kmahyyg.xyz/2019/ynu-datastru-c2/"/>
    <id>https://www.kmahyyg.xyz/2019/ynu-datastru-c2/</id>
    <published>2019-01-05T01:15:25.000Z</published>
    <updated>2019-02-24T12:39:17.218Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构复习-Chapter-2-线性表"><a href="#数据结构复习-Chapter-2-线性表" class="headerlink" title="数据结构复习 - Chapter 2 线性表"></a>数据结构复习 - Chapter 2 线性表</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>回顾：</p><p>线性结构：数据元素有序且有限，有且仅有一个起始节点与终端节点，并且每个节点最多只有一个直接前驱和直接后继，头节点没有直接前驱，尾节点没有直接后继。</p><p>线性表：由 n 个同类型的数据元素组成的有限序列。 n 定义为表长度。可以灵活增长、缩短、CRUD。</p><p>直接前驱与直接后继 用有序对表示：&lt;a2,a3&gt;</p><p>存在的应用方法：</p><ul><li>初始化</li><li>求长度、判空、清空</li><li>求所在位置序号、求前驱、求后继</li><li>插入、删除、读取</li><li>求交并</li></ul><h2 id="顺序表示"><a href="#顺序表示" class="headerlink" title="顺序表示"></a>顺序表示</h2><p>定义：按逻辑顺序依次存放在一组地址连续的存储单元。只存储本身的值，不存储逻辑关系，关系通过存储地址相邻来隐含表示。</p><p><strong>注意：数组下表从 0 开始，顺序表位序从 1 开始</strong>。</p><p>算法实现注意：</p><ol><li>入参检查，传入参数不合法返回 -1.</li><li>置空 != 销毁</li><li>顺序表冒泡排序问题</li><li>合并线性表，先排序后合并。</li></ol><p>顺序存储：</p><ul><li>特征：逻辑相邻、物理相邻</li><li>优点：随机查找快，O(1)，节省了存储关系的空间，结构简单、实现方便。</li><li>缺点：插入删除慢，O(n)，不能充分利用所有空间，可能溢出。</li></ul><h2 id="链式表示"><a href="#链式表示" class="headerlink" title="链式表示"></a>链式表示</h2><p>定义：任意存储单元存储数据元素，线性表数据元素的逻辑次序和物理保存次序不一定相同。<br>包括：单链表、双链表、多链表、循环链表。根据指针域数目和指向区分。</p><p>存储结构：</p><ol><li>区分头节点和首元节点。 空表的头节点，指针域为空，代表该链表为空（等价于头指针指向 NULL）。头指针指向头节点，作为首元结点的直接前驱。头节点的数据域可用于存储链表长度。</li></ol><p>查找：按位置、按 Value 查找。<br>插入：指针修改是难点。</p><h3 id="链表修改：-节点插入与删除"><a href="#链表修改：-节点插入与删除" class="headerlink" title="链表修改： 节点插入与删除"></a>链表修改： 节点插入与删除</h3><p>原则：先空后实。先修改新建节点的数据域和指针域，再修改原链表中的元素。</p><p>删除注意：保存现场，需要预保存指向下一元素的指针。</p><p>C 语言背景：如果条件为真 ? 则值为 X : 否则值为 Y</p><h3 id="循环链表与双向链表"><a href="#循环链表与双向链表" class="headerlink" title="循环链表与双向链表"></a>循环链表与双向链表</h3><p>循环链表：将终端指针域的 NULL 指向头节点，就得到了单链表。<br>判断依据：指针指向元素的 next 域是否与头指针重合。<br>特点：从任一节点出发均可找到表中的其他节点。</p><p>双向链表： prior = next = NULL 即为空。<br>插入删除遵循：先空后实。画图是关键。</p><h2 id="实验回顾"><a href="#实验回顾" class="headerlink" title="实验回顾"></a>实验回顾</h2><p>注意 数据处理与 Error Handler，其他的都是常规操作。画图就对了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据结构复习-Chapter-2-线性表&quot;&gt;&lt;a href=&quot;#数据结构复习-Chapter-2-线性表&quot; class=&quot;headerlink&quot; title=&quot;数据结构复习 - Chapter 2 线性表&quot;&gt;&lt;/a&gt;数据结构复习 - Chapter 2 线性表&lt;/
      
    
    </summary>
    
    
      <category term="School" scheme="https://www.kmahyyg.xyz/tags/School/"/>
    
      <category term="Datastru" scheme="https://www.kmahyyg.xyz/tags/Datastru/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法课程 - Chap 1 序言</title>
    <link href="https://www.kmahyyg.xyz/2019/ynu-datastru-c1/"/>
    <id>https://www.kmahyyg.xyz/2019/ynu-datastru-c1/</id>
    <published>2019-01-05T01:14:49.000Z</published>
    <updated>2019-02-24T12:39:17.218Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构复习-Chapter-1-序言"><a href="#数据结构复习-Chapter-1-序言" class="headerlink" title="数据结构复习 - Chapter 1 序言"></a>数据结构复习 - Chapter 1 序言</h1><h2 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h2><p>数据结构研究： 数据的 <strong>逻辑结构、存储结构、每种结构定义的运算</strong> 。</p><p>相关概念：</p><ul><li>数据：信息的符号表示</li><li>数据元素：数据的基本单位</li><li>数据项：一个数据元素可由若干个数据项组成，<strong>数据项是数据的不可分割的最小单位</strong>。</li><li>数据对象：性质相同的数据元素的集合，数据的一个子集。</li><li>结构：数据彼此之间存在的相互关系。</li><li>数据结构：相互之间存在的一种或多种特定关系的数据元素的集合。元素之间的相互联系称为逻辑结构。</li></ul><p>逻辑结构包括：</p><ul><li>集合：没有相关性。</li><li>线性关系：一对一。</li><li>树形关系：一对多。</li><li>图状结构：多对多。</li></ul><h2 id="ADT-抽象数据类型描述"><a href="#ADT-抽象数据类型描述" class="headerlink" title="ADT 抽象数据类型描述"></a>ADT 抽象数据类型描述</h2><p>表示对应数学模型及定义在该模型上的一组操作。</p><pre><code>ADT Typename{  Object: Definition  Relationship: Definition  BasicOperation: Definition} ADT Typename</code></pre><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>算法：指令的有限序列，每条指令包括一个或多个操作，五个特性：<strong>有穷、确定、可行性、输入、输出</strong> 。</p><p>算法意味着 <strong>可终止</strong> ，程序是 <strong>算法使用某种具体程序设计语言</strong> 具体实现。</p><p>算法的设计要求：</p><ul><li>正确性： 满足具体问题需求。</li><li>可读性：有助于阅读理解，简化后续维护与调试修改的难度。</li><li>健壮性（Robustness，鲁棒性）：具有容错处理能力。</li><li>效率 与 存储需求：算法执行时间 + 算法执行过程中所需的最大存储空间，与问题规模相关。</li></ul><h3 id="算法构成与复杂度问题"><a href="#算法构成与复杂度问题" class="headerlink" title="算法构成与复杂度问题"></a>算法构成与复杂度问题</h3><p>时间复杂度 &lt;=&gt; 运算工作量，对应问题规模<br>空间复杂度 &lt;=&gt; 对应需要的最大存储空间</p><p>算法：控制结构（循环、顺序、分支）+原操作（固有数据类型的操作）</p><p>例如：三次循环，从1到n，总次数为 n^3 ，时间复杂度为 O(n^3)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据结构复习-Chapter-1-序言&quot;&gt;&lt;a href=&quot;#数据结构复习-Chapter-1-序言&quot; class=&quot;headerlink&quot; title=&quot;数据结构复习 - Chapter 1 序言&quot;&gt;&lt;/a&gt;数据结构复习 - Chapter 1 序言&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="School" scheme="https://www.kmahyyg.xyz/tags/School/"/>
    
      <category term="Datastru" scheme="https://www.kmahyyg.xyz/tags/Datastru/"/>
    
  </entry>
  
  <entry>
    <title>君子务本</title>
    <link href="https://www.kmahyyg.xyz/2019/chinese-gentleman-works-hard/"/>
    <id>https://www.kmahyyg.xyz/2019/chinese-gentleman-works-hard/</id>
    <published>2019-01-05T01:04:50.000Z</published>
    <updated>2019-02-24T12:39:17.218Z</updated>
    
    <content type="html"><![CDATA[<h1 id="君子务本"><a href="#君子务本" class="headerlink" title="君子务本"></a>君子务本</h1><blockquote><p>有子曰：「其為人也孝弟，而好犯上者，鮮矣；不好犯上，而好作亂者，未之有也。君子務本，本立而道生。孝弟也者，其為仁之本與！」</p><p>——《论语·学而》</p></blockquote><p>孔子在数千年前提出了上述思想，用于描述儒家的一种对于组织行为的规范。儒家的组织行为规范，基本上以儒家的伦理道德思想为主轴，将每个人的定位与顺序厘清，以统治者为最高模范，再从个人的修养入手，以个人的「本质内涵」修养「内仁、外礼」，其在个人思想境界提升上至今仍具有重大的现实意义。</p><p>然而，放之今日，此言的适用者已经不仅仅局限于君王。“一位有志于修养高尚品德的君子，「修身」是他一切修养的根本，「修身」的根本一立住，「仁道」也就建立起来了。” 故曰：“君子务本，本立而道生。”</p><h2 id="那么，何为本？作为一个君子，如何务本？"><a href="#那么，何为本？作为一个君子，如何务本？" class="headerlink" title="那么，何为本？作为一个君子，如何务本？"></a>那么，何为本？作为一个君子，如何务本？</h2><p>《礼记·大学》中有如下记载：</p><blockquote><p>「古之欲明明德於天下者，先治其國；欲治其國者，先齊其家；欲齊其家者，先修其身；欲修其身者，先正其心；欲正其心者，先誠其意；欲誠其意者，先致其知，致知在格物。物格而後知至，知至而後意誠，意誠而後心正，心正而後身修，身修而後家齊，家齊而後國治，國治而後天下平。自天子以至於庶人，壹是皆以修身為本。其本亂而末治者否矣，其所厚者薄，而其所薄者厚，未之有也！此謂知本，此謂知之至也。」</p></blockquote><p>由此可知，“知本”（即“务本”）便是实现“三纲八目”（三纲：明明德、亲民、止于至善；八目：格物、致知、诚意、正心、修身、治国、齐家、平天下），即“修己”是治人的前提，也正是这一思想为后世“达则兼济天下，穷则独善其身”奠定了坚实的基础。</p><p>而我个人更喜欢著名国学大师南怀瑾老先生的提法，即“四纲七证八目”。四纲，即为“本”，“七证”则指出“君子务本”的几个基础步骤，“八目”则指出了圆满修行四纲的行为阶梯。</p><p>南老将《大学》原有的三纲加上大学之道一纲，三纲变四纲。大学之道作为首纲，与明明德、亲民、止于至善是一个修德悟道的整体。止于至善就是止于至道，因为离开道，至善的指向不明晰，个人修行容易落入茫然不知所措的空道。止于至道是明明德、亲民、止于至善三纲运用于个人修行与觉悟的领航，离开了道的指引，个人的修行与觉悟就如没有方向的航行与跋涉。大学之道做为大学四纲第一纲，引领二、三、四纲。全句做为大学全文的纲要，统领全文的精髓。所以南老把大学之道作为第一纲，具有深刻的中华文化内涵。</p><p>接下来确定了“四纲”之后，本文将着重谈一谈如何在“七证”指引之下寻求达到四纲并达到“八目”所追求的行为境界。</p><p>七证即知、止、定、静、安、虑、得。</p><p>七证的步骤又称七步学养功夫，是经文给出的七个求证大道学问的程序与步骤。整体来说，七证从人的认知、志向、心性、处事方面指导人们追寻大道。</p><p>在认知上，古语有云“小知不及大知”。七证中的“知”则是教导人们在小知的基础上达到大知的认知。所谓小知，即是言传知识；所谓大知，即是意会知识，小知是大知的一部分。近代西方异军突起，在自然科学上以严谨科学的实验和逻辑推理发现、推理自然规律，并用于进一步改造生活、认识生活、推动科技的发展。中华传统文化的精华部分则在小知的基础上继续前进，达到“转识成智”，深刻的诠释人与自然的关系，落实最终阴阳互动、天地人和谐发展的大道，也是一种面向天、地、人、物的广义上的“爱”，也就是最终君子务本的终极境界。</p><p>在志向上，当认知止于至善，也就达到了广义的“爱”的境界，“研学求真，于缉熙敬止”。知止，则志向安定。人生有了至善的终极目标，心境也就逐渐安定下来，大道已在心中，自然不为俗世琐事所拘束。心归于平静。</p><p>诸葛亮《诫子书》有云：“夫君子之行，静以修身，俭以养德，非淡泊无以明志，非宁静无以致远。”静，又似一把镜子，照见你心底的时时勤拂试，又照见你的明镜亦非台。心静则万事安定，自然处事方圆、考虑周全，便有包容万物的胸怀，反哺了静安之道。海纳百川也成了虑后的自然所得。一切都在冥冥之中归于自然，所得自为浑然天成，非人力之他力所求。最终达到了天地人和谐发展的大道，进入了面向天、地、人、物的广义上的大“爱”的境界。</p><p>这样明静知止的心，随遇而安，是生活中温暖的底蕴，即是君子务本的根本。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;君子务本&quot;&gt;&lt;a href=&quot;#君子务本&quot; class=&quot;headerlink&quot; title=&quot;君子务本&quot;&gt;&lt;/a&gt;君子务本&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;有子曰：「其為人也孝弟，而好犯上者，鮮矣；不好犯上，而好作亂者，未之有也。君子務本，本立而道生。孝
      
    
    </summary>
    
    
      <category term="School" scheme="https://www.kmahyyg.xyz/tags/School/"/>
    
  </entry>
  
  <entry>
    <title>关于 C 的 CRC32 实现</title>
    <link href="https://www.kmahyyg.xyz/2018/CRC32-Network/"/>
    <id>https://www.kmahyyg.xyz/2018/CRC32-Network/</id>
    <published>2018-12-04T21:14:28.000Z</published>
    <updated>2019-02-24T12:39:17.218Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><p>最近讲了计算机网络课程，在上课过程中明白了 CRC32 的人工计算方法。个人猜测后面计算机网络实验会做，趁最近忙碌，一鼓作气，在刚刚学完的时候一起实现了吧。</p><h2 id="关于-CRC32"><a href="#关于-CRC32" class="headerlink" title="关于 CRC32"></a>关于 CRC32</h2><p>具体的原理性的东西就不说了，大家自己搜索 IEEE 802.3 相关文档和维基百科吧。主要用途是传输过程中的错误检测，由于容错率高，简单易于实现，占用资源少，得到了广泛的应用。</p><h3 id="关于-手动计算"><a href="#关于-手动计算" class="headerlink" title="关于 手动计算"></a>关于 手动计算</h3><p>就那点内容，其实我也很懵逼，就多查查资料吧。剩下的就是 <code>Talk is cheap, show me the code!</code> ，大家自己根据 Reversed CRC32 的 GZip 实现参考吧。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// C Native implement, CRC32</span><span class="token comment" spellcheck="true">// Reference: RFC1952 https://tools.ietf.org/html/rfc1952</span><span class="token comment" spellcheck="true">// Reference: PEDIY https://bbs.pediy.com/thread-17195.htm</span><span class="token comment" spellcheck="true">// Reference: CSDN https://blog.csdn.net/xiaogugood/article/details/8724745</span><span class="token comment" spellcheck="true">// Reference: https://stackoverflow.com/questions/2587766/how-is-a-crc32-checksum-calculated</span><span class="token comment" spellcheck="true">// Reference: http://stigge.org/martin/pub/SAR-PR-2006-05.pdf</span><span class="token comment" spellcheck="true">// Written by Patrick Young</span><span class="token comment" spellcheck="true">// Created on Tuesday, December 11, 2018 2:57 PM</span><span class="token comment" spellcheck="true">// Updated on Wednesday, December 12, 2018 1:06 PM</span><span class="token comment" spellcheck="true">// Rev.5</span><span class="token comment" spellcheck="true">/* * The highest bit of the generator is always 1, so ignored in the polyabbr. * * Algorithm   Result       Check               Poly        Init       RefIn     RefOut     XorOut      ReversedPoly    CRC-32     0xCBF43926      0xCBF43926    0x04C11DB7      0xFFFFFFFF    true    true    0xFFFFFFFF   0xEDB88320 */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;inttypes.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> crc_table<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Table of CRCs of all 8-bit messages</span><span class="token keyword">int</span> is_crc_table_computed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//计算本字节后的CRC码，等于上一字节余式CRC码的低8位左移8位，加上上一字节CRC右移8位和本字节之和后所求得的CRC码</span><span class="token keyword">void</span> <span class="token function">make_crc_table</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> c<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> n <span class="token operator">&lt;</span> <span class="token number">256</span><span class="token punctuation">;</span> <span class="token operator">++</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// all groups contains 8 bits * 4 * n, XOR can be passed without any external opeation</span>        <span class="token comment" spellcheck="true">// divide the msg into 8-bit-long group</span>        c <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span> n<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// Least-Significant-Bit first.</span>                <span class="token comment" spellcheck="true">// Same CRC property but reversed to fit old hardware(low memory address save lower bits of data.)</span>                c<span class="token operator">=</span> <span class="token number">0xedb88320L</span> <span class="token operator">^</span> <span class="token punctuation">(</span>c <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 0 is non-sense.</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                c<span class="token operator">=</span> c <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        crc_table<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    is_crc_table_computed <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* * Update a running crc with the bytes buf[0..len-1] and returnthe updated crc. The crc should be initialized to zero. Pre- andpost-conditioning (one's complement) is performed within thisfunction so it shouldn't be done by the caller. Usage example: * *  unsigned long crc = 0L; * *  while (read_buffer(buffer, length) != EOF) { *      crc = update_crc(crc, buffer, length); *  } *   if (crc != original_crc) error(); **/</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">update_crc</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> crc<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> c <span class="token operator">=</span> crc <span class="token operator">^</span> <span class="token number">0xffffffffL</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>is_crc_table_computed<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">make_crc_table</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// build the crc table first for fast lookup</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*    （1）将上次计算出的CRC校验码右移一个字节；    （2）将移出的这个字节与新的要校验的字节进行XOR运算；    （3）用运算出的值在预先生成码表中进行索引，获取对应的值（称为余式）；    （4）用获取的值与第（1）步右移后的值进行XOR运算；    （5）如果要校验的数据已经处理完，则第（4）步的结果就是最终的CRC校验码。如果还有数据要进行处理，则再转到第（1）步运行。     */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> p <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> <span class="token operator">++</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>        c <span class="token operator">=</span> crc_table<span class="token punctuation">[</span><span class="token punctuation">(</span>c <span class="token operator">^</span> buf<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xff</span><span class="token punctuation">]</span> <span class="token operator">^</span> <span class="token punctuation">(</span>c <span class="token operator">>></span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// remove the non-sense zero and shifted bits</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> c <span class="token operator">^</span> <span class="token number">0xffffffffL</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// avoid "add zero as you want, not affected" problem</span><span class="token punctuation">}</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">crc</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Math theory by hand: (quotient + remainder)/divisor = 0</span>    <span class="token comment" spellcheck="true">// appended 0s is used for be a placeholder of remainder</span>    <span class="token keyword">return</span> <span class="token function">update_crc</span><span class="token punctuation">(</span><span class="token number">0L</span><span class="token punctuation">,</span>buf<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// recursive update crc checksum.</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">check_crcsum</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>src<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> sum<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// why should I calculate the damn divide</span>    <span class="token comment" spellcheck="true">// (data+crc) / divisor = 000 ,correct</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> xr <span class="token operator">=</span> <span class="token function">crc</span><span class="token punctuation">(</span>src<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">strlen</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// just calculate received data's CRC, check if corresponding is okay.</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The source is %s, Checksum calculated is: 0x%lx\n"</span><span class="token punctuation">,</span> src<span class="token punctuation">,</span> xr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>xr <span class="token operator">==</span> sum<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Data CRC check passed! \n\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The offered checksum 0x%lx is different from offered one. \n"</span><span class="token punctuation">,</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Data Corrupted! \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">printUsage</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Illegal input! \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Usage: %s &lt;SOURCE STRING> 0x&lt;CRC32SUM>\n"</span><span class="token punctuation">,</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Usage: If you want to calculate, just input source in ASCII mode. \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Usage: If you want to check, use the second param such as 1A3C5D78 as a HEX String.\n\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> argc <span class="token operator">!=</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printUsage</span><span class="token punctuation">(</span>argv<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">char</span> <span class="token operator">*</span>ipt <span class="token operator">=</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> final <span class="token operator">=</span> <span class="token function">crc</span><span class="token punctuation">(</span>ipt<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">strlen</span><span class="token punctuation">(</span>ipt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The source is: %s\n"</span><span class="token punctuation">,</span>ipt<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The CRC32 checksum is: 0x%lx \n\n"</span><span class="token punctuation">,</span>final<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">char</span> <span class="token operator">*</span>ipt <span class="token operator">=</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">char</span> <span class="token operator">*</span>csum <span class="token operator">=</span> argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span>csum<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">printUsage</span><span class="token punctuation">(</span>argv<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> hexcsum <span class="token operator">=</span> <span class="token function">strtoul</span><span class="token punctuation">(</span>csum<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> stats <span class="token operator">=</span> <span class="token function">check_crcsum</span><span class="token punctuation">(</span>ipt<span class="token punctuation">,</span>hexcsum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> stats<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.xilinx.com/support/documentation/application_notes/xapp209.pdf" target="_blank" rel="noopener">https://www.xilinx.com/support/documentation/application_notes/xapp209.pdf</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Preface&quot;&gt;&lt;a href=&quot;#Preface&quot; class=&quot;headerlink&quot; title=&quot;Preface&quot;&gt;&lt;/a&gt;Preface&lt;/h1&gt;&lt;p&gt;最近讲了计算机网络课程，在上课过程中明白了 CRC32 的人工计算方法。个人猜测后面计算机网络实验会
      
    
    </summary>
    
    
      <category term="Tech" scheme="https://www.kmahyyg.xyz/tags/Tech/"/>
    
      <category term="School" scheme="https://www.kmahyyg.xyz/tags/School/"/>
    
  </entry>
  
  <entry>
    <title>使用 Backblaze + Cloudflare 搭建 10G 免费网盘</title>
    <link href="https://www.kmahyyg.xyz/2018/B2-Cloudflare/"/>
    <id>https://www.kmahyyg.xyz/2018/B2-Cloudflare/</id>
    <published>2018-11-11T16:32:06.000Z</published>
    <updated>2019-02-24T12:39:17.218Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><p> Backblaze 作为一家专业提供云存储服务的厂商为我们提供了一个 B2 Cloud Storage 服务。其免费额度包含 10GiB 存储空间 + 每天 1 GiB 下载流量 + 每天 2500 次的 API 调用量。近期，由于 Cloudflare CDN 到 B2 服务器的流量不再计费，我们可以利用这一特性打造不限下载流量，附带全球免费 CDN 加成的下载网盘。</p><h1 id="Deploy"><a href="#Deploy" class="headerlink" title="Deploy"></a>Deploy</h1><h2 id="注册和登陆"><a href="#注册和登陆" class="headerlink" title="注册和登陆"></a>注册和登陆</h2><p>按照文字提示处理，B2 注册的时候不需要提供信用卡，请提供真实的账单地址以供验证。请注册完成之后创建 Bucket，然后任意上传一个文件，记录下该文件的 Friendly Download Address，以备后续使用。</p><h2 id="接入-Cloudflare"><a href="#接入-Cloudflare" class="headerlink" title="接入 Cloudflare"></a>接入 Cloudflare</h2><p>请参考我之前的博文： <a href="/2018/CAMAL-OfflineDL/">CAMAL 离线下载套件</a></p><p>接入时的几点注意：</p><ul><li>如果您使用 CNAME 方式接入，请注意检查是否已经由 Cloudflare 正确下发证书。</li><li>B2 Cloud Storage 要求请求的 URL 必须为 HTTPS，请您注意您分发时的 URL.</li><li>使用 CNAME 方式接入时的回源地址应为你的 Friendly Download Address 中的域名，如果这个方式无法正确下发域名，请您将其临时更改为其他启用了 HTTPS 的大站的域名并重新禁用、启用一次 Cloudflare Universal SSL，等待下发证书成功后改回即可。</li><li>接入完成并确认证书正确下发后再根据 Reference 设置您的 Page Rules 用以屏蔽未授权的访问。</li><li>在您的 权威 DNS 端的 CNAME 设置也请参考我之前的博文，如果存在问题，请先改为由伙伴面板提供的 CNAME 再切换为您想定义的其他线路。</li></ul><p>最终的文件访问 URL 格式应当为：  <code>https://&lt;YOUR CUSTOM DOMAIN WITH CLOUDFLARE ACCLERATED&gt;/file/&lt;BUCKET NAME&gt;/&lt;FILE NAME&gt;</code></p><p>具体的 B2 云存储相关的安全设置请参考 Backblaze 官方文档，Cloudflare 安全性相关设置请参考 Cloudflare 官方文档并结合您的自身需求。</p><p>Recommended Page Rules:</p><p><img src="https://alicdn.kmahyyg.xyz/asset_files/2018-b2cf-01.webp" alt="Recommended Page Rules"></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://help.backblaze.com/hc/en-us/articles/217666928-Using-Backblaze-B2-with-the-Cloudflare-CDN" target="_blank" rel="noopener">https://help.backblaze.com/hc/en-us/articles/217666928-Using-Backblaze-B2-with-the-Cloudflare-CDN</a></li><li><a href="https://www.kmahyyg.xyz/2018/CAMAL-OfflineDL/">https://www.kmahyyg.xyz/2018/CAMAL-OfflineDL/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Preface&quot;&gt;&lt;a href=&quot;#Preface&quot; class=&quot;headerlink&quot; title=&quot;Preface&quot;&gt;&lt;/a&gt;Preface&lt;/h1&gt;&lt;p&gt; Backblaze 作为一家专业提供云存储服务的厂商为我们提供了一个 B2 Cloud Stora
      
    
    </summary>
    
    
      <category term="Tech" scheme="https://www.kmahyyg.xyz/tags/Tech/"/>
    
  </entry>
  
  <entry>
    <title>将 CUPS 共享的打印机转为 Airprint 适用</title>
    <link href="https://www.kmahyyg.xyz/2018/Cups2Airprint/"/>
    <id>https://www.kmahyyg.xyz/2018/Cups2Airprint/</id>
    <published>2018-10-24T10:31:57.000Z</published>
    <updated>2019-02-24T12:39:17.218Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Convert-CUPS-Printer-to-Airprint-available"><a href="#Convert-CUPS-Printer-to-Airprint-available" class="headerlink" title="Convert CUPS Printer to Airprint-available"></a>Convert CUPS Printer to Airprint-available</h1><h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><p>由于人民日益增长的打印需要与打印店日益下降的打印质量和开门时间存在的巨大矛盾，已经穷得吃土的我买了一个打印机。<del>然而，迫于钱没加够，又有自动双面打印的需要（手动双面打印总是把纸放反……）所以舍弃了网络打印，买了个自动双面打印功能的 USB 打印机。</del></p><h2 id="Prepare"><a href="#Prepare" class="headerlink" title="Prepare"></a>Prepare</h2><ol><li>一台已经连接到打印机的服务器</li><li>一台安装了对应 Linux 发行版及对应打印机驱动并连接到对应局域网的 Linux 主机</li><li>可以正常运作的 CUPS 和 Avahi Daemon</li></ol><h2 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h2><p>请先确保您的打印机此时已经可以正常工作并能通过物理连接正常打印。</p><h3 id="CUPSD-添加打印机"><a href="#CUPSD-添加打印机" class="headerlink" title="CUPSD 添加打印机"></a>CUPSD 添加打印机</h3><p>添加一个打印机，做好默认设置，务必把打印机的默认打印设置配置好之后设为共享打印机，并对 CUPSD 打印服务器整体的打印共享功能打开。</p><h3 id="CUPSD-配置文件修改"><a href="#CUPSD-配置文件修改" class="headerlink" title="CUPSD 配置文件修改"></a>CUPSD 配置文件修改</h3><blockquote><p>/etc/cups/cupsd.conf </p></blockquote><p>在 <code>Listen /run/cups/cups.sock</code> 后面添加这个。</p><pre><code>Listen /run/cups/cups.sockListen 0.0.0.0:631PreserveJobHistoryFileDevice YesServerAlias *</code></pre><p>在这里添加对应的缺失的几行，并在 Web 管理控制端勾起 <code>Share printers connected to this system</code> 。</p><pre><code>&lt;Location /&gt;  # Allow shared printing...  Order allow,deny  Allow @LOCAL&lt;/Location&gt;&lt;Location /admin&gt;  Order allow,deny  allow @LOCAL&lt;/Location&gt;&lt;Location /admin/conf&gt;  AuthType Default  Require user @SYSTEM&lt;/Location&gt;&lt;Location /admin/log&gt;  AuthType Default  Require user @SYSTEM  Order allow,deny  allow @LOCAL&lt;/Location&gt;</code></pre><h3 id="创建-MIME-应用类型配置"><a href="#创建-MIME-应用类型配置" class="headerlink" title="创建 MIME 应用类型配置"></a>创建 MIME 应用类型配置</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># echo "image/urf urf string(0,UNIRAST&lt;00>)" > \</span>    /usr/share/cups/mime/airprint.types<span class="token comment" spellcheck="true"># echo "image/urf application/pdf 100 pdftoraster" > \</span>    /usr/share/cups/mime/airprint.convs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Avahi-Daemon-配置文件修改"><a href="#Avahi-Daemon-配置文件修改" class="headerlink" title="Avahi Daemon 配置文件修改"></a>Avahi Daemon 配置文件修改</h3><blockquote><p>/etc/avahi/avahi-daemon.conf </p></blockquote><pre><code>domain-name=local</code></pre><p>将这一行的注释符号去除。</p><h3 id="Avahi-Daemon-及-打印机支持添加"><a href="#Avahi-Daemon-及-打印机支持添加" class="headerlink" title="Avahi Daemon 及 打印机支持添加"></a>Avahi Daemon 及 打印机支持添加</h3><p>下载 参考文献 2 中的对应的 Python 脚本，并安装对应支持库。</p><p>请注意，该脚本只支持 Python 2, 安装依赖：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">apt-get</span> update -y <span class="token operator">&amp;&amp;</span> <span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> libxml2-dev$ <span class="token function">sudo</span> pip2 <span class="token function">install</span> pycups$ <span class="token function">sudo</span> pip2 <span class="token function">install</span> lxml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>接下来使用对应的参数将会对所有已经在 CUPSD 中配置好的打印机生成对应的 Avahi 服务并保存到对应目录：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> python2 ./airprint-generate.py -P <span class="token operator">&lt;</span>CUPS 服务器端口号<span class="token operator">></span> -u root -d /etc/avahi/services -p c2a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>重启服务，完成配置</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> systemctl restart avahi-daemon.service$ <span class="token function">sudo</span> systemctl restart org.cups.cupsd.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="Enjoy"><a href="#Enjoy" class="headerlink" title="Enjoy"></a>Enjoy</h2><p>打开连接到同一局域网的苹果设备，尝试打印，你就能看到对应 PC 连接的打印机了。</p><h2 id="Acknowledgement"><a href="#Acknowledgement" class="headerlink" title="Acknowledgement"></a>Acknowledgement</h2><ul><li><a href="https://askubuntu.com/questions/26130/how-can-share-my-printer-so-that-i-can-use-it-with-airprint" target="_blank" rel="noopener">AskUbuntu</a></li><li><a href="https://github.com/tjfontaine/airprint-generate" target="_blank" rel="noopener">Airprint Service Generator</a></li><li><a href="https://ezunix.org/index.php?title=Enable_iOS_AirPrint_with_any_printer_supported_by_CUPS" target="_blank" rel="noopener">EzUnix Tutorial</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Convert-CUPS-Printer-to-Airprint-available&quot;&gt;&lt;a href=&quot;#Convert-CUPS-Printer-to-Airprint-available&quot; class=&quot;headerlink&quot; title=&quot;Convert 
      
    
    </summary>
    
    
      <category term="Tech" scheme="https://www.kmahyyg.xyz/tags/Tech/"/>
    
  </entry>
  
</feed>
