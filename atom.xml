<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Potato Online</title>
  
  <subtitle>Trust , But Verify !</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.kmahyyg.xyz/"/>
  <updated>2019-01-04T17:18:57.989Z</updated>
  <id>https://www.kmahyyg.xyz/</id>
  
  <author>
    <name>Patrick Young</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构与算法课程 - Chap 10 排序</title>
    <link href="https://www.kmahyyg.xyz/2019/ynu-datastru-c10/"/>
    <id>https://www.kmahyyg.xyz/2019/ynu-datastru-c10/</id>
    <published>2019-01-05T01:16:26.000Z</published>
    <updated>2019-01-04T17:18:57.989Z</updated>
    
    <content type="html"><![CDATA[<p>TODO</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;TODO&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="School" scheme="https://www.kmahyyg.xyz/tags/School/"/>
    
      <category term="Datastru" scheme="https://www.kmahyyg.xyz/tags/Datastru/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法课程 - Chap 9 查找</title>
    <link href="https://www.kmahyyg.xyz/2019/ynu-datastru-c9/"/>
    <id>https://www.kmahyyg.xyz/2019/ynu-datastru-c9/</id>
    <published>2019-01-05T01:16:19.000Z</published>
    <updated>2019-01-04T17:18:57.989Z</updated>
    
    <content type="html"><![CDATA[<p>TODO</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;TODO&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="School" scheme="https://www.kmahyyg.xyz/tags/School/"/>
    
      <category term="Datastru" scheme="https://www.kmahyyg.xyz/tags/Datastru/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法课程 - Chap 7 图</title>
    <link href="https://www.kmahyyg.xyz/2019/ynu-datastru-c7/"/>
    <id>https://www.kmahyyg.xyz/2019/ynu-datastru-c7/</id>
    <published>2019-01-05T01:16:11.000Z</published>
    <updated>2019-01-04T17:18:57.989Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构复习-Chapter-7-图"><a href="#数据结构复习-Chapter-7-图" class="headerlink" title="数据结构复习 - Chapter 7 图"></a>数据结构复习 - Chapter 7 图</h1><h2 id="图的相关概念"><a href="#图的相关概念" class="headerlink" title="图的相关概念"></a>图的相关概念</h2><p>图是由顶点集合和顶点间的关系集合构成的一种数据结构。</p><p>图的 ADT:</p><pre><code>ADT Graph {  数据对象V：    V是具有相同特性的数据元素的集合，称为顶点集。  数据关系R：    R={ VR }    VR={&lt;v,w&gt;|v,w∈V且P(v,w)，&lt;v,w&gt;表示从v到w的弧，谓词P(v,w)定义了弧&lt;v,w&gt;的意义或信息}  基本操作P：    CreateGraph(&amp;G,V,VR); // 按V和V R的定义构造图G    DestroyGraph(&amp;G);     // 销毁图G    LocateVex(G, u);  // 若G中存在顶点u，则返回该顶点在图中位置；    GetVex(G, v);         // 返回 v 的值    PutVex(&amp;G, v, value);   // 对 v 赋值value    FirstAdjVex(G, v);  // 返回v的第一个邻接点。否则，则返回“空”}ADT Graph</code></pre><p>图的术语：</p><ul><li>有向图 &amp; 无向图</li><li>完全图：图中任意两个顶点间都有一条边相连接，无向完全图的边数是 n(n-1)/2，有向完全图的边数是 n(n-1)</li><li>稠密图/稀疏图：边数的判定界限为 nlogn</li><li>网络：带权图，路径上带有权值，其中非带权图的路径长度是指此路径上边的条数，带权图的路径长度是指路径上的各边的权之和。</li><li>(非)简单路径：路径上的顶点不重复出现。</li></ul><p>关于连通图：</p><ul><li>连通图：（不一定直接连通）任意两顶点之间有路径可达，图中所有顶点均连通。</li><li>强连通图： 任意一对顶点存在正向路径也存在反向路径。</li><li>非（强）连通图的极大连通子图称为（强）连通分量。</li></ul><p>关于邻接：</p><ul><li>无向图：邻接、关联、依附于边：都是说边的两个顶点</li><li>有向图：从起点邻接到终点，终点邻接自起点，弧与顶点相关联</li></ul><p>关于度：</p><ul><li>度：无向图：和对应顶点关联的边的数目</li><li>出度：以 v 为终点的有向边数</li><li>入度：以 v 为起点的有向边数</li></ul><p>生成：</p><ul><li>生成树：极小连通子图，包含图的全部顶点，只能生成树的 n-1 条边，图中每个顶点间均存在路径。</li><li>生成森林： 有向图的一个顶点的入度为 0, 其他的顶点入度为 1, 则为有向树。生成森林包含若干个有向树</li></ul><h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><ol><li>无向图： <code>edge[i][j]</code> 表示 i 到 j 之间有弧或边。（具有对称性，完全图的邻接矩阵中，对角线为 0，其他均为 1。）</li><li>有向图： 第 i 行，表示出度边（尾）；第 j 列，表示入度边（头）。</li></ol><h3 id="邻接链表"><a href="#邻接链表" class="headerlink" title="邻接链表"></a>邻接链表</h3><ol><li>无向：<code>vertex | pointer</code> -&gt; <code>pointer</code> == <code>neighbor vertex | pointer</code></li><li>有向：<code>vertex | pointer</code> -&gt; <code>pointer</code> == <code>dest vertex | pointer</code>  (出边)<br><code>vertex | pointer</code> -&gt; <code>pointer</code> == <code>src vertex | pointer</code>  (入边)</li></ol><h2 id="图的遍历-aka-搜素"><a href="#图的遍历-aka-搜素" class="headerlink" title="图的遍历(aka. 搜素)"></a>图的遍历(aka. 搜素)</h2><p>遍历的定义：从某一顶点出发，遍历其余顶点，且每个顶点仅被访问一次。实质是寻找邻接点。<br>其实与二叉树三序遍历等价。</p><p>DFS：计算机实现需借用辅助的 <code>visited[]</code> ，整体思路是先沿指针访问，访问后置 visited = 1, 然后直到到达的所有邻接节点都被访问过，回退，直到所有图中节点均被实现。</p><p>BFS： <em>NON-RECURSIVE</em>  辅助存储： <code>visited[] &amp; Queue(Visited)</code> 。实现思路：从起点顺序访问，访问路径长度为 1 的节点，然后置节点为 visited = 1，并将该节点入队，当队列非空时，将队头元素出队，并置出队节点为当前节点，访问与出队节点距离为 1 的点并逐个入队，之后依次出队，将出队后的节点作为起始节点，重复上述过程。</p><h2 id="图的连通性"><a href="#图的连通性" class="headerlink" title="图的连通性"></a>图的连通性</h2><h3 id="Kruskal-算法"><a href="#Kruskal-算法" class="headerlink" title="Kruskal 算法"></a>Kruskal 算法</h3><ol><li>添加所有顶点</li><li>选择最小权重边，不产生回路，直至完全连通。</li></ol><h3 id="Prim-算法"><a href="#Prim-算法" class="headerlink" title="Prim 算法"></a>Prim 算法</h3><ol><li>选择起始顶点，建立 <code>founded[]</code></li><li>将初始的辅助数组中各项元素初始化为 0 ，辅助数组结构为：</li></ol><table><thead><tr><th style="text-align:center">Index</th><th style="text-align:center">AdjVertex</th><th style="text-align:center">LowCost</th></tr></thead><tbody><tr><td style="text-align:center">网中的节点v</td><td style="text-align:center">相邻点u</td><td style="text-align:center">u与v之间的边的权重</td></tr></tbody></table><p>其中第一次的网中节点为除了起点之外的其他节点。起始节点的 founded == 1。</p><ol start="3"><li>在对应的邻接矩阵的各点中找到最小权重的边。接下来以找到的最近的邻接点为起点，重复上述过程，直到所有节点的 founded == 1。 </li></ol><p>时间复杂度：O(n^2)</p><h2 id="有向无环图"><a href="#有向无环图" class="headerlink" title="有向无环图"></a>有向无环图</h2><h3 id="Activity-on-Vertices-AOV"><a href="#Activity-on-Vertices-AOV" class="headerlink" title="Activity on Vertices (AOV)"></a>Activity on Vertices (AOV)</h3><p>顶点表示活动，弧的起点和终点表示终点的活动必须先于起点进行。</p><h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><p>目的：用于判断是否存在有向环</p><p>本质：重复选择没有直接前驱的结点</p><p>方法：</p><ul><li>输入 AOV 网。</li><li>在 AOV 中选择没有直接前驱的点并输出，删除该顶点和发出的所有有向边。</li><li>重复，直至全部节点均被输出或跳出循环</li></ul><p>若剩余有节点未被输出，则必然存在有向环。该排序方法为不稳定排序，结果不唯一。</p><h3 id="Activity-on-Edges-AOE"><a href="#Activity-on-Edges-AOE" class="headerlink" title="Activity on Edges (AOE)"></a>Activity on Edges (AOE)</h3><p>顶点表示事件(Event)，有向边表示活动(Activity)，边上权值表示活动持续时间(Duration)。</p><p>入度为 0, 为 SRC，源点（开始点）；出度为 0, 为 DEST， 汇点（终点）。</p><p>Event 节点表示在 该节点之前所有活动已经完成，在它之后的活动可以开始。每边的起点为开始事件，终点为结束事件，可以看作进度条。</p><h4 id="事件之最"><a href="#事件之最" class="headerlink" title="事件之最"></a>事件之最</h4><p>事件的 最早开始时间： 最长路径<br>事件的 最晚开始时间： 最长路径 - 出边的权值（结果取最小）</p><h4 id="活动之最"><a href="#活动之最" class="headerlink" title="活动之最"></a>活动之最</h4><p>活动的 最早开始时间： 起始事件 的 最早开始时间<br>活动的 最迟开始时间（最长拖延时间）： 末尾事件的最晚开始时间 - 出边的权值</p><h4 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h4><p><strong>活动</strong> 的 <strong>最早开始时间 == 最迟开始时间</strong> 的路径</p><h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><p><a href="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/dijkstra.html" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/easy-learn-algorithm/dijkstra.html</a></p><p><a href="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/floyd.html" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/easy-learn-algorithm/floyd.html</a></p><h3 id="Floyd-Warshall-非负图的多源最短路径"><a href="#Floyd-Warshall-非负图的多源最短路径" class="headerlink" title="Floyd-Warshall 非负图的多源最短路径"></a>Floyd-Warshall 非负图的多源最短路径</h3><p>时间复杂度：O(n^3)</p><ol><li>数组第 0 维，存储初始数据。 <code>[i][j]</code> 表示从 i 到 j 的 最短路径长度。最短路径经过的点使用链表方式，保存在另一个数组中。</li><li>只允许经过一个特定的顶点 k 中转，重复上述过程。 从 i 到 j 只需判断 <code>[i][k] + [k][j] ?? [i][j]</code> 即可。</li><li>推广到允许经过所有顶点中转。基本思想就是：最开始只允许经过 1 号顶点进行中转，接下来只允许经过 1 和 2 号顶点进行中转……允许经过 1~n 号所有顶点进行中转，求任意两点之间的最短路程。用一句话概括就是：从 i 号顶点到 j 号顶点只经过前k号点的最短路程。</li></ol><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> e<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> n<span class="token punctuation">,</span> m<span class="token punctuation">,</span> t1<span class="token punctuation">,</span> t2<span class="token punctuation">,</span> t3<span class="token punctuation">;</span>    <span class="token keyword">int</span> inf <span class="token operator">=</span> <span class="token number">99999999</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//用inf(infinity的缩写)存储一个我们认为的正无穷值</span>    <span class="token comment" spellcheck="true">//读入n和m，n表示顶点个数，m表示边的条数</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d %d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//初始化</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> j<span class="token punctuation">)</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> inf<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//读入边</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d %d %d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>t1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t2<span class="token punctuation">,</span> <span class="token operator">&amp;</span>t3<span class="token punctuation">)</span><span class="token punctuation">;</span>        e<span class="token punctuation">[</span>t1<span class="token punctuation">]</span><span class="token punctuation">[</span>t2<span class="token punctuation">]</span> <span class="token operator">=</span> t3<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//Floyd-Warshall算法核心语句</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> e<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                    e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> e<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//输出最终的结果</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%10d"</span><span class="token punctuation">,</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Dijkstra-非负图的单源最短路径"><a href="#Dijkstra-非负图的单源最短路径" class="headerlink" title="Dijkstra 非负图的单源最短路径"></a>Dijkstra 非负图的单源最短路径</h3><p>时间复杂度：O(n^2)</p><blockquote><p>Talk is cheap, show me the code.  —- Linus Torvalds</p></blockquote><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!/usr/bin/env python3</span><span class="token comment" spellcheck="true"># -*- encoding:utf-8 -*-</span><span class="token comment" spellcheck="true"># http://wiki.jikexueyuan.com/project/easy-learn-algorithm/dijkstra.html</span><span class="token comment" spellcheck="true"># https://blog.csdn.net/qq_35644234/article/details/60870719</span><span class="token comment" spellcheck="true"># https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/</span><span class="token keyword">from</span> sys <span class="token keyword">import</span> maxsize <span class="token keyword">as</span> maxintgraph <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true"># 0A, and no-route should be zero.</span>    <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true"># 1B</span>    <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true"># 2C</span>    <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true"># 3D</span>    <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true"># 4E</span>    <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 5F</span><span class="token punctuation">]</span><span class="token keyword">global</span> distsrc <span class="token operator">=</span> int<span class="token punctuation">(</span><span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token string">"Input Source: "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># start from source</span>vtx <span class="token operator">=</span> <span class="token number">6</span>  <span class="token comment" spellcheck="true"># total vertexes</span>dist <span class="token operator">=</span> <span class="token punctuation">[</span>maxint <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>vtx<span class="token punctuation">)</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># distance should be max at initial</span>foundset <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># if shortest path found, append to here</span>prev <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> vtx  <span class="token comment" spellcheck="true"># initate all front-driven == -1, if still -1, non-accessable</span><span class="token keyword">def</span> <span class="token function">str2Path</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">:</span>    path <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    n <span class="token operator">=</span> node    <span class="token keyword">while</span> n <span class="token operator">!=</span> src<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># insert a dest-node at front of the list, and insert its front-driven at the first</span>        path<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span>        n <span class="token operator">=</span> prev<span class="token punctuation">[</span>n<span class="token punctuation">]</span>    path<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> src<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># finally, insert src at the list.</span>    <span class="token keyword">return</span> <span class="token string">'->'</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>str<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># return built result string</span><span class="token keyword">def</span> <span class="token function">printsol</span><span class="token punctuation">(</span>dist<span class="token punctuation">,</span> vtx<span class="token punctuation">,</span> src<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Source:"</span><span class="token punctuation">,</span> src<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\t Destination \t Length \t Shortest Path"</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>vtx<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">" \t\t"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token string">"   \t\t  "</span><span class="token punctuation">,</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">" \t\t  "</span><span class="token punctuation">,</span> str2Path<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">mind</span><span class="token punctuation">(</span>dist<span class="token punctuation">,</span> foundset<span class="token punctuation">,</span> vtx<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">from</span> sys <span class="token keyword">import</span> maxsize <span class="token keyword">as</span> maxint    min_idx <span class="token operator">=</span> maxint    min_dist <span class="token operator">=</span> maxint    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>vtx<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> i <span class="token keyword">in</span> foundset<span class="token punctuation">:</span>            <span class="token keyword">continue</span>        <span class="token keyword">if</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> min_dist<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># find the minimal distance in not found vertexes</span>            min_dist <span class="token operator">=</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            min_idx <span class="token operator">=</span> i    <span class="token keyword">return</span> min_idx<span class="token keyword">def</span> <span class="token function">dj</span><span class="token punctuation">(</span>dist<span class="token punctuation">,</span> foundset<span class="token punctuation">,</span> graph<span class="token punctuation">,</span> vtx<span class="token punctuation">,</span> src<span class="token punctuation">)</span><span class="token punctuation">:</span>    dist<span class="token punctuation">[</span>src<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>vtx<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> graph<span class="token punctuation">[</span>src<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>            prev<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> src  <span class="token comment" spellcheck="true"># if have route src->i, initate all front-driven with source</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>vtx<span class="token punctuation">)</span><span class="token punctuation">:</span>        u <span class="token operator">=</span> mind<span class="token punctuation">(</span>dist<span class="token punctuation">,</span> foundset<span class="token punctuation">,</span> vtx<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># find the nearest neighbor</span>        foundset<span class="token punctuation">.</span>append<span class="token punctuation">(</span>u<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># set found</span>        <span class="token keyword">for</span> node <span class="token keyword">in</span> range<span class="token punctuation">(</span>vtx<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># for all destination</span>            <span class="token keyword">if</span> <span class="token operator">not</span> node <span class="token keyword">in</span> foundset<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># if that the shortest way to  destination have not found</span>                <span class="token keyword">if</span> graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>node<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># and have a way to destination</span>                    <span class="token keyword">if</span> dist<span class="token punctuation">[</span>node<span class="token punctuation">]</span> <span class="token operator">></span> dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">:</span>                        dist<span class="token punctuation">[</span>node<span class="token punctuation">]</span> <span class="token operator">=</span> dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>node<span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># update the shortest way with relay included</span>                        prev<span class="token punctuation">[</span>node<span class="token punctuation">]</span> <span class="token operator">=</span> u  <span class="token comment" spellcheck="true"># if have shorter path, then modify its front-driven with relay vertex</span>    printsol<span class="token punctuation">(</span>dist<span class="token punctuation">,</span> vtx<span class="token punctuation">,</span> src<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># print solution and shortest path length</span>dj<span class="token punctuation">(</span>dist<span class="token punctuation">,</span> foundset<span class="token punctuation">,</span> graph<span class="token punctuation">,</span> vtx<span class="token punctuation">,</span> src<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据结构复习-Chapter-7-图&quot;&gt;&lt;a href=&quot;#数据结构复习-Chapter-7-图&quot; class=&quot;headerlink&quot; title=&quot;数据结构复习 - Chapter 7 图&quot;&gt;&lt;/a&gt;数据结构复习 - Chapter 7 图&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
    
      <category term="School" scheme="https://www.kmahyyg.xyz/tags/School/"/>
    
      <category term="Datastru" scheme="https://www.kmahyyg.xyz/tags/Datastru/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法课程 - Chap 6 树和二叉树</title>
    <link href="https://www.kmahyyg.xyz/2019/ynu-datastru-c6/"/>
    <id>https://www.kmahyyg.xyz/2019/ynu-datastru-c6/</id>
    <published>2019-01-05T01:16:05.000Z</published>
    <updated>2019-01-04T17:18:57.989Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构复习-Chapter-6-树和二叉树"><a href="#数据结构复习-Chapter-6-树和二叉树" class="headerlink" title="数据结构复习 - Chapter 6 树和二叉树"></a>数据结构复习 - Chapter 6 树和二叉树</h1><h2 id="树的相关概念"><a href="#树的相关概念" class="headerlink" title="树的相关概念"></a>树的相关概念</h2><p>树定义： </p><ol><li>有限集合</li><li>子集为互不相交的有限集</li></ol><p>树表示：</p><ul><li>图形、嵌套集合（Venn 图）、目录表示法</li><li>广义表表示法：根作为由子树森林组成的表的名字写在表的左边<blockquote><p>(A(B(E(K,L),F),C(G),D(H(M),I,J))) </p></blockquote></li><li>左孩子、右兄弟表示</li></ul><p>节点定义：</p><ul><li>根节点：没有前驱</li><li>叶子节点：没有后继（度 == 0）</li><li>森林：指 m 棵不相交的树的集合</li><li>有序树：各子树从左至右有序，不可互换</li><li>节点的度： 节点挂接的子树的数目</li><li>节点的层次：从根（01 层）到该节点的层数</li><li>树的度： Max({各节点的度})</li><li>树的深度： Max({各节点的层次})</li></ul><h2 id="树的存储"><a href="#树的存储" class="headerlink" title="树的存储"></a>树的存储</h2><ul><li>顺序存储：从上至下，从左至右，无法复原、没有实用价值。</li><li><p>链式存储：一个前驱、n 个后继，过于浪费存储空间、结构和定义的数据类型过于复杂。</p></li><li><p>双亲表示：数组存储，根节点的 index 为 0,双亲 为 -1； 其他节点的双亲为 对应双亲的数组下标。</p></li><li>孩子表示：双亲存于数组，每个对应元素的指针域指向孩子，孩子与孩子间通过指针相连，没孩子则为 NULL。</li><li>带双亲的孩子表示法：数组的双亲节点可能同时是另一个节点的孩子，增加一个数据域存储双亲对应的数组下标。</li><li>孩子兄弟表示发： <code>firstchild | data | nextsibling</code>，左存储孩子，右存储兄弟，中间为数据。</li></ul><h2 id="重点：树到二叉树的转换"><a href="#重点：树到二叉树的转换" class="headerlink" title="重点：树到二叉树的转换"></a>重点：<strong>树到二叉树的转换</strong></h2><ol><li>对每个孩子进行从左到右的排序；</li><li>在兄弟之间加一条连线；</li><li>对每个结点，除了左孩子外，去除其与其余孩子之间的联系；</li><li>以根结点为轴心，将整个树顺时针转45°。</li></ol><h2 id="次重点：-森林到二叉树的转换"><a href="#次重点：-森林到二叉树的转换" class="headerlink" title="次重点： 森林到二叉树的转换"></a>次重点： <strong>森林到二叉树的转换</strong></h2><p>兄弟相连 长兄为父 孩子靠左 头根为根</p><h2 id="次重点：-二叉树到森林的转换"><a href="#次重点：-二叉树到森林的转换" class="headerlink" title="次重点： 二叉树到森林的转换"></a>次重点： <strong>二叉树到森林的转换</strong></h2><p>把最右边的子树变为森林，其余右子树变为兄弟</p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>所有树都能转为唯一对应的二叉树。 <strong>是一种有序树</strong></p><p>满二叉树：深度为 k 且含有 2k-1 个结点的二叉树。</p><p>完全二叉树：树中所含的 n 个结点和满二叉树中编号为 1 至 n 的结点一一对应。上面的要满，左边的要满，只有最右边 1 个不满或空。具有 n 个结点的完全二叉树的高度为 <code>[log2n] + 1</code> 。</p><h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><ul><li>数组，BFS 遍历，顺序存储，但无法唯一复原</li><li>二叉链表： <code>lchild | data | rchild</code></li><li>三叉链表： <code>lchild | data | parent | rchild</code></li></ul><h3 id="重点：二叉树的遍历与重建"><a href="#重点：二叉树的遍历与重建" class="headerlink" title="重点：二叉树的遍历与重建"></a><strong>重点：二叉树的遍历与重建</strong></h3><p>对于森林的遍历，从左到右依次对每棵树进行遍历即可。</p><h4 id="DFS-深度优先"><a href="#DFS-深度优先" class="headerlink" title="DFS 深度优先"></a>DFS 深度优先</h4><p>3.1.1 先根次序遍历</p><p>先根次序遍历按照“根结点-左孩子-右孩子”的顺序进行访问。</p><p>（1）递归实现</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//先根递归遍历</span><span class="token keyword">void</span> <span class="token function">preOrderRecursion</span><span class="token punctuation">(</span>BinaryTreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>root<span class="token operator">-</span><span class="token operator">></span>m_key<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//visit</span>    <span class="token function">preOrderRecursion</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>m_pLeft<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">preOrderRecursion</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>m_pRight<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）非递归实现 </p><p>根据前序遍历访问的顺序，优先访问根结点，然后再分别访问左孩子和右孩子。即对于任一结点，其可看做是根结点，因此可以直接访问，访问完之后，若其左孩子不为空，按相同规则访问它的左子树；当访问完左子树时，再访问它的右子树。因此其处理过程如下：</p><p>给定二叉树的根节点R： </p><p>(a)并将根节点R入栈；</p><p>(b)判断栈是否为空，若不为空，取栈顶元素cur访问并出栈。然后先将cur的右子节点入栈，再将cur的左子节点入栈；</p><p>(c)重复(b)直到栈为空，则遍历结束。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//先根非递归遍历，需要使用栈</span><span class="token keyword">void</span> <span class="token function">preOrderStack</span><span class="token punctuation">(</span>BinaryTreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>     stack<span class="token operator">&lt;</span>BinaryTreeNode<span class="token operator">*</span><span class="token operator">></span> stack<span class="token punctuation">;</span>    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    BinaryTreeNode<span class="token operator">*</span> cur<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cur<span class="token operator">=</span>stack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cout<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>cur<span class="token operator">-</span><span class="token operator">></span>m_key<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//visit</span>        stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">-</span><span class="token operator">></span>m_pRight<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token operator">-</span><span class="token operator">></span>m_pRight<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">-</span><span class="token operator">></span>m_pLeft<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token operator">-</span><span class="token operator">></span>m_pLeft<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.1.2中根次序遍历</p><p>中序遍历按照“左孩子-根结点-右孩子”的顺序进行访问。 </p><p> （1）递归实现</p><pre><code>//中根递归遍历void midOrderRecursion(BinaryTreeNode* root){    if(root==NULL)        return;    midOrderRecursion(root-&gt;m_pLeft);    cout&lt;&lt;&quot; &quot;&lt;&lt;root-&gt;m_key;   //visit    midOrderRecursion(root-&gt;m_pRight);}</code></pre><p>（2）非递归实现 </p><p>根据中序遍历的顺序，对于任一结点，先访问其左孩子，而左孩子结点又可以看做一根结点，然后继续访问其左孩子结点，直到遇到左孩子结点为空的结点才进行访问，然后按相同的规则访问其右子树。因此其处理过程如下：</p><p>对于给定的二叉树根节点R， </p><p> (a)若其左孩子不为空，循环将R以及R左子树中的所有节点的左孩子入栈； </p><p> (b)取栈顶元素cur，访问cur并将cur出栈。然后对cur的右子节点进行步骤（a）那样的处理； </p><p> (c)重复（a）和（b）的操作，直到cur为空切栈为空。</p><pre><code>//中根非递归遍历，需要使用栈void midOrderStack(BinaryTreeNode* root){    if(root==NULL)        return;     stack&lt;BinaryTreeNode*&gt; stack;    BinaryTreeNode* cur=root;    while(!stack.empty()||cur!=NULL){          while(cur){              stack.push(cur);              cur=cur-&gt;m_pLeft;          }          cur=stack.top();          cout&lt;&lt;&quot; &quot;&lt;&lt;cur-&gt;m_key;   //visit        stack.pop();          cur=cur-&gt;m_pRight;      }              }</code></pre><p>3.1.3后根次序遍历</p><p>后序遍历按照“左孩子-右孩子-根结点”的顺序进行访问。 </p><p> （1）递归实现</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//后根递归遍历</span><span class="token keyword">void</span> <span class="token function">postOrderRecursion</span><span class="token punctuation">(</span>BinaryTreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token function">postOrderRecursion</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>m_pLeft<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">postOrderRecursion</span><span class="token punctuation">(</span>root<span class="token operator">-</span><span class="token operator">></span>m_pRight<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>root<span class="token operator">-</span><span class="token operator">></span>m_key<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//visit</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）非递归实现 </p><p>后序遍历的非递归实现是三种遍历方式中最难的一种。因为在后序遍历中，要保证左孩子和右孩子都已被访问并且左孩子要在右孩子前被访问，才能访问根节点。这就为流程的控制带来了难题。</p><p>对于任一结点P，将其入栈，然后沿其左子树一直往下搜索，直到搜索到没有左孩子的结点，此时该结点出现在栈顶，但是此时不能将其出栈并访问，因此其右孩子还为被访问。所以接下来按照相同的规则对其右子树进行相同的处理，当访问完其右孩子时，该结点又出现在栈顶，此时可以将其出栈并访问。这样就保证了正确的访问顺序。可以看出，在这个过程中，每个结点都两次出现在栈顶，只有在第二次出现在栈顶时，才能访问它。因此需要多设置一个变量标识该结点是否是第一次出现在栈顶。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//非递归后序遍历，版本1</span><span class="token keyword">void</span> <span class="token function">postOrderStack1</span><span class="token punctuation">(</span>BinaryTreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>     stack<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span>BinaryTreeNode<span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token operator">></span> s<span class="token punctuation">;</span>    pair<span class="token operator">&lt;</span>BinaryTreeNode<span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">bool</span><span class="token operator">></span> cur<span class="token operator">=</span><span class="token function">make_pair</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>first<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token operator">||</span><span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>first<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token comment" spellcheck="true">//沿左子树一直往下搜索，直至出现没有左子树的结点 </span>            s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>            cur<span class="token operator">=</span><span class="token function">make_pair</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>first<span class="token operator">-</span><span class="token operator">></span>m_pLeft<span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token operator">==</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//表示是第一次出现在栈顶 </span>                s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span>                cur<span class="token operator">=</span><span class="token function">make_pair</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token operator">-</span><span class="token operator">></span>m_pRight<span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将当前节点的右节点入栈</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">//第二次出现在栈顶 </span>                cout<span class="token operator">&lt;&lt;</span>s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token operator">-</span><span class="token operator">></span>m_key<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>                s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="BFS-深度优先"><a href="#BFS-深度优先" class="headerlink" title="BFS 深度优先"></a>BFS 深度优先</h4><p>广度优先周游的方式是按层次从上到下，从左到右的逐层访问，不难想到，可以利用一个队列来实现。基本思想是：<br> （1）首先把二叉树的根节点送入队列；<br> （2）队首的节点出队列并访问之，然后把它的右子节点和左子节点分别入队列；<br> （3）重复上面两步操作，直至队空。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//广度优先遍历二叉树，使用队列实现</span><span class="token keyword">void</span> <span class="token function">breadthFirstOrder</span><span class="token punctuation">(</span>BinaryTreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    queue<span class="token operator">&lt;</span>BinaryTreeNode<span class="token operator">*</span><span class="token operator">></span> queue<span class="token punctuation">;</span>    queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        BinaryTreeNode<span class="token operator">*</span> cur<span class="token operator">=</span>queue<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cout<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token operator">&lt;&lt;</span>cur<span class="token operator">-</span><span class="token operator">></span>m_key<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//visit</span>        queue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">-</span><span class="token operator">></span>m_pLeft<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span>            queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token operator">-</span><span class="token operator">></span>m_pLeft<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token operator">-</span><span class="token operator">></span>m_pRight<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span>            queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token operator">-</span><span class="token operator">></span>m_pRight<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="先序-中序-重建"><a href="#先序-中序-重建" class="headerlink" title="先序+中序 重建"></a>先序+中序 重建</h4><p>构建过程：<br> （1）前序遍历序列中的第一个数字为根节点，构造根节点；<br> （2）找到根节点在中序遍历序列中的位置，中序中根节点左右两边分别为左子树和有子树，前序序列根节点后面为左子树+右子树；<br> （3）递归处理处理左右子树，返回根节点，完成构造。</p><p>由于在中序遍历中，有三个左子树节点的值，因此在前序遍历的序列中，根节点后面的3个数字就是3个左子树节点的值，再后面的所有数字都是右子树节点的值。这样子我们就在前序序列和中序序列中找到了左右子书对应的子序列，然后再递归处理即可。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//二叉树节点结构体</span><span class="token keyword">struct</span> BinaryTreeNode<span class="token punctuation">{</span>    <span class="token keyword">int</span> m_key<span class="token punctuation">;</span>    BinaryTreeNode<span class="token operator">*</span> m_pLeft<span class="token punctuation">;</span>    BinaryTreeNode<span class="token operator">*</span> m_pRight<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/****************************************func:根据前序序列和中序序列构建二叉树para:preOrder:前序序列;midOrder:中序序列;len:节点数****************************************/</span>BinaryTreeNode<span class="token operator">*</span> <span class="token function">construct</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> preOrder<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">*</span> midOrder<span class="token punctuation">,</span><span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>preOrder<span class="token operator">==</span><span class="token constant">NULL</span><span class="token operator">||</span>midOrder<span class="token operator">==</span><span class="token constant">NULL</span><span class="token operator">||</span>len<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//先根遍历（前序遍历）的第一个值就是根节点的键值</span>    <span class="token keyword">int</span> rootKey<span class="token operator">=</span>preOrder<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    BinaryTreeNode<span class="token operator">*</span> root<span class="token operator">=</span><span class="token keyword">new</span> BinaryTreeNode<span class="token punctuation">;</span>    root<span class="token operator">-</span><span class="token operator">></span>m_key<span class="token operator">=</span>rootKey<span class="token punctuation">;</span>    root<span class="token operator">-</span><span class="token operator">></span>m_pLeft<span class="token operator">=</span>root<span class="token operator">-</span><span class="token operator">></span>m_pRight<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>len<span class="token operator">==</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>preOrder<span class="token operator">==</span><span class="token operator">*</span>midOrder<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//只有一个节点</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//在中根遍历（中序遍历）中找到根节点的值</span>    <span class="token keyword">int</span><span class="token operator">*</span> rootMidOrder<span class="token operator">=</span>midOrder<span class="token punctuation">;</span>    <span class="token keyword">int</span> leftLen<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//左子树节点数</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">*</span>rootMidOrder<span class="token operator">!=</span>rootKey<span class="token operator">&amp;&amp;</span>rootMidOrder<span class="token operator">&lt;=</span><span class="token punctuation">(</span>midOrder<span class="token operator">+</span>len<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token operator">++</span>rootMidOrder<span class="token punctuation">;</span>        <span class="token operator">++</span>leftLen<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">*</span>rootMidOrder<span class="token operator">!=</span>rootKey<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//在中根序列未找到根节点,输入错误</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>leftLen<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//构建左子树</span>        root<span class="token operator">-</span><span class="token operator">></span>m_pLeft<span class="token operator">=</span><span class="token function">construct</span><span class="token punctuation">(</span>preOrder<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>midOrder<span class="token punctuation">,</span>leftLen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>len<span class="token operator">-</span>leftLen<span class="token number">-1</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//构建右子树</span>        root<span class="token operator">-</span><span class="token operator">></span>m_pRight<span class="token operator">=</span><span class="token function">construct</span><span class="token punctuation">(</span>preOrder<span class="token operator">+</span>leftLen<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>rootMidOrder<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>len<span class="token operator">-</span>leftLen<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> root<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p><strong>遍历的实质是对非线性结构的二叉树进行线性化处理</strong></p><p>存储结构： <code>lchild | ltag | data | rtag | rchild</code></p><p> Tag == 0, 正常指向孩子；Tag == 1, lchild 指向前驱，rchild 指向后继。(前驱和后继由遍历获得)</p><p>为解决悬空，在线索链表中添加了一个“头结点”，头结点的左指针指向二叉树的根结点，其右线索指向遍历序列中的最后一个结点，即头结点的 LTag =0; RTag = 1。遍历序列中第一个结点的 lchild 域和最后一个结点的 rchild 域都指向头结点。（没有头节点，则最后一个左孩子的 lchild 和 最后一个右孩子的 rchild 为 NULL 指针，悬空状态。 <strong>实现过程注意检测是否为叶子节点即可</strong> ）</p><h3 id="非常重要：-Huffman-Tree"><a href="#非常重要：-Huffman-Tree" class="headerlink" title="非常重要： Huffman Tree"></a>非常重要： <strong>Huffman Tree</strong></h3><p>这是最优二叉树，带权路径最短。</p><ul><li>树的带权路径长度：树中所有叶子结点的带权路径长度之和。</li><li>结点带权路径长度 WPL(Weighted Path Length)：结点到根的路径长度与结点上权的乘积。</li><li>路径长度：路径上的分支数目。</li><li>树的路径长度：从树根到每一结点的路径长度之和。</li></ul><p>Huffman 编码：利用 Huffman 树可以构造一种不等长的二进制编码，并且构造所得的 Huffman 编码是一种最优前缀编码，即：需要传输的电文的总长度最短。任何一个字符的编码都不是同一字符集中另一个字符的编码的前缀。”左 0 右 1”</p><p><img src="https://yygc.zzjnyyz.cn/asset_files/Huffman_tree_2.svg" alt="huffman_tree"></p><p><strong>权重最低的为叶子节点，叶子节点的双亲节点为孩子的权重之和，依此类推，根节点的孩子节点的权重最高，对应单字符的权重最高、使用频率最高、电文最短。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据结构复习-Chapter-6-树和二叉树&quot;&gt;&lt;a href=&quot;#数据结构复习-Chapter-6-树和二叉树&quot; class=&quot;headerlink&quot; title=&quot;数据结构复习 - Chapter 6 树和二叉树&quot;&gt;&lt;/a&gt;数据结构复习 - Chapter 6
      
    
    </summary>
    
    
      <category term="School" scheme="https://www.kmahyyg.xyz/tags/School/"/>
    
      <category term="Datastru" scheme="https://www.kmahyyg.xyz/tags/Datastru/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法课程 - Chap 5 数组和广义表</title>
    <link href="https://www.kmahyyg.xyz/2019/ynu-datastru-c5/"/>
    <id>https://www.kmahyyg.xyz/2019/ynu-datastru-c5/</id>
    <published>2019-01-05T01:15:56.000Z</published>
    <updated>2019-01-04T17:18:57.989Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构复习-Chapter-5-数组和广义表"><a href="#数据结构复习-Chapter-5-数组和广义表" class="headerlink" title="数据结构复习 - Chapter 5 数组和广义表"></a>数据结构复习 - Chapter 5 数组和广义表</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>高级语言中的数组一定是顺序结构，元素的值并非原子类型，可以再分解。 <strong>广义的线性表包括线性表元素组成的线性表</strong></p><p><strong>这里的数组中的每一维度的元素长度是不相同的。</strong></p><h3 id="数组的顺序保存结构的地址计算"><a href="#数组的顺序保存结构的地址计算" class="headerlink" title="数组的顺序保存结构的地址计算"></a>数组的顺序保存结构的地址计算</h3><ol><li>多维数组的元素存储反复故事： 行优先/列优先。</li><li>数组寻址格式： 起始位置 + 数组 A 前面保存的元素 × 元素的长度。</li><li>画图！画图啊！</li></ol><h3 id="广义的数组顺序表示"><a href="#广义的数组顺序表示" class="headerlink" title="广义的数组顺序表示"></a>广义的数组顺序表示</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property">#<span class="token directive keyword">define</span> MAX_ARRAY_DIM 8</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>    ElemType <span class="token operator">*</span>baseaddr<span class="token punctuation">;</span>    <span class="token keyword">int</span> dim<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>bounds<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>constants<span class="token punctuation">;</span><span class="token punctuation">}</span>Array<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Baseaddr: 存储数组的内存空间的基地址<br>Dim: 数组的最高维度<br>Bounds： 存储每一维数组长度的内存空间的基地址<br>Constants： 存放各数据的内存空间的基地址</p><h3 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h3><h4 id="可变长参数列表-stdarg-h"><a href="#可变长参数列表-stdarg-h" class="headerlink" title="可变长参数列表 stdarg.h"></a>可变长参数列表 stdarg.h</h4><p><a href="https://www.kmahyyg.xyz/2018/DS04-Maze-EXP/#stdarg-h-%E5%9C%A8-C-%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8">https://www.kmahyyg.xyz/2018/DS04-Maze-EXP/#stdarg-h-%E5%9C%A8-C-%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8</a></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdarg.h></span></span><span class="token keyword">int</span> <span class="token function">echoinfo</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>strNotice<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> noti<span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">strcpy</span><span class="token punctuation">(</span>noti<span class="token punctuation">,</span><span class="token string">"The printout is"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">echoinfo</span><span class="token punctuation">(</span>noti<span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">echoinfo</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>strNotice<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span>str0 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>str1 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>str2 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    va_list stArgv<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// define a param list</span>    <span class="token function">va_start</span><span class="token punctuation">(</span>stArgv<span class="token punctuation">,</span> strNotice<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// pass the fixed param to the function</span>    str0 <span class="token operator">=</span> <span class="token function">va_arg</span><span class="token punctuation">(</span>stArgv<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    str1 <span class="token operator">=</span> <span class="token function">va_arg</span><span class="token punctuation">(</span>stArgv<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    str2 <span class="token operator">=</span> <span class="token function">va_arg</span><span class="token punctuation">(</span>stArgv<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s: %s %s %s"</span><span class="token punctuation">,</span> strNotice<span class="token punctuation">,</span> str0<span class="token punctuation">,</span> str1<span class="token punctuation">,</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">va_end</span><span class="token punctuation">(</span>stArgv<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="矩阵的压缩存储"><a href="#矩阵的压缩存储" class="headerlink" title="矩阵的压缩存储"></a>矩阵的压缩存储</h4><ul><li>为多值相同的元素只分配一个存储空间</li><li>对 0 元素不分配存储空间</li><li>值相同或 0 元素在矩阵中的分布有一定规律，则称其为特殊矩阵，否则称之为稀疏矩阵。（也就是说正常的矩阵应当是稀疏的）</li><li>保存格式 &lt;行，列，值&gt;</li></ul><h2 id="特殊矩阵"><a href="#特殊矩阵" class="headerlink" title="特殊矩阵"></a>特殊矩阵</h2><h3 id="三角矩阵"><a href="#三角矩阵" class="headerlink" title="三角矩阵"></a>三角矩阵</h3><p>数组保存的下标：</p><ul><li>上三角：[列*(列-1)]/2+行</li><li>下三角：[行*(行-1)]/2+列</li></ul><h4 id="重点：矩阵的转置"><a href="#重点：矩阵的转置" class="headerlink" title="重点：矩阵的转置"></a>重点：矩阵的转置</h4><p>快速转置算法： </p><p>每一列第一个非零元素保存个数位置 = 上一列第一个非零元素保存位置 + 上一列非零元素。</p><p>num 数组 存储 M 中 第 col 列中非 0 元素个数<br>cpot 数组 存储 M 中 第 col 列的非 0 元素在 T.data 中的保存位置。</p><p>把转置后的位置放到 cpot 数组对应的位置，然后 cpot++;</p><h4 id="稀疏矩阵的乘法"><a href="#稀疏矩阵的乘法" class="headerlink" title="稀疏矩阵的乘法"></a>稀疏矩阵的乘法</h4><p>矩阵乘法 = <strong>M 矩阵该行所有元素对应与 N 矩阵该列所有元素分别相乘之和</strong></p><h4 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h4><p>[所在行，所在列，非零元素，向右域，向下域]</p><h2 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h2><p>表头 = 头元素，第一个元素<br>表尾 = <strong>后面的所有元素，表尾必须是一个广义表</strong></p><p>广义表特点：有次序性、有长度、有深度、可以递归定义、可以共享。<br>广义表的长度：最外层括号的元素个数<br>广义表的深度：括号层数（有多少括号匹配）</p><p>数据保存时，需要添加 tag 标志域，区分表节点与数据 (Atom) 节点。</p><p>[tag=0,data=atom]<br>[tag=1,headptr=head,endptr=tail]</p><p>headptr 永远指向表或者表元素，也是唯一一个可以直接指向 atom 元素的指针。</p><p>广义表中的数据元素有数据的相对次序，一个直接前驱、一个直接后继。</p><p>广义表的 ADT 表示，借此复习 ADT 的表示方法：</p><pre class="line-numbers language-cpp"><code class="language-cpp">ADT Glist <span class="token punctuation">{</span>    数据对象：    D＝<span class="token punctuation">{</span>ei <span class="token operator">|</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span>n<span class="token punctuation">;</span> n≥<span class="token number">0</span><span class="token punctuation">;</span> ei∈AtomSet或ei∈Glist<span class="token punctuation">}</span>    数据关系：    LR＝<span class="token punctuation">{</span><span class="token operator">&lt;</span>ei<span class="token number">-1</span><span class="token punctuation">,</span> ei<span class="token operator">></span><span class="token operator">|</span> ei<span class="token number">-1</span> <span class="token punctuation">,</span>ei ∈D<span class="token punctuation">,</span>  <span class="token number">2</span>≤i≤n <span class="token punctuation">}</span>    基本操作：    <span class="token function">InitGList</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//创建空的广义表L。</span>    <span class="token function">DestroyGList</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>L<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//销毁广义表L。</span>    <span class="token function">CreateGList</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>L<span class="token punctuation">,</span> S<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">//由串S创建广义表L。</span>    <span class="token function">CopyGList</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>T<span class="token punctuation">,</span> L<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 由广义表L复制得到广义表T。</span>    <span class="token function">GListLength</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">GListDepth</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">GListEmpty</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 判深、判空、判长</span>    <span class="token function">GetHead</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//取表头 (可能是原子或列表);</span>    <span class="token function">GetTail</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//取表尾 (一定是列表) </span>    <span class="token function">InsertFirst_GL</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>L<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//插入元素e作为广义表L的第一元素。</span>    <span class="token function">DeleteFirst_GL</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>L<span class="token punctuation">,</span> <span class="token operator">&amp;</span>e<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//删除广义表L的第一元素，并用e返回其值。</span><span class="token punctuation">}</span>ADT Glist<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据结构复习-Chapter-5-数组和广义表&quot;&gt;&lt;a href=&quot;#数据结构复习-Chapter-5-数组和广义表&quot; class=&quot;headerlink&quot; title=&quot;数据结构复习 - Chapter 5 数组和广义表&quot;&gt;&lt;/a&gt;数据结构复习 - Chapte
      
    
    </summary>
    
    
      <category term="School" scheme="https://www.kmahyyg.xyz/tags/School/"/>
    
      <category term="Datastru" scheme="https://www.kmahyyg.xyz/tags/Datastru/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法课程 - Chap 4 串</title>
    <link href="https://www.kmahyyg.xyz/2019/ynu-datastru-c4/"/>
    <id>https://www.kmahyyg.xyz/2019/ynu-datastru-c4/</id>
    <published>2019-01-05T01:15:48.000Z</published>
    <updated>2019-01-04T17:18:57.989Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构复习-Chapter-4-串"><a href="#数据结构复习-Chapter-4-串" class="headerlink" title="数据结构复习 - Chapter 4 串"></a>数据结构复习 - Chapter 4 串</h1><h2 id="本质区分-（C-语言）"><a href="#本质区分-（C-语言）" class="headerlink" title="本质区分 （C 语言）"></a>本质区分 （C 语言）</h2><p>字符串：  “ “ 中间，本质是 <strong>字符数组</strong> ，本质是线性表结构，结尾 ‘\0’ 不计入长度<br>字符： ‘ ‘ 中间的元素</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><pre class="line-numbers language-c"><code class="language-c"><span class="token function">StrAssign</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>T<span class="token punctuation">,</span> chars<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 给字符串赋值</span><span class="token function">StrCpy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>T<span class="token punctuation">,</span> S<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 复制 S 到 T</span><span class="token function">StrCmp</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 比较二进制的字符串是否符合</span><span class="token function">StrConcat</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>T<span class="token punctuation">,</span> S1<span class="token punctuation">,</span> S2<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 链接 S1 S2 至 T</span><span class="token function">Strlen</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 字符串长度</span><span class="token function">SubStr</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Sub<span class="token punctuation">,</span>S<span class="token punctuation">,</span> Pos<span class="token punctuation">,</span>Len<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 返回 S 中 pos 位（含）起长度为 len 的子串至 Sub</span><span class="token function">StrDestroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 销毁串 S</span><span class="token function">StrIsEmpty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 串 S 判空</span><span class="token function">StrIndex</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> T<span class="token punctuation">,</span> pos<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 返回 T 在 S 的 pos 位置之后第一次出现的位置</span><span class="token function">StrIns</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">,</span> pos<span class="token punctuation">,</span> T<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 串 S 的第 pos 个字符之前插入串 T</span><span class="token function">StrReplace</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">,</span>T<span class="token punctuation">,</span>V<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 用 V 替换 S 中 符合 T 的串</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="表示与实现"><a href="#表示与实现" class="headerlink" title="表示与实现"></a>表示与实现</h2><h3 id="机内表示"><a href="#机内表示" class="headerlink" title="机内表示"></a>机内表示</h3><ul><li>定长顺序表示： 静态存储，地址连续的存储单元。</li><li>堆分配存储： 动态分配的一块地址连续的存储单元。</li><li>串的块链存储表示：链式存储，块链存储，以 <strong>“串的整体”作为操作对象</strong> 。</li></ul><h4 id="块链结构"><a href="#块链结构" class="headerlink" title="块链结构"></a>块链结构</h4><ol><li>每个节点存放多个字符合理，多个是几个？存储密度计算：串值存储位/实际分配存储位。</li></ol><p>块链结构描述：</p><ul><li>每个结点存放多个字符</li><li>结点中空位采用特殊符号填充</li><li>设置 tail 指针指向链表中的最后一个节点位置，方便进行串链接操作，需要注意处理串尾的第一个无效字符。</li></ul><h2 id="模式匹配算法"><a href="#模式匹配算法" class="headerlink" title="模式匹配算法"></a>模式匹配算法</h2><p>BruteForce &amp; KMP:</p><p><a href="https://www.kmahyyg.xyz/2018/KMP-BF-DataStru/">https://www.kmahyyg.xyz/2018/KMP-BF-DataStru/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据结构复习-Chapter-4-串&quot;&gt;&lt;a href=&quot;#数据结构复习-Chapter-4-串&quot; class=&quot;headerlink&quot; title=&quot;数据结构复习 - Chapter 4 串&quot;&gt;&lt;/a&gt;数据结构复习 - Chapter 4 串&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
    
      <category term="School" scheme="https://www.kmahyyg.xyz/tags/School/"/>
    
      <category term="Datastru" scheme="https://www.kmahyyg.xyz/tags/Datastru/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法课程 - Chap 3 栈与队列</title>
    <link href="https://www.kmahyyg.xyz/2019/ynu-datastru-c3/"/>
    <id>https://www.kmahyyg.xyz/2019/ynu-datastru-c3/</id>
    <published>2019-01-05T01:15:40.000Z</published>
    <updated>2019-01-04T17:18:57.989Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构复习-Chapter-3-栈与队列"><a href="#数据结构复习-Chapter-3-栈与队列" class="headerlink" title="数据结构复习 - Chapter 3 栈与队列"></a>数据结构复习 - Chapter 3 栈与队列</h1><p>区分：</p><p>L = (a1 … an)</p><p>线性表: 表头、表尾均可插入删除。</p><p>栈：只能在表尾进行插入和删除。Last-in-First-Out.</p><p>队列：表尾插入，表头删除。 First-in-First-Out.</p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p><strong>栈顶指针：总是指向栈顶元素之上的数组下标位置（最上一个可用空间）</strong><br>top == base 指针，则栈空。</p><h2 id="函数调用问题"><a href="#函数调用问题" class="headerlink" title="函数调用问题"></a>函数调用问题</h2><ol><li>将当前函数的控制转移到被调用函数的入口</li><li>为被调用函数的局部变量分配存储区</li><li>将实在参数、返回地址等信息传递给被调用参数保存</li></ol><h3 id="递归调用"><a href="#递归调用" class="headerlink" title="递归调用"></a>递归调用</h3><p>一个直接调用或通过一系列语句间接调用自己的函数成为递归函数。运行规则： <strong>后调用先返回</strong> ，被调用的函数占有的存储管理应当实行 “栈式存储”。</p><p>调用顺序： F -&gt; F1 -&gt; F2<br>返回顺序： F2 -&gt; F1 -&gt; F</p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>空队列：队头和队尾指针都指向头节点。<br>队头指针：永远指向出队的第一个元素位置<br>队尾：永远指向出队的最后一个元素，判空方法 <code>Queue.rear == CurrentPtr</code></p><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>循环队列：即 设数组维数为 M，使数组下标为 M-1 的结点的指针域，指向数组下标为 0 的结点，从而连成一个环。</p><p>若 rear+1 == M, 则令 rear == 0  ( mod 运算)</p><p><strong>注：front 指向队首元素，rear 指向队尾元素的下一个位置</strong></p><p>操作实现:</p><pre><code>入队：sq[rear]=x    rear=(rear+1) % M出队：x=sq[front]   front=(front+1) % M区分队空队满：（用修改后的与不变的做比较）队空：rear==front        出队操作时才需判断队空队满：rear==(rear+1)% M  入队时判断队满，即 队头指针在队尾指针的下一个位置 （另外一个解决方案：Q.rear 所指向的单元恒为 NULL）              ↑        入队操作修改后的队列长度： [(Queue.rear - Queue.front + MaxQueueSize) % MaxQueueSize]</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据结构复习-Chapter-3-栈与队列&quot;&gt;&lt;a href=&quot;#数据结构复习-Chapter-3-栈与队列&quot; class=&quot;headerlink&quot; title=&quot;数据结构复习 - Chapter 3 栈与队列&quot;&gt;&lt;/a&gt;数据结构复习 - Chapter 3 栈与
      
    
    </summary>
    
    
      <category term="School" scheme="https://www.kmahyyg.xyz/tags/School/"/>
    
      <category term="Datastru" scheme="https://www.kmahyyg.xyz/tags/Datastru/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法课程 - Chap 2 线性表</title>
    <link href="https://www.kmahyyg.xyz/2019/ynu-datastru-c2/"/>
    <id>https://www.kmahyyg.xyz/2019/ynu-datastru-c2/</id>
    <published>2019-01-05T01:15:25.000Z</published>
    <updated>2019-01-04T17:18:57.989Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构复习-Chapter-2-线性表"><a href="#数据结构复习-Chapter-2-线性表" class="headerlink" title="数据结构复习 - Chapter 2 线性表"></a>数据结构复习 - Chapter 2 线性表</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>回顾：</p><p>线性结构：数据元素有序且有限，有且仅有一个起始节点与终端节点，并且每个节点最多只有一个直接前驱和直接后继，头节点没有直接前驱，尾节点没有直接后继。</p><p>线性表：由 n 个同类型的数据元素组成的有限序列。 n 定义为表长度。可以灵活增长、缩短、CRUD。</p><p>直接前驱与直接后继 用有序对表示：&lt;a2,a3&gt;</p><p>存在的应用方法：</p><ul><li>初始化</li><li>求长度、判空、清空</li><li>求所在位置序号、求前驱、求后继</li><li>插入、删除、读取</li><li>求交并</li></ul><h2 id="顺序表示"><a href="#顺序表示" class="headerlink" title="顺序表示"></a>顺序表示</h2><p>定义：按逻辑顺序依次存放在一组地址连续的存储单元。只存储本身的值，不存储逻辑关系，关系通过存储地址相邻来隐含表示。</p><p><strong>注意：数组下表从 0 开始，顺序表位序从 1 开始</strong>。</p><p>算法实现注意：</p><ol><li>入参检查，传入参数不合法返回 -1.</li><li>置空 != 销毁</li><li>顺序表冒泡排序问题</li><li>合并线性表，先排序后合并。</li></ol><p>顺序存储：</p><ul><li>特征：逻辑相邻、物理相邻</li><li>优点：随机查找快，O(1)，节省了存储关系的空间，结构简单、实现方便。</li><li>缺点：插入删除慢，O(n)，不能充分利用所有空间，可能溢出。</li></ul><h2 id="链式表示"><a href="#链式表示" class="headerlink" title="链式表示"></a>链式表示</h2><p>定义：任意存储单元存储数据元素，线性表数据元素的逻辑次序和物理保存次序不一定相同。<br>包括：单链表、双链表、多链表、循环链表。根据指针域数目和指向区分。</p><p>存储结构：</p><ol><li>区分头节点和首元节点。 空表的头节点，指针域为空，代表该链表为空（等价于头指针指向 NULL）。头指针指向头节点，作为首元结点的直接前驱。头节点的数据域可用于存储链表长度。</li></ol><p>查找：按位置、按 Value 查找。<br>插入：指针修改是难点。</p><h3 id="链表修改：-节点插入与删除"><a href="#链表修改：-节点插入与删除" class="headerlink" title="链表修改： 节点插入与删除"></a>链表修改： 节点插入与删除</h3><p>原则：先空后实。先修改新建节点的数据域和指针域，再修改原链表中的元素。</p><p>删除注意：保存现场，需要预保存指向下一元素的指针。</p><p>C 语言背景：如果条件为真 ? 则值为 X : 否则值为 Y</p><h3 id="循环链表与双向链表"><a href="#循环链表与双向链表" class="headerlink" title="循环链表与双向链表"></a>循环链表与双向链表</h3><p>循环链表：将终端指针域的 NULL 指向头节点，就得到了单链表。<br>判断依据：指针指向元素的 next 域是否与头指针重合。<br>特点：从任一节点出发均可找到表中的其他节点。</p><p>双向链表： prior = next = NULL 即为空。<br>插入删除遵循：先空后实。画图是关键。</p><h2 id="实验回顾"><a href="#实验回顾" class="headerlink" title="实验回顾"></a>实验回顾</h2><p>注意 数据处理与 Error Handler，其他的都是常规操作。画图就对了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据结构复习-Chapter-2-线性表&quot;&gt;&lt;a href=&quot;#数据结构复习-Chapter-2-线性表&quot; class=&quot;headerlink&quot; title=&quot;数据结构复习 - Chapter 2 线性表&quot;&gt;&lt;/a&gt;数据结构复习 - Chapter 2 线性表&lt;/
      
    
    </summary>
    
    
      <category term="School" scheme="https://www.kmahyyg.xyz/tags/School/"/>
    
      <category term="Datastru" scheme="https://www.kmahyyg.xyz/tags/Datastru/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法课程 - Chap 1 序言</title>
    <link href="https://www.kmahyyg.xyz/2019/ynu-datastru-c1/"/>
    <id>https://www.kmahyyg.xyz/2019/ynu-datastru-c1/</id>
    <published>2019-01-05T01:14:49.000Z</published>
    <updated>2019-01-04T17:18:57.989Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构复习-Chapter-1-序言"><a href="#数据结构复习-Chapter-1-序言" class="headerlink" title="数据结构复习 - Chapter 1 序言"></a>数据结构复习 - Chapter 1 序言</h1><h2 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h2><p>数据结构研究： 数据的 <strong>逻辑结构、存储结构、每种结构定义的运算</strong> 。</p><p>相关概念：</p><ul><li>数据：信息的符号表示</li><li>数据元素：数据的基本单位</li><li>数据项：一个数据元素可由若干个数据项组成，<strong>数据项是数据的不可分割的最小单位</strong>。</li><li>数据对象：性质相同的数据元素的集合，数据的一个子集。</li><li>结构：数据彼此之间存在的相互关系。</li><li>数据结构：相互之间存在的一种或多种特定关系的数据元素的集合。元素之间的相互联系称为逻辑结构。</li></ul><p>逻辑结构包括：</p><ul><li>集合：没有相关性。</li><li>线性关系：一对一。</li><li>树形关系：一对多。</li><li>图状结构：多对多。</li></ul><h2 id="ADT-抽象数据类型描述"><a href="#ADT-抽象数据类型描述" class="headerlink" title="ADT 抽象数据类型描述"></a>ADT 抽象数据类型描述</h2><p>表示对应数学模型及定义在该模型上的一组操作。</p><pre><code>ADT Typename{  Object: Definition  Relationship: Definition  BasicOperation: Definition} ADT Typename</code></pre><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>算法：指令的有限序列，每条指令包括一个或多个操作，五个特性：<strong>有穷、确定、可行性、输入、输出</strong> 。</p><p>算法意味着 <strong>可终止</strong> ，程序是 <strong>算法使用某种具体程序设计语言</strong> 具体实现。</p><p>算法的设计要求：</p><ul><li>正确性： 满足具体问题需求。</li><li>可读性：有助于阅读理解，简化后续维护与调试修改的难度。</li><li>健壮性（Robustness，鲁棒性）：具有容错处理能力。</li><li>效率 与 存储需求：算法执行时间 + 算法执行过程中所需的最大存储空间，与问题规模相关。</li></ul><h3 id="算法构成与复杂度问题"><a href="#算法构成与复杂度问题" class="headerlink" title="算法构成与复杂度问题"></a>算法构成与复杂度问题</h3><p>时间复杂度 &lt;=&gt; 运算工作量，对应问题规模<br>空间复杂度 &lt;=&gt; 对应需要的最大存储空间</p><p>算法：控制结构（循环、顺序、分支）+原操作（固有数据类型的操作）</p><p>例如：三次循环，从1到n，总次数为 n^3 ，时间复杂度为 O(n^3)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据结构复习-Chapter-1-序言&quot;&gt;&lt;a href=&quot;#数据结构复习-Chapter-1-序言&quot; class=&quot;headerlink&quot; title=&quot;数据结构复习 - Chapter 1 序言&quot;&gt;&lt;/a&gt;数据结构复习 - Chapter 1 序言&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="School" scheme="https://www.kmahyyg.xyz/tags/School/"/>
    
      <category term="Datastru" scheme="https://www.kmahyyg.xyz/tags/Datastru/"/>
    
  </entry>
  
  <entry>
    <title>君子务本</title>
    <link href="https://www.kmahyyg.xyz/2019/chinese-gentleman-works-hard/"/>
    <id>https://www.kmahyyg.xyz/2019/chinese-gentleman-works-hard/</id>
    <published>2019-01-05T01:04:50.000Z</published>
    <updated>2019-01-04T17:18:57.989Z</updated>
    
    <content type="html"><![CDATA[<h1 id="君子务本"><a href="#君子务本" class="headerlink" title="君子务本"></a>君子务本</h1><blockquote><p>有子曰：「其為人也孝弟，而好犯上者，鮮矣；不好犯上，而好作亂者，未之有也。君子務本，本立而道生。孝弟也者，其為仁之本與！」</p><p>——《论语·学而》</p></blockquote><p>孔子在数千年前提出了上述思想，用于描述儒家的一种对于组织行为的规范。儒家的组织行为规范，基本上以儒家的伦理道德思想为主轴，将每个人的定位与顺序厘清，以统治者为最高模范，再从个人的修养入手，以个人的「本质内涵」修养「内仁、外礼」，其在个人思想境界提升上至今仍具有重大的现实意义。</p><p>然而，放之今日，此言的适用者已经不仅仅局限于君王。“一位有志于修养高尚品德的君子，「修身」是他一切修养的根本，「修身」的根本一立住，「仁道」也就建立起来了。” 故曰：“君子务本，本立而道生。”</p><h2 id="那么，何为本？作为一个君子，如何务本？"><a href="#那么，何为本？作为一个君子，如何务本？" class="headerlink" title="那么，何为本？作为一个君子，如何务本？"></a>那么，何为本？作为一个君子，如何务本？</h2><p>《礼记·大学》中有如下记载：</p><blockquote><p>「古之欲明明德於天下者，先治其國；欲治其國者，先齊其家；欲齊其家者，先修其身；欲修其身者，先正其心；欲正其心者，先誠其意；欲誠其意者，先致其知，致知在格物。物格而後知至，知至而後意誠，意誠而後心正，心正而後身修，身修而後家齊，家齊而後國治，國治而後天下平。自天子以至於庶人，壹是皆以修身為本。其本亂而末治者否矣，其所厚者薄，而其所薄者厚，未之有也！此謂知本，此謂知之至也。」</p></blockquote><p>由此可知，“知本”（即“务本”）便是实现“三纲八目”（三纲：明明德、亲民、止于至善；八目：格物、致知、诚意、正心、修身、治国、齐家、平天下），即“修己”是治人的前提，也正是这一思想为后世“达则兼济天下，穷则独善其身”奠定了坚实的基础。</p><p>而我个人更喜欢著名国学大师南怀瑾老先生的提法，即“四纲七证八目”。四纲，即为“本”，“七证”则指出“君子务本”的几个基础步骤，“八目”则指出了圆满修行四纲的行为阶梯。</p><p>南老将《大学》原有的三纲加上大学之道一纲，三纲变四纲。大学之道作为首纲，与明明德、亲民、止于至善是一个修德悟道的整体。止于至善就是止于至道，因为离开道，至善的指向不明晰，个人修行容易落入茫然不知所措的空道。止于至道是明明德、亲民、止于至善三纲运用于个人修行与觉悟的领航，离开了道的指引，个人的修行与觉悟就如没有方向的航行与跋涉。大学之道做为大学四纲第一纲，引领二、三、四纲。全句做为大学全文的纲要，统领全文的精髓。所以南老把大学之道作为第一纲，具有深刻的中华文化内涵。</p><p>接下来确定了“四纲”之后，本文将着重谈一谈如何在“七证”指引之下寻求达到四纲并达到“八目”所追求的行为境界。</p><p>七证即知、止、定、静、安、虑、得。</p><p>七证的步骤又称七步学养功夫，是经文给出的七个求证大道学问的程序与步骤。整体来说，七证从人的认知、志向、心性、处事方面指导人们追寻大道。</p><p>在认知上，古语有云“小知不及大知”。七证中的“知”则是教导人们在小知的基础上达到大知的认知。所谓小知，即是言传知识；所谓大知，即是意会知识，小知是大知的一部分。近代西方异军突起，在自然科学上以严谨科学的实验和逻辑推理发现、推理自然规律，并用于进一步改造生活、认识生活、推动科技的发展。中华传统文化的精华部分则在小知的基础上继续前进，达到“转识成智”，深刻的诠释人与自然的关系，落实最终阴阳互动、天地人和谐发展的大道，也是一种面向天、地、人、物的广义上的“爱”，也就是最终君子务本的终极境界。</p><p>在志向上，当认知止于至善，也就达到了广义的“爱”的境界，“研学求真，于缉熙敬止”。知止，则志向安定。人生有了至善的终极目标，心境也就逐渐安定下来，大道已在心中，自然不为俗世琐事所拘束。心归于平静。</p><p>诸葛亮《诫子书》有云：“夫君子之行，静以修身，俭以养德，非淡泊无以明志，非宁静无以致远。”静，又似一把镜子，照见你心底的时时勤拂试，又照见你的明镜亦非台。心静则万事安定，自然处事方圆、考虑周全，便有包容万物的胸怀，反哺了静安之道。海纳百川也成了虑后的自然所得。一切都在冥冥之中归于自然，所得自为浑然天成，非人力之他力所求。最终达到了天地人和谐发展的大道，进入了面向天、地、人、物的广义上的大“爱”的境界。</p><p>这样明静知止的心，随遇而安，是生活中温暖的底蕴，即是君子务本的根本。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;君子务本&quot;&gt;&lt;a href=&quot;#君子务本&quot; class=&quot;headerlink&quot; title=&quot;君子务本&quot;&gt;&lt;/a&gt;君子务本&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;有子曰：「其為人也孝弟，而好犯上者，鮮矣；不好犯上，而好作亂者，未之有也。君子務本，本立而道生。孝
      
    
    </summary>
    
    
      <category term="School" scheme="https://www.kmahyyg.xyz/tags/School/"/>
    
  </entry>
  
  <entry>
    <title>2018 汇编大作业</title>
    <link href="https://www.kmahyyg.xyz/2019/ASM-BigHomework/"/>
    <id>https://www.kmahyyg.xyz/2019/ASM-BigHomework/</id>
    <published>2019-01-04T20:12:43.000Z</published>
    <updated>2019-01-04T17:18:57.989Z</updated>
    
    <content type="html"><![CDATA[<p>TODO</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;TODO&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Tech" scheme="https://www.kmahyyg.xyz/tags/Tech/"/>
    
      <category term="School" scheme="https://www.kmahyyg.xyz/tags/School/"/>
    
  </entry>
  
  <entry>
    <title>2018 年终总结</title>
    <link href="https://www.kmahyyg.xyz/2019/2018-EndofYear/"/>
    <id>https://www.kmahyyg.xyz/2019/2018-EndofYear/</id>
    <published>2019-01-04T20:11:50.000Z</published>
    <updated>2019-01-04T17:18:57.989Z</updated>
    
    <content type="html"><![CDATA[<p>TODO</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;TODO&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="School" scheme="https://www.kmahyyg.xyz/tags/School/"/>
    
      <category term="Personal" scheme="https://www.kmahyyg.xyz/tags/Personal/"/>
    
  </entry>
  
  <entry>
    <title>关于 C 的 CRC32 实现</title>
    <link href="https://www.kmahyyg.xyz/2018/CRC32-Network/"/>
    <id>https://www.kmahyyg.xyz/2018/CRC32-Network/</id>
    <published>2018-12-04T21:14:28.000Z</published>
    <updated>2019-01-04T17:18:57.989Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><p>最近讲了计算机网络课程，在上课过程中明白了 CRC32 的人工计算方法。个人猜测后面计算机网络实验会做，趁最近忙碌，一鼓作气，在刚刚学完的时候一起实现了吧。</p><h2 id="关于-CRC32"><a href="#关于-CRC32" class="headerlink" title="关于 CRC32"></a>关于 CRC32</h2><p>具体的原理性的东西就不说了，大家自己搜索 IEEE 802.3 相关文档和维基百科吧。主要用途是传输过程中的错误检测，由于容错率高，简单易于实现，占用资源少，得到了广泛的应用。</p><h3 id="关于-手动计算"><a href="#关于-手动计算" class="headerlink" title="关于 手动计算"></a>关于 手动计算</h3><p>就那点内容，其实我也很懵逼，就多查查资料吧。剩下的就是 <code>Talk is cheap, show me the code!</code> ，大家自己根据 Reversed CRC32 的 GZip 实现参考吧。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// C Native implement, CRC32</span><span class="token comment" spellcheck="true">// Reference: RFC1952 https://tools.ietf.org/html/rfc1952</span><span class="token comment" spellcheck="true">// Reference: PEDIY https://bbs.pediy.com/thread-17195.htm</span><span class="token comment" spellcheck="true">// Reference: CSDN https://blog.csdn.net/xiaogugood/article/details/8724745</span><span class="token comment" spellcheck="true">// Reference: https://stackoverflow.com/questions/2587766/how-is-a-crc32-checksum-calculated</span><span class="token comment" spellcheck="true">// Reference: http://stigge.org/martin/pub/SAR-PR-2006-05.pdf</span><span class="token comment" spellcheck="true">// Written by Patrick Young</span><span class="token comment" spellcheck="true">// Created on Tuesday, December 11, 2018 2:57 PM</span><span class="token comment" spellcheck="true">// Updated on Wednesday, December 12, 2018 1:06 PM</span><span class="token comment" spellcheck="true">// Rev.5</span><span class="token comment" spellcheck="true">/* * The highest bit of the generator is always 1, so ignored in the polyabbr. * * Algorithm   Result       Check               Poly        Init       RefIn     RefOut     XorOut      ReversedPoly    CRC-32     0xCBF43926      0xCBF43926    0x04C11DB7      0xFFFFFFFF    true    true    0xFFFFFFFF   0xEDB88320 */</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;inttypes.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> crc_table<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Table of CRCs of all 8-bit messages</span><span class="token keyword">int</span> is_crc_table_computed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//计算本字节后的CRC码，等于上一字节余式CRC码的低8位左移8位，加上上一字节CRC右移8位和本字节之和后所求得的CRC码</span><span class="token keyword">void</span> <span class="token function">make_crc_table</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> c<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> n <span class="token operator">&lt;</span> <span class="token number">256</span><span class="token punctuation">;</span> <span class="token operator">++</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// all groups contains 8 bits * 4 * n, XOR can be passed without any external opeation</span>        <span class="token comment" spellcheck="true">// divide the msg into 8-bit-long group</span>        c <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span> n<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// Least-Significant-Bit first.</span>                <span class="token comment" spellcheck="true">// Same CRC property but reversed to fit old hardware(low memory address save lower bits of data.)</span>                c<span class="token operator">=</span> <span class="token number">0xedb88320L</span> <span class="token operator">^</span> <span class="token punctuation">(</span>c <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 0 is non-sense.</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                c<span class="token operator">=</span> c <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        crc_table<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    is_crc_table_computed <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* * Update a running crc with the bytes buf[0..len-1] and returnthe updated crc. The crc should be initialized to zero. Pre- andpost-conditioning (one's complement) is performed within thisfunction so it shouldn't be done by the caller. Usage example: * *  unsigned long crc = 0L; * *  while (read_buffer(buffer, length) != EOF) { *      crc = update_crc(crc, buffer, length); *  } *   if (crc != original_crc) error(); **/</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">update_crc</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> crc<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> c <span class="token operator">=</span> crc <span class="token operator">^</span> <span class="token number">0xffffffffL</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>is_crc_table_computed<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">make_crc_table</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// build the crc table first for fast lookup</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*    （1）将上次计算出的CRC校验码右移一个字节；    （2）将移出的这个字节与新的要校验的字节进行XOR运算；    （3）用运算出的值在预先生成码表中进行索引，获取对应的值（称为余式）；    （4）用获取的值与第（1）步右移后的值进行XOR运算；    （5）如果要校验的数据已经处理完，则第（4）步的结果就是最终的CRC校验码。如果还有数据要进行处理，则再转到第（1）步运行。     */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> p <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> <span class="token operator">++</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>        c <span class="token operator">=</span> crc_table<span class="token punctuation">[</span><span class="token punctuation">(</span>c <span class="token operator">^</span> buf<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xff</span><span class="token punctuation">]</span> <span class="token operator">^</span> <span class="token punctuation">(</span>c <span class="token operator">>></span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// remove the non-sense zero and shifted bits</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> c <span class="token operator">^</span> <span class="token number">0xffffffffL</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// avoid "add zero as you want, not affected" problem</span><span class="token punctuation">}</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">crc</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Math theory by hand: (quotient + remainder)/divisor = 0</span>    <span class="token comment" spellcheck="true">// appended 0s is used for be a placeholder of remainder</span>    <span class="token keyword">return</span> <span class="token function">update_crc</span><span class="token punctuation">(</span><span class="token number">0L</span><span class="token punctuation">,</span>buf<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// recursive update crc checksum.</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">check_crcsum</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>src<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> sum<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// why should I calculate the damn divide</span>    <span class="token comment" spellcheck="true">// (data+crc) / divisor = 000 ,correct</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> xr <span class="token operator">=</span> <span class="token function">crc</span><span class="token punctuation">(</span>src<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">strlen</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// just calculate received data's CRC, check if corresponding is okay.</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The source is %s, Checksum calculated is: 0x%lx\n"</span><span class="token punctuation">,</span> src<span class="token punctuation">,</span> xr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>xr <span class="token operator">==</span> sum<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Data CRC check passed! \n\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The offered checksum 0x%lx is different from offered one. \n"</span><span class="token punctuation">,</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Data Corrupted! \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">printUsage</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Illegal input! \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Usage: %s &lt;SOURCE STRING> 0x&lt;CRC32SUM>\n"</span><span class="token punctuation">,</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Usage: If you want to calculate, just input source in ASCII mode. \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Usage: If you want to check, use the second param such as 1A3C5D78 as a HEX String.\n\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> argc <span class="token operator">!=</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printUsage</span><span class="token punctuation">(</span>argv<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">char</span> <span class="token operator">*</span>ipt <span class="token operator">=</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> final <span class="token operator">=</span> <span class="token function">crc</span><span class="token punctuation">(</span>ipt<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">strlen</span><span class="token punctuation">(</span>ipt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The source is: %s\n"</span><span class="token punctuation">,</span>ipt<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The CRC32 checksum is: 0x%lx \n\n"</span><span class="token punctuation">,</span>final<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">char</span> <span class="token operator">*</span>ipt <span class="token operator">=</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">char</span> <span class="token operator">*</span>csum <span class="token operator">=</span> argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span>csum<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">printUsage</span><span class="token punctuation">(</span>argv<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> hexcsum <span class="token operator">=</span> <span class="token function">strtoul</span><span class="token punctuation">(</span>csum<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> stats <span class="token operator">=</span> <span class="token function">check_crcsum</span><span class="token punctuation">(</span>ipt<span class="token punctuation">,</span>hexcsum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> stats<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.xilinx.com/support/documentation/application_notes/xapp209.pdf" target="_blank" rel="noopener">https://www.xilinx.com/support/documentation/application_notes/xapp209.pdf</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Preface&quot;&gt;&lt;a href=&quot;#Preface&quot; class=&quot;headerlink&quot; title=&quot;Preface&quot;&gt;&lt;/a&gt;Preface&lt;/h1&gt;&lt;p&gt;最近讲了计算机网络课程，在上课过程中明白了 CRC32 的人工计算方法。个人猜测后面计算机网络实验会
      
    
    </summary>
    
    
      <category term="Tech" scheme="https://www.kmahyyg.xyz/tags/Tech/"/>
    
      <category term="School" scheme="https://www.kmahyyg.xyz/tags/School/"/>
    
  </entry>
  
  <entry>
    <title>YNU - 汇编语言程序设计实验报告 4-5</title>
    <link href="https://www.kmahyyg.xyz/2018/ASM-exp-report2/"/>
    <id>https://www.kmahyyg.xyz/2018/ASM-exp-report2/</id>
    <published>2018-11-19T13:09:43.000Z</published>
    <updated>2019-01-04T17:18:57.989Z</updated>
    
    <content type="html"><![CDATA[<h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>如未署名，所有 *.kmahyyg.xyz 的域名下的版权均为本人所有，遵循对应站点下的授权协议。</p><p>本篇文章授权 采用 CC BY-NC-ND 3.0 Unported 协议，禁止转载。</p><h1 id="Experiment-4"><a href="#Experiment-4" class="headerlink" title="Experiment 4"></a>Experiment 4</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>使用虚拟机 Qemu-KVM 和调试器 Bochs，执行，调试 MBR 扇区代码，了解计算机启动的原理和 MBR 扇区代码的功能。</p><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><ol><li>阅读参考源程序并增加注释；</li><li>在参考源程序中增加指令(不要改变原程序的功能)，为程序增加功能：输出你的学号和姓名拼音；</li></ol><p>SRC:     <a href="https://gist.github.com/kmahyyg/ce0d0e3079363f7be5d91f7ace0d9c0d" target="_blank" rel="noopener">https://gist.github.com/kmahyyg/ce0d0e3079363f7be5d91f7ace0d9c0d</a></p><ol start="3"><li>使用 NASM 工具将修改后的实验源程序编译为 .bin 文件；</li><li>将 .bin 文件用 dd 写入虚拟机硬盘 MBR 扇区；</li><li>使用 Qemu-KVM 虚拟机观察写入 .bin 文件的执行结果；</li></ol><p>Tutorial:    <a href="https://blog.kmahyyg.xyz/2018/ASM-exp-report/#%E5%AE%9E%E9%AA%8C%E6%93%8D%E4%BD%9C%EF%BC%9A%E7%BC%96%E8%AF%91%E5%AE%8C%E6%88%90%E5%90%8E%E7%9A%84-BOCHS-%E5%AF%BC%E5%85%A5" target="_blank" rel="noopener">https://blog.kmahyyg.xyz/2018/ASM-exp-report/#%E5%AE%9E%E9%AA%8C%E6%93%8D%E4%BD%9C%EF%BC%9A%E7%BC%96%E8%AF%91%E5%AE%8C%E6%88%90%E5%90%8E%E7%9A%84-BOCHS-%E5%AF%BC%E5%85%A5</a></p><ol start="6"><li>关闭 Qemu-KVM，使用 BochsDBG 虚拟机调试写入在虚拟硬盘 MBR 扇区中的程序；</li></ol><p><img src="https://yygc.zzjnyyz.cn/asset_files/2018-asmexp3-02.png" alt="2018-asmexp3-02.png"></p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ol><li>计算机如何在屏幕上显示字符？</li></ol><p><a href="https://asm.kmahyyg.xyz/exps/exp7-transfer.html#quiz-2%EF%BC%9A-%E6%A0%B9%E6%8D%AE%E6%9D%90%E6%96%99%E7%BC%96%E7%A8%8B" target="_blank" rel="noopener">https://asm.kmahyyg.xyz/exps/exp7-transfer.html#quiz-2%EF%BC%9A-%E6%A0%B9%E6%8D%AE%E6%9D%90%E6%96%99%E7%BC%96%E7%A8%8B</a></p><ol start="2"><li>如何输入输出 10 进制数据？如何输入数字、字符串？</li></ol><p><a href="https://computer.howstuffworks.com/bios1.htm" target="_blank" rel="noopener">https://computer.howstuffworks.com/bios1.htm</a></p><p><a href="https://blog.csdn.net/qq_28598203/article/details/51081368" target="_blank" rel="noopener">https://blog.csdn.net/qq_28598203/article/details/51081368</a></p><p>结合中断向量表实现。</p><ol start="3"><li>MBR 扇区有什么特点？MBR 扇区中的代码实现什么功能？</li></ol><p><a href="https://wiki.osdev.org/MBR_(x86)" target="_blank" rel="noopener">https://wiki.osdev.org/MBR_(x86)</a></p><ol start="4"><li>简述计算机复位后的启动过程。</li></ol><p><a href="https://wiki.osdev.org/Boot_Sequence" target="_blank" rel="noopener">https://wiki.osdev.org/Boot_Sequence</a></p><h1 id="Experiment-5"><a href="#Experiment-5" class="headerlink" title="Experiment 5"></a>Experiment 5</h1><h2 id="实验目的-1"><a href="#实验目的-1" class="headerlink" title="实验目的"></a>实验目的</h2><p>了解计算机屏幕显示的原理，编程实现显存映射与中断 <code>int 10H</code> 式。</p><h2 id="实验内容-1"><a href="#实验内容-1" class="headerlink" title="实验内容"></a>实验内容</h2><ol><li>使用控制显存显示内容。</li></ol><blockquote><p>略，之前的实现均使用的这种方式。MASM 与 NASM 的差异，在使用这种方式时差异不大，此处略去不表。</p></blockquote><ol start="2"><li>使用 <code>int 10H</code> 方式显示数据。</li></ol><p>看这里！这里有代码： </p><p>MASM: <a href="https://gist.github.com/kmahyyg/4e8dc523f513ff78a53c18e4234460af" target="_blank" rel="noopener">https://gist.github.com/kmahyyg/4e8dc523f513ff78a53c18e4234460af</a></p><p>NASM: <a href="https://gist.github.com/kmahyyg/4e8dc523f513ff78a53c18e4234460af" target="_blank" rel="noopener">https://gist.github.com/kmahyyg/4e8dc523f513ff78a53c18e4234460af</a></p><h2 id="思考题-1"><a href="#思考题-1" class="headerlink" title="思考题"></a>思考题</h2><ol><li>注释源程序</li></ol><p>已经注释了，懒得多写废话，具体的详细文档自己看后面的 Reference。这里略微一提， BIOS 是一个最小型的系统，在硬件支持 int 13h 对应的显示模式的前提下，可以通过 BIOS 中断向量 int 10h 调用显示 API。</p><p>具体参考这里 <a href="https://protas.pypt.lt/informatika/assembler/writing_to_the_screen" target="_blank" rel="noopener">https://protas.pypt.lt/informatika/assembler/writing_to_the_screen</a></p><p>2.显示字符的方式</p><p>就两种，实验目的里写的很清楚，具体的自己去查资料。</p><h1 id="Experiment-6"><a href="#Experiment-6" class="headerlink" title="Experiment 6"></a>Experiment 6</h1><h2 id="实验目的-2"><a href="#实验目的-2" class="headerlink" title="实验目的"></a>实验目的</h2><p>接受键盘输入，保存到磁盘；从磁盘读取，显示到屏幕。</p><h2 id="实验实现"><a href="#实验实现" class="headerlink" title="实验实现"></a>实验实现</h2><p>目前问题：</p><p>Can： 接受输入、保存到 FDD，从磁盘读取，读取到指定的具体的固定 RAM 地址并显示。<br>Cannot： 读取到变量对应的地址并显示，读取 FDD 成功但写入 RAM 失败…</p><p>接受输入，写入 FDD 的代码：</p><pre class="line-numbers language-asm6502"><code class="language-asm6502">dataarea segment    buffer db 64   ; max 63 bytes string           db ?    string db 64 dup ('$')  ; preallocated with '$', int 21h/0ah outputdataarea endscodesg segment;START PROCmain proc far    assume cs:codesg,ds:dataareastart:;SAVE THE CURRENT SITUATION FOR RET    push ds    sub ax,ax    push ax;POINT CORRESPONDING DATA REGISTER    mov ax,dataarea    mov ds,ax;GET INPUT FROM KEYBOARD    lea dx,buffer    mov ah,0ah    int 21h;PREPARE ES:BX to where data to be wrote into    mov ax,dataarea    mov es,ax    lea bx,string;WRITE DATA TO FDD, 0 Cylinder: 0 Track: 4 Sector;Each sector has 512 bytes    mov ah,3  ; 3 for write    mov al,1  ; how many sectors to write    mov dh,0  ; cylinder    mov ch,0  ; track    mov cl,4  ; sector    mov dl,0  ; drive no.     ;0:FDD-A, 1:FDD-B, 80H:HDD-C, 81H:HDD-D    int 13h     retmain endpcodesg ends    end start <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接受输入之后回显打印：</p><pre class="line-numbers language-asm6502"><code class="language-asm6502">;sudo mount -o loop,offset=$(python -c 'print(512*63)') /var/lib/libvirt/images/dosdata.img /mnt/nfs1dataarea segment    buffer db 64           db ?    string db 64 dup ('$')    hint   db 10,13,'$'dataarea endscodesg segmentmain proc far    assume cs:codesg,ds:dataareastart:    push ds    sub ax,ax    push ax    mov ax,dataarea    mov ds,ax    lea dx,buffer    mov ah,0ah    int 21h    mov cx,2newl:    lea dx,hint    mov ah,9h    int 21h    loop newl    lea dx,string    mov ah,9h    int 21h    retmain endpcodesg ends    end start <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><strong>不要忘记打末尾的 <code>h</code></strong></p><pre><code>INT 13h / AH = 02h - read disk sectors into memory.INT 13h / AH = 03h - write disk sectors.    input:AL = number of sectors to read/write (must be nonzero)CH = cylinder number (0..79).CL = sector number (1..18).DH = head number (0..1).DL = drive number (0..3 , for the emulator it depends on quantity of FLOPPY_ files).ES:BX points to data buffer.    return:CF set on error.CF clear if successful.AH = status (0 - if successful).AL = number of sectors transferred. Note: each sector has 512 bytes.</code></pre><pre><code>INT 21h / AH=9 - output of a string at DS:DX. String must be terminated by &#39;$&#39;. example:        org 100h        mov dx, offset msg        mov ah, 9        int 21h        ret        msg db &quot;hello world $&quot;</code></pre><pre><code>INT 21h / AH=0Ah - input of a string to DS:DX, fist byte is buffer size, second byte is number of chars actually read. this function does not add &#39;$&#39; in the end of string. to print using INT 21h / AH=9 you must set dollar character at the end of it and start printing from address DS:DX + 2. </code></pre><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1><p>本学期的汇编课程的随堂实验就到此告一段落，感谢 王逍老师的精心付出<br>和 钰在各方面的帮助，爱你！</p><p>Updated on Thu Nov 29 23:41:30 CST 2018<br>Rev. 09</p><h1 id="Reference-1"><a href="#Reference-1" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://thestarman.pcministry.com/asm/mbr/STDMBR.htm" target="_blank" rel="noopener">https://thestarman.pcministry.com/asm/mbr/STDMBR.htm</a></p><p><a href="https://thestarman.pcministry.com/asm/bios/index.html" target="_blank" rel="noopener">https://thestarman.pcministry.com/asm/bios/index.html</a></p><p><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-823-computer-system-architecture-fall-2005/index.htm" target="_blank" rel="noopener">https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-823-computer-system-architecture-fall-2005/index.htm</a></p><p><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-828-operating-system-engineering-fall-2012/index.htm" target="_blank" rel="noopener">https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-828-operating-system-engineering-fall-2012/index.htm</a></p><p><a href="https://stackoverflow.com/questions/41196376/int-10h-13h-bios-string-output-not-working" target="_blank" rel="noopener">https://stackoverflow.com/questions/41196376/int-10h-13h-bios-string-output-not-working</a></p><p><a href="http://www.ablmcc.edu.hk/~scy/CIT/8086_bios_and_dos_interrupts.htm" target="_blank" rel="noopener">http://www.ablmcc.edu.hk/~scy/CIT/8086_bios_and_dos_interrupts.htm</a></p><p><a href="https://wiki.osdev.org/ATA_PIO_Mode" target="_blank" rel="noopener">https://wiki.osdev.org/ATA_PIO_Mode</a></p><p><a href="https://stackoverflow.com/questions/8461363/access-harddrive-using-assembly" target="_blank" rel="noopener">https://stackoverflow.com/questions/8461363/access-harddrive-using-assembly</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;License&quot;&gt;&lt;a href=&quot;#License&quot; class=&quot;headerlink&quot; title=&quot;License&quot;&gt;&lt;/a&gt;License&lt;/h2&gt;&lt;p&gt;如未署名，所有 *.kmahyyg.xyz 的域名下的版权均为本人所有，遵循对应站点下的授权协议。&lt;
      
    
    </summary>
    
    
      <category term="Tech" scheme="https://www.kmahyyg.xyz/tags/Tech/"/>
    
      <category term="School" scheme="https://www.kmahyyg.xyz/tags/School/"/>
    
  </entry>
  
  <entry>
    <title>使用 Backblaze + Cloudflare 搭建 10G 免费网盘</title>
    <link href="https://www.kmahyyg.xyz/2018/B2-Cloudflare/"/>
    <id>https://www.kmahyyg.xyz/2018/B2-Cloudflare/</id>
    <published>2018-11-11T16:32:06.000Z</published>
    <updated>2019-01-04T17:18:57.989Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><p> Backblaze 作为一家专业提供云存储服务的厂商为我们提供了一个 B2 Cloud Storage 服务。其免费额度包含 10GiB 存储空间 + 每天 1 GiB 下载流量 + 每天 2500 次的 API 调用量。近期，由于 Cloudflare CDN 到 B2 服务器的流量不再计费，我们可以利用这一特性打造不限下载流量，附带全球免费 CDN 加成的下载网盘。</p><h1 id="Deploy"><a href="#Deploy" class="headerlink" title="Deploy"></a>Deploy</h1><h2 id="注册和登陆"><a href="#注册和登陆" class="headerlink" title="注册和登陆"></a>注册和登陆</h2><p>按照文字提示处理，B2 注册的时候不需要提供信用卡，请提供真实的账单地址以供验证。请注册完成之后创建 Bucket，然后任意上传一个文件，记录下该文件的 Friendly Download Address，以备后续使用。</p><h2 id="接入-Cloudflare"><a href="#接入-Cloudflare" class="headerlink" title="接入 Cloudflare"></a>接入 Cloudflare</h2><p>请参考我之前的博文： <a href="/2018/CAMAL-OfflineDL/">CAMAL 离线下载套件</a></p><p>接入时的几点注意：</p><ul><li>如果您使用 CNAME 方式接入，请注意检查是否已经由 Cloudflare 正确下发证书。</li><li>B2 Cloud Storage 要求请求的 URL 必须为 HTTPS，请您注意您分发时的 URL.</li><li>使用 CNAME 方式接入时的回源地址应为你的 Friendly Download Address 中的域名，如果这个方式无法正确下发域名，请您将其临时更改为其他启用了 HTTPS 的大站的域名并重新禁用、启用一次 Cloudflare Universal SSL，等待下发证书成功后改回即可。</li><li>接入完成并确认证书正确下发后再根据 Reference 设置您的 Page Rules 用以屏蔽未授权的访问。</li><li>在您的 权威 DNS 端的 CNAME 设置也请参考我之前的博文，如果存在问题，请先改为由伙伴面板提供的 CNAME 再切换为您想定义的其他线路。</li></ul><p>最终的文件访问 URL 格式应当为：  <code>https://&lt;YOUR CUSTOM DOMAIN WITH CLOUDFLARE ACCLERATED&gt;/file/&lt;BUCKET NAME&gt;/&lt;FILE NAME&gt;</code></p><p>具体的 B2 云存储相关的安全设置请参考 Backblaze 官方文档，Cloudflare 安全性相关设置请参考 Cloudflare 官方文档并结合您的自身需求。</p><p>Recommended Page Rules:</p><p><img src="https://yygc.zzjnyyz.cn/asset_files/2018-b2cf-01.png" alt="Recommended Page Rules"></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://help.backblaze.com/hc/en-us/articles/217666928-Using-Backblaze-B2-with-the-Cloudflare-CDN" target="_blank" rel="noopener">https://help.backblaze.com/hc/en-us/articles/217666928-Using-Backblaze-B2-with-the-Cloudflare-CDN</a></li><li><a href="https://www.kmahyyg.xyz/2018/CAMAL-OfflineDL/">https://www.kmahyyg.xyz/2018/CAMAL-OfflineDL/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Preface&quot;&gt;&lt;a href=&quot;#Preface&quot; class=&quot;headerlink&quot; title=&quot;Preface&quot;&gt;&lt;/a&gt;Preface&lt;/h1&gt;&lt;p&gt; Backblaze 作为一家专业提供云存储服务的厂商为我们提供了一个 B2 Cloud Stora
      
    
    </summary>
    
    
      <category term="Tech" scheme="https://www.kmahyyg.xyz/tags/Tech/"/>
    
  </entry>
  
  <entry>
    <title>将 CUPS 共享的打印机转为 Airprint 适用</title>
    <link href="https://www.kmahyyg.xyz/2018/Cups2Airprint/"/>
    <id>https://www.kmahyyg.xyz/2018/Cups2Airprint/</id>
    <published>2018-10-24T10:31:57.000Z</published>
    <updated>2019-01-04T17:18:57.989Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Convert-CUPS-Printer-to-Airprint-available"><a href="#Convert-CUPS-Printer-to-Airprint-available" class="headerlink" title="Convert CUPS Printer to Airprint-available"></a>Convert CUPS Printer to Airprint-available</h1><h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><p>由于人民日益增长的打印需要与打印店日益下降的打印质量和开门时间存在的巨大矛盾，已经穷得吃土的我买了一个打印机。<del>然而，迫于钱没加够，又有自动双面打印的需要（手动双面打印总是把纸放反……）所以舍弃了网络打印，买了个自动双面打印功能的 USB 打印机。</del></p><h2 id="Prepare"><a href="#Prepare" class="headerlink" title="Prepare"></a>Prepare</h2><ol><li>一台已经连接到打印机的服务器</li><li>一台安装了对应 Linux 发行版及对应打印机驱动并连接到对应局域网的 Linux 主机</li><li>可以正常运作的 CUPS 和 Avahi Daemon</li></ol><h2 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h2><p>请先确保您的打印机此时已经可以正常工作并能通过物理连接正常打印。</p><h3 id="CUPSD-添加打印机"><a href="#CUPSD-添加打印机" class="headerlink" title="CUPSD 添加打印机"></a>CUPSD 添加打印机</h3><p>添加一个打印机，做好默认设置，务必把打印机的默认打印设置配置好之后设为共享打印机，并对 CUPSD 打印服务器整体的打印共享功能打开。</p><h3 id="CUPSD-配置文件修改"><a href="#CUPSD-配置文件修改" class="headerlink" title="CUPSD 配置文件修改"></a>CUPSD 配置文件修改</h3><blockquote><p>/etc/cups/cupsd.conf </p></blockquote><p>在 <code>Listen /run/cups/cups.sock</code> 后面添加这个。</p><pre><code>Listen /run/cups/cups.sockListen 0.0.0.0:631PreserveJobHistoryFileDevice YesServerAlias *</code></pre><p>在这里添加对应的缺失的几行，并在 Web 管理控制端勾起 <code>Share printers connected to this system</code> 。</p><pre><code>&lt;Location /&gt;  # Allow shared printing...  Order allow,deny  Allow @LOCAL&lt;/Location&gt;&lt;Location /admin&gt;  Order allow,deny  allow @LOCAL&lt;/Location&gt;&lt;Location /admin/conf&gt;  AuthType Default  Require user @SYSTEM&lt;/Location&gt;&lt;Location /admin/log&gt;  AuthType Default  Require user @SYSTEM  Order allow,deny  allow @LOCAL&lt;/Location&gt;</code></pre><h3 id="创建-MIME-应用类型配置"><a href="#创建-MIME-应用类型配置" class="headerlink" title="创建 MIME 应用类型配置"></a>创建 MIME 应用类型配置</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># echo "image/urf urf string(0,UNIRAST&lt;00>)" > \</span>    /usr/share/cups/mime/airprint.types<span class="token comment" spellcheck="true"># echo "image/urf application/pdf 100 pdftoraster" > \</span>    /usr/share/cups/mime/airprint.convs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Avahi-Daemon-配置文件修改"><a href="#Avahi-Daemon-配置文件修改" class="headerlink" title="Avahi Daemon 配置文件修改"></a>Avahi Daemon 配置文件修改</h3><blockquote><p>/etc/avahi/avahi-daemon.conf </p></blockquote><pre><code>domain-name=local</code></pre><p>将这一行的注释符号去除。</p><h3 id="Avahi-Daemon-及-打印机支持添加"><a href="#Avahi-Daemon-及-打印机支持添加" class="headerlink" title="Avahi Daemon 及 打印机支持添加"></a>Avahi Daemon 及 打印机支持添加</h3><p>下载 参考文献 2 中的对应的 Python 脚本，并安装对应支持库。</p><p>请注意，该脚本只支持 Python 2, 安装依赖：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">apt-get</span> update -y <span class="token operator">&amp;&amp;</span> <span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> libxml2-dev$ <span class="token function">sudo</span> pip2 <span class="token function">install</span> pycups$ <span class="token function">sudo</span> pip2 <span class="token function">install</span> lxml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>接下来使用对应的参数将会对所有已经在 CUPSD 中配置好的打印机生成对应的 Avahi 服务并保存到对应目录：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> python2 ./airprint-generate.py -P <span class="token operator">&lt;</span>CUPS 服务器端口号<span class="token operator">></span> -u root -d /etc/avahi/services -p c2a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>重启服务，完成配置</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> systemctl restart avahi-daemon.service$ <span class="token function">sudo</span> systemctl restart org.cups.cupsd.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="Enjoy"><a href="#Enjoy" class="headerlink" title="Enjoy"></a>Enjoy</h2><p>打开连接到同一局域网的苹果设备，尝试打印，你就能看到对应 PC 连接的打印机了。</p><h2 id="Acknowledgement"><a href="#Acknowledgement" class="headerlink" title="Acknowledgement"></a>Acknowledgement</h2><ul><li><a href="https://askubuntu.com/questions/26130/how-can-share-my-printer-so-that-i-can-use-it-with-airprint" target="_blank" rel="noopener">AskUbuntu</a></li><li><a href="https://github.com/tjfontaine/airprint-generate" target="_blank" rel="noopener">Airprint Service Generator</a></li><li><a href="https://ezunix.org/index.php?title=Enable_iOS_AirPrint_with_any_printer_supported_by_CUPS" target="_blank" rel="noopener">EzUnix Tutorial</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Convert-CUPS-Printer-to-Airprint-available&quot;&gt;&lt;a href=&quot;#Convert-CUPS-Printer-to-Airprint-available&quot; class=&quot;headerlink&quot; title=&quot;Convert 
      
    
    </summary>
    
    
      <category term="Tech" scheme="https://www.kmahyyg.xyz/tags/Tech/"/>
    
  </entry>
  
  <entry>
    <title>数据结构实验 4 - 迷宫</title>
    <link href="https://www.kmahyyg.xyz/2018/DS04-Maze-EXP/"/>
    <id>https://www.kmahyyg.xyz/2018/DS04-Maze-EXP/</id>
    <published>2018-10-18T23:57:13.000Z</published>
    <updated>2019-01-04T17:18:57.989Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在最前"><a href="#写在最前" class="headerlink" title="写在最前"></a>写在最前</h1><p>请先阅读 <a href="https://github.com/octowhale/Stop-Ask-Questions-The-Stupid-Ways/blob/master/README.md" target="_blank" rel="noopener">我要提问</a> 之后再看下文。</p><h1 id="数据结构实验-4-迷宫"><a href="#数据结构实验-4-迷宫" class="headerlink" title="数据结构实验 4 - 迷宫"></a>数据结构实验 4 - 迷宫</h1><p>实验代码和实验要求请参见 <a href="https://github.com/kmahyyg/datastru-ynu" target="_blank" rel="noopener">我的 Github 项目 (Private)</a></p><p>本篇博文将更加注重着眼于：</p><ul><li>具体迷宫生成实现</li><li>自动完成迷宫实现</li><li>实现过程中新学到的东西和踩的坑</li></ul><h1 id="stdarg-h"><a href="#stdarg-h" class="headerlink" title="stdarg.h"></a>stdarg.h</h1><h2 id="举一反三：-Python-Non-keyword-Argument"><a href="#举一反三：-Python-Non-keyword-Argument" class="headerlink" title="举一反三： Python - Non-keyword Argument"></a>举一反三： Python - Non-keyword Argument</h2><p>Pass the <strong>variable length argument list with single asterisk</strong>.</p><p>Inside the function, we have a loop which adds the passed argument and prints the result. We passed 3 different tuples with variable length as an argument to the function.</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">adder</span><span class="token punctuation">(</span><span class="token operator">*</span>num<span class="token punctuation">)</span><span class="token punctuation">:</span>    sum <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> n <span class="token keyword">in</span> num<span class="token punctuation">:</span>        sum <span class="token operator">=</span> sum <span class="token operator">+</span> n    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Sum:"</span><span class="token punctuation">,</span>sum<span class="token punctuation">)</span>adder<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span>adder<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span>adder<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>Sum: 8Sum: 22Sum: 17</code></pre><h2 id="举一反三：-Python-Keyword-Argument"><a href="#举一反三：-Python-Keyword-Argument" class="headerlink" title="举一反三： Python - Keyword Argument"></a>举一反三： Python - Keyword Argument</h2><p>Use a <strong>dictionary-like parameters with double asterisk</strong> passed to the function.</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">intro</span><span class="token punctuation">(</span><span class="token operator">**</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\nData type of argument:"</span><span class="token punctuation">,</span>type<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> key<span class="token punctuation">,</span> value <span class="token keyword">in</span> data<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                          <span class="token comment" spellcheck="true"># inside loop</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"{} is {}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span>intro<span class="token punctuation">(</span>Firstname<span class="token operator">=</span><span class="token string">"Sita"</span><span class="token punctuation">,</span> Lastname<span class="token operator">=</span><span class="token string">"Sharma"</span><span class="token punctuation">,</span> Age<span class="token operator">=</span><span class="token number">22</span><span class="token punctuation">,</span> Phone<span class="token operator">=</span><span class="token number">1234567890</span><span class="token punctuation">)</span>intro<span class="token punctuation">(</span>Firstname<span class="token operator">=</span><span class="token string">"John"</span><span class="token punctuation">,</span> Lastname<span class="token operator">=</span><span class="token string">"Wood"</span><span class="token punctuation">,</span> Email<span class="token operator">=</span><span class="token string">"johnwood@nomail.com"</span><span class="token punctuation">,</span> Country<span class="token operator">=</span><span class="token string">"Wakanda"</span><span class="token punctuation">,</span> Age<span class="token operator">=</span><span class="token number">25</span><span class="token punctuation">,</span> Phone<span class="token operator">=</span><span class="token number">9876543210</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>Data type of argument: &lt;class &#39;dict&#39;&gt;Firstname is SitaLastname is SharmaAge is 22Phone is 1234567890Data type of argument: &lt;class &#39;dict&#39;&gt;Firstname is JohnLastname is WoodEmail is johnwood@nomail.comCountry is WakandaAge is 25Phone is 9876543210</code></pre><h2 id="stdarg-h-在-C-中的应用"><a href="#stdarg-h-在-C-中的应用" class="headerlink" title="stdarg.h 在 C 中的应用"></a>stdarg.h 在 C 中的应用</h2><p>建议少用或者尽量不用。</p><h3 id="库变量与库宏"><a href="#库变量与库宏" class="headerlink" title="库变量与库宏"></a>库变量与库宏</h3><p><code>va_list</code> ： 适用于 <code>va_start() va_arg() va_end()</code> 三个宏存储信息的类型，可近似等价于可变链表。</p><p><code>void va_start(va_list ap, last_arg);</code> 初始化 <code>ap</code> 变量，与 <code>va_arg</code> <code>va_end</code> 共同使用，<code>last_arg</code> 是最后一个传递给函数的已知的固定参数，即省略号前的参数。</p><p><code>type va_arg(va_list ap, type);</code> 这个宏检索函数参数列表 <code>va_list ap</code> 中类型为 <code>type</code> 的 <strong>下一个参数</strong> 。 该函数应当理解为 <strong>指针</strong> ，函数返回为 <strong>有序列表中的符合对应类型的最近一个数据</strong>，函数参数以数据结构 <strong>栈</strong> 形式存储，从左向右入栈。</p><p><code>void va_end(va_list ap);</code> 这个宏允许使用了带有 <code>va_start</code> 宏的带有可变参数的函数返回，若函数返回前未调用 <code>va_end</code> ，则结果为 <code>undefined</code>.</p><h3 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h3><p>Compile ： <code>gcc -std=c99 test.c -o test</code></p><p>test.c :</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdarg.h></span></span><span class="token keyword">int</span> <span class="token function">echoinfo</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>strNotice<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> noti<span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">strcpy</span><span class="token punctuation">(</span>noti<span class="token punctuation">,</span><span class="token string">"The printout is"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">echoinfo</span><span class="token punctuation">(</span>noti<span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">echoinfo</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>strNotice<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> <span class="token operator">*</span>str0 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>str1 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>str2 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    va_list stArgv<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// define a param list</span>    <span class="token function">va_start</span><span class="token punctuation">(</span>stArgv<span class="token punctuation">,</span> strNotice<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// pass the fixed param to the function</span>    str0 <span class="token operator">=</span> <span class="token function">va_arg</span><span class="token punctuation">(</span>stArgv<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    str1 <span class="token operator">=</span> <span class="token function">va_arg</span><span class="token punctuation">(</span>stArgv<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    str2 <span class="token operator">=</span> <span class="token function">va_arg</span><span class="token punctuation">(</span>stArgv<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s: %s %s %s"</span><span class="token punctuation">,</span> strNotice<span class="token punctuation">,</span> str0<span class="token punctuation">,</span> str1<span class="token punctuation">,</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">va_end</span><span class="token punctuation">(</span>stArgv<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="迷宫生成"><a href="#迷宫生成" class="headerlink" title="迷宫生成"></a>迷宫生成</h1><p>其实是一个 树/图 的遍历问题，这样也就关联上了两种常用算法：BFS（广度优先搜索）、DFS(深度优先搜索)，实际上就是一个 Single Source Shortest Path 寻找问题。</p><p><img src="https://yygc.zzjnyyz.cn/asset_files/2018-mazegen-01.png" alt="gen-maze.png"></p><p><a href="https://yygc.zzjnyyz.cn/maze_ds04_vid.html" target="_blank" rel="noopener">点击此处查看视频演示</a></p><h2 id="推荐的生成思路"><a href="#推荐的生成思路" class="headerlink" title="推荐的生成思路"></a>推荐的生成思路</h2><p>Once we have a grid filled with walls, we transform it into a maze as follows:</p><ol><li>We pick a random cell</li><li>We select a random neighbouring cell that has not been visited</li><li>We remove the wall between the two cells and add the neighbouring cell to the list of cells having been visited.</li><li>If there are no unvisited neighbouring cell, we backtrack to one that has at least one unvisited neighbour; this is done until we backtrack to the original cell.</li></ol><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>由于之前完全没有接触过这类实现，本次实现将采用 Python 进行一次预实现。</p><p><strong><a href="https://docs.python.org/3/library/stdtypes.html#common-sequence-operations" target="_blank" rel="noopener">Python 多维数组的浅拷贝问题 - 关于列表</a></strong> </p><p><strong><a href="https://docs.python.org/3/faq/programming.html#faq-multidimensional-list" target="_blank" rel="noopener">Python 多维数组的浅拷贝问题 - 官方 FAQ</a></strong></p><p><strong><a href="http://www.runoob.com/python3/python3-func-zip.html" target="_blank" rel="noopener">Python 3 zip() 函数</a></strong></p><h3 id="关于-zip-函数"><a href="#关于-zip-函数" class="headerlink" title="关于 zip 函数"></a>关于 zip 函数</h3><p>定义：<code>zip([iterable, ...])</code></p><p><code>zip()</code> 是 Python 的一个内建函数，它接受一系列可迭代的对象作为参数，将对象中对应的元素打包成一个个 tuple (元组)，然后返回由这些 tuples 组成的 list (列表)。若传入参数的长度不等，则返回 list 的长度和参数中长度最短的对象相同。利用 * 号操作符，可以将 list unzip (解压)，看下面的例子就明白了：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> c <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> zipped <span class="token operator">=</span> zip<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> zip<span class="token punctuation">(</span>a<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> zip<span class="token punctuation">(</span><span class="token operator">*</span>zipped<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="random-randrange"><a href="#random-randrange" class="headerlink" title="random.randrange()"></a>random.randrange()</h3><pre><code>random.randrange(start, stop[, step])Return a randomly selected element from range(start, stop, step). </code></pre><h3 id="random-shuffle"><a href="#random-shuffle" class="headerlink" title="random.shuffle()"></a>random.shuffle()</h3><pre><code>random.shuffle(x[, random])¶Shuffle the sequence x in place.The optional argument random is a 0-argument function returning a random float in [0.0, 1.0); by default, this is the function random().</code></pre><h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>官方的建议：</p><blockquote><p>listA = [[None] *2] *3<br>这样的使用 * 创建的一个列表，并没有创建内部列表的三次拷贝，而是创建了三次同样的链接到内部的列表。所以你如果修改任何一个内部列表，三个外部链接的值也会跟随改变。</p></blockquote><p>正确的做法是：</p><ol><li>使用 <code>numpy</code> 等提供矩阵类型的工具。</li><li>使用下列代码：</li></ol><pre class="line-numbers language-python"><code class="language-python">A <span class="token operator">=</span> <span class="token punctuation">[</span>None<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">3</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>None<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>等价于：</p><pre class="line-numbers language-python"><code class="language-python">w<span class="token punctuation">,</span> h <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span>A <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>None<span class="token punctuation">]</span> <span class="token operator">*</span> w <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="迷宫自动完成"><a href="#迷宫自动完成" class="headerlink" title="迷宫自动完成"></a>迷宫自动完成</h1><p><img src="https://yygc.zzjnyyz.cn/asset_files/2018-mazegen-02.png" alt="autowalk-maze.png"></p><h1 id="编写过程中的实现问题"><a href="#编写过程中的实现问题" class="headerlink" title="编写过程中的实现问题"></a>编写过程中的实现问题</h1><h2 id="Dirty-Workaround-ycomlib-h"><a href="#Dirty-Workaround-ycomlib-h" class="headerlink" title="Dirty Workaround (ycomlib.h)"></a>Dirty Workaround (ycomlib.h)</h2><p>请参考 Github Repo 中的对应文件。</p><h2 id="最大的问题"><a href="#最大的问题" class="headerlink" title="最大的问题"></a>最大的问题</h2><p>Python 预实现过后，进行面向 C 的迁移。很多方面，例如 二维数组的传递、数组 Index 超界、递归超过上限 问题，导致了许多的 SEGV，最后还是没有解决。时间太紧张了，没时间了。整体的思路还算清晰，请参考上面的附图。也欢迎您和我联系，交换您的想法。</p><h1 id="Acknowledgement"><a href="#Acknowledgement" class="headerlink" title="Acknowledgement"></a>Acknowledgement</h1><ul><li><a href="https://docs.python.org/3/" target="_blank" rel="noopener">Python official document list</a></li><li><a href="https://blog.csdn.net/crystal_tyan/article/details/42523861" target="_blank" rel="noopener">Recursive backtracker mtod for maze generation</a></li><li><a href="https://blog.csdn.net/juzihongle1/article/details/73135920" target="_blank" rel="noopener">Three widely used mtod for maze generation</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在最前&quot;&gt;&lt;a href=&quot;#写在最前&quot; class=&quot;headerlink&quot; title=&quot;写在最前&quot;&gt;&lt;/a&gt;写在最前&lt;/h1&gt;&lt;p&gt;请先阅读 &lt;a href=&quot;https://github.com/octowhale/Stop-Ask-Questions-
      
    
    </summary>
    
    
      <category term="Tech" scheme="https://www.kmahyyg.xyz/tags/Tech/"/>
    
      <category term="Datastru" scheme="https://www.kmahyyg.xyz/tags/Datastru/"/>
    
  </entry>
  
  <entry>
    <title>正确提问</title>
    <link href="https://www.kmahyyg.xyz/2018/Ask-Questions/"/>
    <id>https://www.kmahyyg.xyz/2018/Ask-Questions/</id>
    <published>2018-10-18T22:22:23.000Z</published>
    <updated>2019-01-04T17:18:57.989Z</updated>
    
    <content type="html"><![CDATA[<p>送给所有人，也送给我自己：</p><p><strong>提问之前你们 TMD 看一看这些再问好吗！！</strong></p><h2 id="Stop-Ask-Questions-the-Stupid-Way"><a href="#Stop-Ask-Questions-the-Stupid-Way" class="headerlink" title="Stop Ask Questions the Stupid Way"></a>Stop Ask Questions the Stupid Way</h2><ul><li><a href="https://github.com/octowhale/Stop-Ask-Questions-The-Stupid-Ways/blob/master/README.md" target="_blank" rel="noopener">https://github.com/octowhale/Stop-Ask-Questions-The-Stupid-Ways/blob/master/README.md</a></li></ul><h2 id="How-to-Ask-Questions-the-Smart-Way"><a href="#How-to-Ask-Questions-the-Smart-Way" class="headerlink" title="How to Ask Questions the Smart Way"></a>How to Ask Questions the Smart Way</h2><ul><li><a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md" target="_blank" rel="noopener">https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/master/README-zh_CN.md</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;送给所有人，也送给我自己：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提问之前你们 TMD 看一看这些再问好吗！！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;Stop-Ask-Questions-the-Stupid-Way&quot;&gt;&lt;a href=&quot;#Stop-Ask-Questions-
      
    
    </summary>
    
    
      <category term="School" scheme="https://www.kmahyyg.xyz/tags/School/"/>
    
  </entry>
  
  <entry>
    <title>CAMAL 离线下载套件</title>
    <link href="https://www.kmahyyg.xyz/2018/CAMAL-OfflineDL/"/>
    <id>https://www.kmahyyg.xyz/2018/CAMAL-OfflineDL/</id>
    <published>2018-10-18T13:26:19.000Z</published>
    <updated>2019-01-04T17:18:57.989Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>CAMAL 离线下载套件，顾名思义：Caddy + AriaNG + Mldonkey(ED2K) + Aria2(BT+PT+HTTP+FTP+MAGNET) + Linux 用于简单搭建一个离线下载系统。</p><p>上述提到的软件均将运行在 x86_64 架构的计算机上。请在部署时注意您和您所租用的离线下载服务器所在地的法律法规，本人不承担任何相关的法律责任。</p><p>如您需要 不接受 DMCA 争议的离岸服务器，请参考本人最后一个参考文献。</p><h1 id="软件下载与基础部署"><a href="#软件下载与基础部署" class="headerlink" title="软件下载与基础部署"></a>软件下载与基础部署</h1><p>示例环境：Ubuntu 18.04.1 LTS Full Installation via LXC Virtualization</p><ul><li>Caddy Webserver with FileManager</li></ul><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># apt update -y</span><span class="token comment" spellcheck="true"># apt install curl wget ca-certificates -y</span><span class="token comment" spellcheck="true"># curl https://getcaddy.com | bash -s personal http.filemanager,http.forwardproxy,http.ipfilter,http.login,http.minify,http.nobots,http.upload,tls.dns.rfc2136</span>$ <span class="token comment" spellcheck="true"># 编辑配置文件 /etc/Caddyfile</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>启动：<code>nohup caddy -conf /etc/Caddyfile &gt; /dev/null 2&gt;&amp;1 &amp;</code></p><p>关于 CaddyServer 的 systmed 后台守护，请参见 <a href="https://github.com/mholt/caddy/tree/master/dist/init/linux-systemd" target="_blank" rel="noopener">此处</a></p><ul><li><p><a href="https://github.com/mayswind/AriaNg/releases/download/0.5.0/AriaNg-0.5.0.zip" target="_blank" rel="noopener">AriaNG Web前端</a></p></li><li><p>Aria2</p></li></ul><p>推荐使用参考文献中对应的一键脚本直接部署，方便简洁快速。如果您熟悉相关配置，您也可以选择从软件仓库安装之后手动配置。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> apt update -y$ <span class="token function">sudo</span> apt <span class="token function">install</span> aria2 -y$ <span class="token comment" spellcheck="true"># 编辑配置文件</span>$ aria2c -D --conf-path <span class="token operator">&lt;</span>Config <span class="token function">file</span> path<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>一键脚本链接：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/aria2.sh &amp;&amp; chmod +x aria2.sh &amp;&amp; bash aria2.sh</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>MlDonkey</li></ul><p>从软件仓库安装并启动：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> apt update -y$ <span class="token function">sudo</span> apt <span class="token function">install</span> mldonkey-server -y$ <span class="token comment" spellcheck="true"># 编辑系统配置文件 /var/lib/mldonkey/downloads.ini</span>$ <span class="token function">sudo</span> systemctl <span class="token function">enable</span> mldonkey-server$ <span class="token function">sudo</span> systemctl start mldonkey-server<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="部分配置文件"><a href="#部分配置文件" class="headerlink" title="部分配置文件"></a>部分配置文件</h2><p>以下仅展示可运行的最简配置文件，更多详情请参考软件的 Manual Page.</p><p>部分文件由于默认配置过长，仅展示修改过的部分。</p><h3 id="Caddy-Caddyfile"><a href="#Caddy-Caddyfile" class="headerlink" title="Caddy (Caddyfile)"></a>Caddy (Caddyfile)</h3><p>由于一般情况下，对于一些特大文件的传输，在运营商不存在劫持或文件过于冷门，且不存在文件审查的情况下，就使用 HTTP 传输就可以了，没必要对这类文件使用 HTTPS。</p><p><code>/aria</code> 为 AriaNG 入口。</p><pre><code>https://你的回源二级域名 {  root &lt;保存下载路径的上级目录&gt;  redir /aria &lt;AriaNG 的 index.html 相对 root 的路径&gt; 302  timeouts none  gzip  tls &lt;证书&gt; &lt;私钥&gt;  header / {    Strict-Transport-Security &quot;max-age=31536000;&quot;    X-XSS-Protection &quot;1; mode=block&quot;    X-Content-Type-Options &quot;nosniff&quot;    X-Frame-Options &quot;DENY&quot;  }  filemanager &lt;网盘入口相对路径&gt; {    database &lt;网盘数据库文件保存位置&gt;/filemgr.db  }}http://你的CDN加速域名 {  root &lt;保存下载路径的上级目录&gt;  redir /aria &lt;AriaNG 的 index.html 相对路径&gt; 302  timeouts none  gzip  filemanager &lt;网盘入口相对路径&gt; {    database &lt;网盘数据库文件保存位置&gt;/filemgr.db  }}</code></pre><p><strong>请在下载目录下执行运行 Caddy 的命令，以避免一些问题。</strong></p><h3 id="Aria2-aria2-conf"><a href="#Aria2-aria2-conf" class="headerlink" title="Aria2 (aria2.conf)"></a>Aria2 (aria2.conf)</h3><pre><code>## 文件保存相关 ### 文件的保存路径(可使用绝对路径或相对路径), 默认: 当前启动位置dir=&lt;保存下载路径&gt;# 启用磁盘缓存, 0为禁用缓存, 需1.16以上版本, 默认:16Mdisk-cache=32M# 文件预分配方式, 能有效降低磁盘碎片, 默认:prealloc# 预分配所需时间: none &lt; falloc ? trunc &lt; prealloc# falloc和trunc则需要文件系统和内核支持# NTFS建议使用falloc, EXT3/4建议trunc, MAC 下需要注释此项file-allocation=trunc# 断点续传continue=true## 下载连接相关 ### 最大同时下载任务数, 运行时可修改, 默认:5max-concurrent-downloads=5# 同一服务器连接数, 添加时可指定, 默认:1max-connection-per-server=16# 最小文件分片大小, 添加时可指定, 取值范围1M -1024M, 默认:20M# 假定size=10M, 文件为20MiB 则使用两个来源下载; 文件为15MiB 则使用一个来源下载min-split-size=10M# 单个任务最大线程数, 添加时可指定, 默认:5split=20# 整体下载速度限制, 运行时可修改, 默认:0#max-overall-download-limit=0# 单个任务下载速度限制, 默认:0#max-download-limit=0# 整体上传速度限制, 运行时可修改, 默认:0#max-overall-upload-limit=1M# 单个任务上传速度限制, 默认:0#max-upload-limit=1000# 禁用IPv6, 默认:falsedisable-ipv6=false## 进度保存相关 ### 从会话文件中读取下载任务input-file=/root/.aria2/aria2.session# 在Aria2退出时保存`错误/未完成`的下载任务到会话文件save-session=/root/.aria2/aria2.session# 定时保存会话, 0为退出时才保存, 需1.16.1以上版本, 默认:0#save-session-interval=60## RPC相关设置 ### 启用RPC, 默认:falseenable-rpc=true# 允许所有来源, 默认:falserpc-allow-origin-all=true# 允许非外部访问, 默认:falserpc-listen-all=true# 事件轮询方式, 取值:[epoll, kqueue, port, poll, select], 不同系统默认值不同#event-poll=select# RPC监听端口, 端口被占用时可以修改, 默认:6800rpc-listen-port=&lt;修改为你要的端口&gt;# 设置的RPC授权令牌, v1.18.4新增功能, 取代 --rpc-user 和 --rpc-passwd 选项rpc-secret=&lt;远程管理密码&gt;# 设置的RPC访问用户名, 此选项新版已废弃, 建议改用 --rpc-secret 选项#rpc-user=&lt;USER&gt;# 设置的RPC访问密码, 此选项新版已废弃, 建议改用 --rpc-secret 选项#rpc-passwd=&lt;PASSWD&gt;# 是否启用 RPC 服务的 SSL/TLS 加密,# 启用加密后 RPC 服务需要使用 https 或者 wss 协议连接rpc-secure=true# 在 RPC 服务中启用 SSL/TLS 加密时的证书文件(.pem/.crt)rpc-certificate=&lt;CADDY 申请的 TLS 证书文件&gt;# 在 RPC 服务中启用 SSL/TLS 加密时的私钥文件(.key)rpc-private-key=&lt;CADDY 申请的 TLS 证书私钥文件&gt;## BT/PT下载相关 ### 当下载的是一个种子(以.torrent结尾)时, 自动开始BT任务, 默认:truefollow-torrent=true# BT监听端口, 当端口被屏蔽时使用, 默认:6881-6999listen-port=51413# 单个种子最大连接数, 默认:55bt-max-peers=500# 打开DHT功能, PT需要禁用, 默认:trueenable-dht=true# 打开IPv6 DHT功能, PT需要禁用enable-dht6=true# DHT网络监听端口, 默认:6881-6999#dht-listen-port=6881-6999# 本地节点查找, PT需要禁用, 默认:false#bt-enable-lpd=true# 种子交换, PT需要禁用, 默认:trueenable-peer-exchange=true# 每个种子限速, 对少种的PT很有用, 默认:50K#bt-request-peer-speed-limit=50K# 客户端伪装, PT需要peer-id-prefix=-TR2770-user-agent=Transmission/2.77# 当种子的分享率达到这个数时, 自动停止做种, 0为一直做种, 默认:1.0seed-ratio=1.5# 强制保存会话, 即使任务已经完成, 默认:false# 较新的版本开启后会在任务完成后依然保留.aria2文件#force-save=false# BT校验相关, 默认:truebt-hash-check-seed=true# 继续之前的BT任务时, 无需再次校验, 默认:falsebt-seed-unverified=true# 保存磁力链接元数据为种子文件(.torrent文件), 默认:false#bt-save-metadata=truebt-tracker=udp://tracker.coppersurfer.tk:6969/announce,udp://tracker.opentrackr.org:1337/announce,udp://tracker.internetwarriors.net:1337/announce,http://tracker.internetwarriors.net:1337/announce,udp://9.rarbg.to:2710/announce,udp://exodus.desync.com:6969/announce,udp://explodie.org:6969/announce,http://explodie.org:6969/announce,udp://tracker.vanitycore.co:6969/announce,udp://public.popcorn-tracker.org:6969/announce,http://tracker.vanitycore.co:6969/announce,udp://mgtracker.org:6969/announce,http://mgtracker.org:6969/announce,udp://tracker1.itzmx.com:8080/announce,udp://ipv4.tracker.harry.lu:80/announce,http://tracker3.itzmx.com:6961/announce,http://tracker1.itzmx.com:8080/announce,udp://tracker.torrent.eu.org:451/announce,udp://tracker.tiny-vps.com:6969/announce,udp://open.stealth.si:80/announce,udp://tracker.port443.xyz:6969/announce,udp://open.demonii.si:1337/announce,udp://denis.stalker.upeer.me:6969/announce,udp://bt.xxx-tracker.com:2710/announce,http://tracker.port443.xyz:6969/announce,http://open.acgnxtracker.com:80/announce,udp://retracker.lanta-net.ru:2710/announce,http://retracker.telecom.by:80/announce,udp://thetracker.org:80/announce,http://torrent.nwps.ws:80/announce,http://0d.kebhana.mx:443/announce,udp://tracker.uw0.xyz:6969/announce,udp://tracker.cypherpunks.ru:6969/announce,https://tracker.fastdownload.xyz:443/announce,https://opentracker.xyz:443/announce,http://tracker.cypherpunks.ru:6969/announce,http://opentracker.xyz:80/announce,http://open.trackerlist.xyz:80/announce,udp://zephir.monocul.us:6969/announce,udp://tracker.ds.is:6969/announce,wss://ltrackr.iamhansen.xyz:443/announce,udp://tracker2.itzmx.com:6961/announce,udp://tracker.tvunderground.org.ru:3218/announce,udp://tracker.toss.li:6969/announce,udp://tracker.swateam.org.uk:2710/announce,udp://tracker.kamigami.org:2710/announce,udp://tracker.iamhansen.xyz:2000/announce,https://2.track.ga:443/announce,http://wegkxfcivgx.chickenkiller.com:80/announce,http://tracker4.itzmx.com:2710/announce,http://tracker2.itzmx.com:6961/announce,http://tracker.tvunderground.org.ru:3218/announce,http://tracker.torrentyorg.pl:80/announce,http://tracker.city9x.com:2710/announce,http://t.nyaatracker.com:80/announce,http://retracker.mgts.by:80/announce,http://open.acgtracker.com:1096/announce,http://node.611.to:9000/announce,wss://tracker.fastcast.nz:443/announce,wss://tracker.btorrent.xyz:443/announce,udp://tracker.justseed.it:1337/announce,udp://packages.crunchbangplusplus.org:6969/announce,https://1337.abcvg.info:443/announce,http://share.camoe.cn:8080/announce,http://fxtt.ru:80/announce</code></pre><p>将 Aria2NG 解压到网站根目录下，从浏览器访问，然后配置对应 Aria2 本地配置项：</p><ul><li>使用协议</li><li>域名 地址 端口</li><li>RPC 密钥</li></ul><p>即可使用。</p><h3 id="Aria2-trackers-all-txt"><a href="#Aria2-trackers-all-txt" class="headerlink" title="Aria2 (trackers_all.txt)"></a>Aria2 (trackers_all.txt)</h3><p>来源：<a href="https://raw.githubusercontent.com/ngosang/trackerslist/master/trackers_all.txt" target="_blank" rel="noopener">https://raw.githubusercontent.com/ngosang/trackerslist/master/trackers_all.txt</a></p><h3 id="MLdonkey-var-lib-mldonkey-downloads-ini"><a href="#MLdonkey-var-lib-mldonkey-downloads-ini" class="headerlink" title="MLdonkey (/var/lib/mldonkey/downloads.ini)"></a>MLdonkey (/var/lib/mldonkey/downloads.ini)</h3><pre><code>allowed_ips = [&quot;0.0.0.0/0&quot;;] shared_directories = [  {     dirname = shared     strategy = all_files     priority = 0};  {     dirname = &quot;&lt;下载文件保存目录&gt;&quot;     strategy = incoming_files     priority = 0};  {     dirname = &quot;incoming/directories&quot;     strategy = incoming_directories     priority = 0};]</code></pre><p>保存目录可以自由修改，需要注意文件夹权限问题。</p><h3 id="MLDonkey-的进一步配置"><a href="#MLDonkey-的进一步配置" class="headerlink" title="MLDonkey 的进一步配置"></a>MLDonkey 的进一步配置</h3><p>在完成上面的配置之后，我们来添加管理员账户并设置一个普通用户。</p><p>同时对 ED2K 服务器列表 server.met 进行一次更新。</p><pre class="line-numbers language-bash"><code class="language-bash">$ telnet localhost 4000<span class="token operator">></span> <span class="token function">useradd</span> admin <span class="token operator">&lt;</span>你的管理员密码<span class="token operator">></span><span class="token operator">></span> quit$ <span class="token function">sudo</span> systemctl restart mldonkey-server$ telnet localhost 4000<span class="token operator">></span> auth admin <span class="token operator">&lt;</span>你的管理员密码<span class="token operator">></span><span class="token operator">></span> d http://ed2k.2x4u.de/v1s4vbaf/max/server.met<span class="token operator">></span> <span class="token function">useradd</span> 普通用户名 普通用户密码<span class="token operator">></span> quit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>经过上述设置之后，你可以通过 <code>http://&lt;你的IP&gt;:4080</code> 来登陆 WebUI 进行下载了。</p><p>注意每次拷贝下载完成的文件之前要去 WebUI 右上角命令框里输入一次 <code>commit</code>.</p><h4 id="MLDonkey-忘记管理员密码"><a href="#MLDonkey-忘记管理员密码" class="headerlink" title="MLDonkey 忘记管理员密码"></a>MLDonkey 忘记管理员密码</h4><p><code>/var/lib/mldonkey/users.ini</code> 里：</p><p>将对应 <code>user_name = admin</code> 的 <code>user_pass</code> 清空后重启服务。</p><h2 id="关于后台进程守护"><a href="#关于后台进程守护" class="headerlink" title="关于后台进程守护"></a>关于后台进程守护</h2><p>建议参考 阮一峰老师的 Systemd 相关教程和 计算器启动 与 后台守护相关文章</p><ul><li><p><a href="http://www.ruanyifeng.com/blog/2016/02/linux-daemon.html" target="_blank" rel="noopener">Linux 后台守护</a></p></li><li><p><a href="http://www.ruanyifeng.com/blog/2013/02/booting.html" target="_blank" rel="noopener">计算机是如何启动的</a></p></li><li><p><a href="http://www.ruanyifeng.com/blog/2013/08/linux_boot_process.html" target="_blank" rel="noopener">Linux 是如何启动的</a></p></li></ul><blockquote><p>Unix 哲学: Keep simple, keep stupid.</p></blockquote><ul><li><p><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html" target="_blank" rel="noopener">Systemd Commands</a></p></li><li><p><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html" target="_blank" rel="noopener">Systemd Services</a></p></li><li><p><a href="http://www.ruanyifeng.com/blog/2018/03/systemd-timer.html" target="_blank" rel="noopener">Systemd Timer (You could also use crontab)</a></p></li></ul><p>如果你想学习更多的内容，也欢迎你前往 <a href="https://wiki.archlinux.org/" target="_blank" rel="noopener">Arch Linux Wiki</a> 那里有最详细的人类友好型文档，Arch Wiki 中的大多数内容对基于 Systemd 的发行版均是适用的。</p><h1 id="CDN-中转加速"><a href="#CDN-中转加速" class="headerlink" title="CDN 中转加速"></a>CDN 中转加速</h1><h2 id="准备域名"><a href="#准备域名" class="headerlink" title="准备域名"></a>准备域名</h2><p>如果你还没有域名，你需要注册一个域名，个人推荐 <a href="https://www.namesilo.com/register.php?rid=bd46d72xg" target="_blank" rel="noopener">NameSilo</a> ，便宜，附送 WHOIS 隐私保护，支持支付宝。</p><p>然后建议将域名托管到 <a href="https://dns.he.net" target="_blank" rel="noopener">https://dns.he.net</a> ，分别添加一个指向 @ 和 www 的 A 记录。再添加一个 cf_www 和 回源二级域名 的 A 记录。</p><p>注册一个 Cloudflare 账户，注册完成后不做任何配置。</p><h2 id="CNAME-接入-Cloudflare-加速"><a href="#CNAME-接入-Cloudflare-加速" class="headerlink" title="CNAME 接入 Cloudflare 加速"></a>CNAME 接入 Cloudflare 加速</h2><ol><li>寻找一家 Cloudflare Partner，并确保您的域名 <strong>没有</strong> 在 Cloudflare 注册过或正在处于 Cloudflare 服务之下。</li><li>按照提示添加域名，之后按照 Partner 提示设置 www 记录的回源地址为 cf_www 地址。</li><li>添加一个 CDN 加速域名，此 CDN 加速域名的回源地址指向 回源二级域名 地址。</li><li>前往您的域名托管商，本例中是 HE，添加一个 CNAME 记录，从 CDN 加速域名 指向 <code>cdn.cf-a.x-gslb.com</code> 或者 <code>cdn.cf-b.x-gslb.com</code> 。</li><li>通过 CDN 加速域名下载文件即可。</li></ol><h1 id="完"><a href="#完" class="headerlink" title="完"></a>完</h1><p>还有问题？请使用评论框。</p><p>公告：本站评论 <strong>不对</strong> 使用中国大陆 IP 地址访问本站的用户开放。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://caddyserver.com/docs" target="_blank" rel="noopener">Caddy Server Documentation</a></li><li><a href="https://doub.io/goflyway-jc3/" target="_blank" rel="noopener">Doubi Location</a></li><li><a href="https://www.dcc.cat/cloudflare/" target="_blank" rel="noopener">Cloudflare $5000 Route</a></li><li><a href="https://dns.he.net/" target="_blank" rel="noopener">HE.net DNS</a></li><li><a href="https://doub.io/jzzy-3/" target="_blank" rel="noopener">Caddy Filemanager</a></li><li><a href="https://doub.io/shell-jc4/" target="_blank" rel="noopener">Aria 2 Onekey Script</a></li><li><a href="https://github.com/mayswind/AriaNg" target="_blank" rel="noopener">AriaNG WebUI</a></li><li><a href="http://mldonkey.sourceforge.net/Allowed_ips" target="_blank" rel="noopener">MLDonkey Config</a></li><li><a href="https://secure.hostsolutions.ro/aff.php?aff=513&amp;pid=271" target="_blank" rel="noopener">Hostsolutions Anti-DMCA VPS</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;CAMAL 离线下载套件，顾名思义：Caddy + AriaNG + Mldonkey(ED2K) + Aria2(BT+PT+HTTP+F
      
    
    </summary>
    
    
      <category term="Tech" scheme="https://www.kmahyyg.xyz/tags/Tech/"/>
    
  </entry>
  
  <entry>
    <title>KMP 与 BF 字符串模式匹配算法简析</title>
    <link href="https://www.kmahyyg.xyz/2018/KMP-BF-DataStru/"/>
    <id>https://www.kmahyyg.xyz/2018/KMP-BF-DataStru/</id>
    <published>2018-10-17T13:29:29.000Z</published>
    <updated>2019-01-04T17:18:57.989Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字符串模式匹配算法"><a href="#字符串模式匹配算法" class="headerlink" title="字符串模式匹配算法"></a>字符串模式匹配算法</h1><p>这里讨论两种常见的字符串模式匹配算法，不讨论字符串的预处理。</p><p>关于对字符串进行搜索，请参考 <a href="https://zh.m.wikipedia.org/wiki/Boyer-Moore%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">Boyer-Moore 字符串搜索算法 (Wikipedia CN)</a></p><p>另外建议大家阅读 [Sunday 算法]</p><h2 id="BF-算法-Brute-Force"><a href="#BF-算法-Brute-Force" class="headerlink" title="BF 算法 (Brute Force)"></a>BF 算法 (Brute Force)</h2><p>返回子串 Ptn 在主串 Tag 的第 pos 个字符后(含第 pos 个位置)第一次出现的位置，若不存在，则返回 -1，这里的位置全部以从 0 开始计算为准，其中 T 非空，0 &lt;= pos &lt;= Tlen。</p><p>使用 i 标记当前在 Tag 中匹配的字符的位置，初始值为 pos。 使用 j 标记 Ptn 中正在等待比较的位置，初始值为 0,下同。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">index</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>Tag<span class="token punctuation">,</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>Ptn<span class="token punctuation">,</span><span class="token keyword">int</span> pos<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>即对 Tag 的每一个字符与 Ptn 的字符进行逐字比较：</p><ul><li>若完整匹配则返回匹配成功的 pos 值。</li><li>匹配过程中，对当前的 pos 值对应位置之后的每一字符进行 Ptn 的匹配，出现不符合的情况，则将 i 置为 pos + 1，j 置为 0；从当前 pos 值对应的下一个字符开始从头对 Ptn 进行匹配。</li><li>若扫描完整个 Tag 都无法匹配，返回 -1.</li></ul><p>该算法在最坏情况下的时间复杂度为 O(len(P)*len(T))，另外该算法的空间复杂度为 O(1)。</p><h2 id="KMP-算法-Kruth-Morris-Pratt"><a href="#KMP-算法-Kruth-Morris-Pratt" class="headerlink" title="KMP 算法 (Kruth-Morris-Pratt)"></a>KMP 算法 (Kruth-Morris-Pratt)</h2><p>上述算法的时间复杂度为乘积关系，是由于索引指针回溯引起的，针对上述不足，有了 KMP 算法。 KMP 算法的时间复杂度为 O(len(P)+len(T))，空间复杂度为 O(len(P))。这个算法改进的地方在于，不需要过度回溯索引指针 i，而是利用部分匹配结果尽可能的向远滑动，继续进行回溯。</p><h3 id="算法示例"><a href="#算法示例" class="headerlink" title="算法示例"></a>算法示例</h3><p>Step 0: 比较开始。</p><pre><code>     00000000001111111111222i:   01234567890123456789012Tag: ABC ABCDAB ABCDABCDABDEPtn: ABCDABDj:   0123456</code></pre><p>Step 1: 从头比较，比较到 Tag[3] = ‘ ‘ 时发现与 Ptn[3] = ‘D’ 不符。我们已知 Tag[1~3] 与 Ptn[0] 不符，接下来略过这些字符，令 i = 4, j = 0</p><pre><code>     00000000001111111111222i:   01234567890123456789012Tag: ABC ABCDAB ABCDABCDABDEPtn:     ABCDABDj:       0123456</code></pre><p>Step 2：这时我们继续检索 Tag，发现仍不匹配，但是 Tag[8~9] 对应的 ‘AB’ 出现了两次，故可以作为下次比较的起始点，我们令 i = 8, j = 2，继续比较。</p><pre><code>     00000000001111111111222i:   01234567890123456789012Tag: ABC ABCDAB ABCDABCDABDEPtn:         ABCDABDj:           0123456</code></pre><p>Step 3：到 i = 10 时，此时我们放弃比较重复内容，比较 i = 10 与 j = 2 发现出现不符。接下来，由于 ‘AB’ 重复出现，我们从 i = 11, j = 0 开始比较。</p><pre><code>     00000000001111111111222i:   01234567890123456789012Tag: ABC ABCDAB ABCDABCDABDEPtn:            ABCDABDj:              0123456</code></pre><p>Step 4：到 i = 17, j = 6 出现不相同异常，我们采取一贯的做法，令 i = 15, j = 2 继续搜索。</p><pre><code>     00000000001111111111222i:   01234567890123456789012Tag: ABC ABCDAB ABCDABCDABDEPtn:                ABCDABDj:                  0123456</code></pre><p>Step 5：此时我们找到完全匹配的字符串，初始位置为 15, 返回 i。比较结束。</p><h3 id="失配函数"><a href="#失配函数" class="headerlink" title="失配函数"></a><strong>失配函数</strong></h3><p>特殊情况：当一个失配出现在模式串的此次匹配最开始，此时无法回退，我们置 j = -1，跳到模式串的开头字符。</p><p>关键：建立 next 表。</p><h4 id="理清匹配过程"><a href="#理清匹配过程" class="headerlink" title="理清匹配过程"></a>理清匹配过程</h4><p>假设现在文本串 Tag 匹配到 i 位置，模式串 Ptn 匹配到 j 位置：</p><ul><li>如果 j == -1 或当前字符匹配成功（即 Tag[i] == Ptn[j]），都令 i++，j++，继续匹配下一个字符；</li><li>如果当前字符匹配失败（即 Tag[i] != Ptn[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串 Ptn 相对于文本串 Tag 向右移动了 (j - next [j]) 位。<br>换言之，当匹配失败时，模式串向右移动的位数为： <strong>失配字符所在位置 - 失配字符对应的 next 值（next 数组的求解会在下文中详细阐述），即移动的实际位数为：(j - next[j])</strong> ，且此值大于等于 1。</li></ul><p>很快，你也会意识到 next 数组各值的含义：代表当前字符之前的字符串中，有多大长度的相同前缀后缀。例如如果 next [j] = k，代表 j 之前的字符串中有最大长度为 k 的相同前缀后缀。</p><ul><li>这也意味着在某个字符失配时，该字符对应的 next 值会告诉你下一步匹配中，模式串应该跳到哪个位置（跳到 next [j] 的位置）。如果 next [j] 等于 0，则跳到模式串的开头字符，若 next [j] = k 且 k &gt; 0，代表下次匹配跳到 j 之前的某个字符，而不是跳到开头，且具体跳过了 k 个字符。</li></ul><p>这里，我们明确一点，next 表的产生实际只与 <strong>模式串及其子串</strong> 有关。</p><h4 id="关于-Next-表的建立"><a href="#关于-Next-表的建立" class="headerlink" title="关于 Next 表的建立"></a>关于 Next 表的建立</h4><ol><li>寻找前缀后缀的公共元素最大长度</li></ol><p>对于 Ptn = p0 p1 … pj ，寻找 Ptn 中长度最大且相等的前缀和后缀。若存在 p0 p1 … pk = p(j-k) p(j-k+1)… pj，那么在包含 pj 的模式串中有最大长度为 k+1 的相同前缀和后缀。</p><ol start="2"><li>求 next 数组</li></ol><p>next 数组考虑的是除当前字符外的最长相同前缀后缀，所以通过第 ① 步骤求得各个前缀后缀的公共元素的最大长度后，只要稍作变形即可：将第 ① 步骤中求得的值整体右移一位，然后初值赋为 -1 。</p><ol start="3"><li>根据 next 数组进行匹配 </li></ol><p>匹配失配，j = next[j] ，模式串向右移动 j - next[j] 位。即当 模式串的后缀 p(j-k) p(j-k+1) … p(j-1) 和 源串 s(i-k) s(i-k+1) … s(i-1) 匹配成功，但最后一位 pj 和 si 匹配失败的时候，因为 next[j] = k，等价于 <strong>在不包含 pj 的模式串中有最大公共长度为 k 的前缀后缀，即 p0 p1 … p(k-1) = p(j-k+) p(j-k+1) … p(j-1)</strong> ，接下来我们令 j = next[j] ，从而让字符串右移 next[j] 位，此时模式串的最大长度公共前缀 p0 p1 … p(k-1) 对应这 s(i-k) s(i-k+1) … s(i-1), 实现了跳过公共前后缀的匹配，直接匹配 pk 和 si 继续匹配。</p><h3 id="学习之后实验"><a href="#学习之后实验" class="headerlink" title="学习之后实验"></a>学习之后实验</h3><pre><code>原字符串 TAG： BBC ABCDAB ABCDABCDABDE匹配模式串 PTN:               ABCDABD</code></pre><ol><li>寻找最长前缀后缀</li></ol><table><thead><tr><th style="text-align:center">子串</th><th style="text-align:center">前缀</th><th style="text-align:center">后缀</th><th style="text-align:center">最大公共元素长度</th></tr></thead><tbody><tr><td style="text-align:center">A</td><td style="text-align:center">/</td><td style="text-align:center">/</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">AB</td><td style="text-align:center">A</td><td style="text-align:center">B</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">ABC</td><td style="text-align:center">A,AB</td><td style="text-align:center">C,BC</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">ABCD</td><td style="text-align:center">A,AB,ABC</td><td style="text-align:center">D,CD,BCD</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">ABCDA</td><td style="text-align:center"><font color="red">A</font>,AB,ABC,ABCD</td><td style="text-align:center"><font color="red">A</font>,DA,CDA,BCDA</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">ABCDAB</td><td style="text-align:center">A,<font color="red">AB</font>,ABCD,ABCDA</td><td style="text-align:center">B,<font color="red">AB</font>,DAB,CDAB,BCDAB</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">ABCDABD</td><td style="text-align:center">A,AB,ABC,ABCD,ABCDA,ABCDAB</td><td style="text-align:center">D,BD,ABD,DABD,CDABD,BCDABD</td><td style="text-align:center">0</td></tr></tbody></table><p>对应生成的公共元素最大长度表如下：</p><table><thead><tr><th>字符</th><th>A</th><th>B</th><th>C</th><th>D</th><th>A</th><th>B</th><th>D</th></tr></thead><tbody><tr><td>最大前缀后缀公共元素长度</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>2</td><td>0</td></tr></tbody></table><ol start="2"><li>基于最大长度表生成 NEXT 表</li></ol><p>原来 next 数组的求解竟然如此简单：就是找最大对称长度的前缀后缀，然后整体右移一位，初值赋为-1（当然，你也可以直接计算某个字符对应的next值，就是 <strong>看这个字符之前的字符串中有多大长度的相同前缀后缀</strong>）</p><table><thead><tr><th>模式串子串</th><th>A</th><th>B</th><th>C</th><th>D</th><th>A</th><th>B</th><th>D</th></tr></thead><tbody><tr><td>NEXT</td><td>-1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>2</td></tr></tbody></table><blockquote><p>备注：这里其实 next[A0] == -1，意在告诉程序当一开始模式串第一个字符与文本串就不匹配时，可以放弃此次匹配，直接将模式串不断右移一位开始下一次匹配。</p></blockquote><ol start="3"><li>初始匹配</li></ol><pre><code>原字符串 TAG： BBC ABCDAB ABCDABCDABDE匹配模式串 PTN:    ABCDABD</code></pre><p>这里，我们从一开始就发现没有匹配的字符，于是不断后移一位。移动到 i = 4 时，与第五个字符 A 匹配成功，接下来，一直向下匹配，匹配到 j = 6 （字母 D2）时，发生失配。这时将模式串后移，后移 j = j - next[D2] = 6 - 2 = 4 位。</p><ol start="4"><li>第二次匹配</li></ol><pre><code>原字符串 TAG： BBC ABCDAB ABCDABCDABDE匹配模式串 PTN:        ABCDABD</code></pre><p>这里，移动到 i = 8 时，与第九个字符 A 匹配成功，接下来，一直向下匹配，匹配到 j = 2 （字母 C）时，发生失配。这时将模式串后移，后移 j = j - next[C] = 2 - 0 = 2 位。</p><ol start="5"><li>第三次匹配， (TAG[10] = ‘ ‘) != (PTN[0] == ‘A’)，后移 j = j - next[A1] = 0 - (-1) = 1 位。</li></ol><pre><code>原字符串 TAG： BBC ABCDAB ABCDABCDABDE匹配模式串 PTN:          ABCDABD</code></pre><ol start="6"><li>第四次匹配， (TAG[17] = ‘C’) != (PTN[6] == ‘D’)，后移 j = j - next[D2] = 6 - 2 = 4 位。</li></ol><pre><code>原字符串 TAG： BBC ABCDAB ABCDABCDABDE匹配模式串 PTN:           ABCDABD</code></pre><ol start="7"><li>第五次匹配， 匹配成功。</li></ol><pre><code>原字符串 TAG： BBC ABCDAB ABCDABCDABDE匹配模式串 PTN:               ABCDABD</code></pre><h3 id="关于逍爷的讲解"><a href="#关于逍爷的讲解" class="headerlink" title="关于逍爷的讲解"></a>关于逍爷的讲解</h3><p>试比较：</p><p>失配时，模式串向右移动的位数为：失配字符所在<strong>位置</strong> - 失配字符对应的 next 值</p><p>失配时，模式串向右移动的位数为：<strong>已匹配字符数 - 失配字符的上一位字符所对应的最大长度值</strong></p><p>其实二者等价，只不过讲法不同罢了。</p><p>根据《最大长度表》，失配时，模式串向右移动的位数 = 已经匹配的字符数 - 失配字符的上一位字符的最大长度值。</p><p>而根据《next 数组》，失配时，模式串向右移动的位数 = 失配字符的位置 - 失配字符对应的 next 值。</p><p>其中，从 0 开始计数时，失配字符的位置 = 已经匹配的字符数（失配字符不计数），而失配字符对应的next 值 = 失配字符的上一位字符的最大长度值，两相比较，结果必然完全一致。</p><h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><h3 id="BF"><a href="#BF" class="headerlink" title="BF"></a>BF</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">ViolentMatch</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> p<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> sLen <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> pLen <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> sLen <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> pLen<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//①如果当前字符匹配成功（即 Tag[i] == Ptn[j]），则 i++，j++    </span>            i<span class="token operator">++</span><span class="token punctuation">;</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//②如果失配（即 Tag[i]! = Ptn[j]），令i = i - (j - 1)，j = 0    </span>            i <span class="token operator">=</span> i <span class="token operator">-</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//匹配成功，返回模式串 Ptn 在文本串 Tag 中的位置，否则返回 -1</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> pLen<span class="token punctuation">)</span>        <span class="token keyword">return</span> i <span class="token operator">-</span> j<span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">KmpSearch</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> p<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> sLen <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> pLen <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> sLen <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> pLen<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//①如果当前字符匹配成功（即 Tag[i] == Ptn[j]），都令 i++，j++    </span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//②如果当前字符匹配失败（即 Tag[i] != Ptn[j]），则令 i 不变，j = next[j]    </span>            <span class="token comment" spellcheck="true">//next[j]即为j所对应的next值      </span>            j <span class="token operator">=</span> next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> pLen<span class="token punctuation">)</span>        <span class="token keyword">return</span> i <span class="token operator">-</span> j<span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="改进后的-Next-数组的递归生成"><a href="#改进后的-Next-数组的递归生成" class="headerlink" title="改进后的 Next 数组的递归生成"></a>改进后的 Next 数组的递归生成</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">GetNextval</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> next<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> pLen <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    next<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> pLen <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//p[k]表示前缀，p[j]表示后缀  </span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> p<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> p<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token operator">++</span>j<span class="token punctuation">;</span>            <span class="token operator">++</span>k<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//较之前next数组求法，改动在下面4行</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> p<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span>                next<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> k<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//之前只有这一行</span>            <span class="token keyword">else</span>                <span class="token comment" spellcheck="true">//因为不能出现p[j] = p[(next[j])]，所以当出现时需要继续递归，k = next[k] = next[next[k]]</span>                next<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> next<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            k <span class="token operator">=</span> next<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="拓展延伸：-Sunday-算法"><a href="#拓展延伸：-Sunday-算法" class="headerlink" title="拓展延伸： Sunday 算法"></a>拓展延伸： Sunday 算法</h2><h3 id="Boyer-Moore-算法"><a href="#Boyer-Moore-算法" class="headerlink" title="Boyer-Moore 算法"></a>Boyer-Moore 算法</h3><p>略显复杂，略去不提，看文章开头有 Wikipedia 链接，也是一个改进算法。</p><p>该算法从模式串的尾部开始匹配，且拥有在最坏情况下O(N)的时间复杂度。在实践中，比KMP算法的实际效能高。</p><p>BM算法定义了两个规则：</p><p>坏字符规则：当文本串中的某个字符跟模式串的某个字符不匹配时，我们称文本串中的这个失配字符为坏字符，此时模式串需要向右移动，移动的位数 = 坏字符在模式串中的位置 - 坏字符在模式串中最右出现的位置。此外，如果”坏字符”不包含在模式串之中，则最右出现位置为-1。</p><p>好后缀规则：当字符失配时，后移位数 = 好后缀在模式串中的位置 - 好后缀在模式串上一次出现的位置，且如果好后缀在模式串中没有再次出现，则为-1。</p><h3 id="Sunday-算法"><a href="#Sunday-算法" class="headerlink" title="Sunday 算法"></a>Sunday 算法</h3><p>上文中，我们已经介绍了 <code>KMP</code> 算法和 <code>BM</code> 算法，这两个算法在最坏情况下均具有线性的查找时间。但实际上， <code>KMP</code> 算法并不比最简单的 <code>C</code> 库函数 <code>strstr()</code> 快多少，而 <code>BM</code> 算法虽然通常比 <code>KMP</code> 算法快，但 <code>BM</code> 算法也还不是现有字符串查找算法中最快的算法，本文最后再介绍一种比 <code>BM</code> 算法更快的查找算法即 <code>Sunday</code> 算法。</p><p>Sunday 算法由 Daniel M.Sunday 在 1990 年提出，它的思想跟 BM 算法很相似：</p><p>只不过 Sunday 算法是从前往后匹配，在匹配失败时关注的是文本串中参加匹配的最末位字符的下一位字符。如果该字符没有在模式串中出现则直接跳过，即移动位数 = 匹配串长度 + 1；否则，其移动位数 = 模式串中最右端的该字符到末尾的距离 + 1。</p><p>下面举个例子说明下 Sunday 算法。假定现在要在文本串 “substring searching algorithm” 中查找模式串 “search” 。</p><ol><li>刚开始时，把模式串与文本串左边对齐：</li></ol><pre><code>substring searching algorithmsearch^</code></pre><ol start="2"><li>结果发现在第 2 个字符处发现不匹配，不匹配时关注文本串中参加匹配的最末位字符的下一位字符，即标粗的字符 i，因为模式串 search 中并不存在 i，所以模式串直接跳过一大片，向右移动位数 = 匹配串长度 + 1 = 6 + 1 = 7，从 i 之后的那个字符（即字符 n ）开始下一步的匹配，如下图：</li></ol><pre><code>substring searching algorithm　　　     search　　　　 ^</code></pre><ol start="3"><li>结果第一个字符就不匹配，再看文本串中参加匹配的最末位字符的下一位字符，是 ‘r’ ，它出现在模式串中的倒数第 3 位，于是把模式串向右移动 3 位（ r 到模式串末尾的距离 + 1 = 2 + 1 = 3 ），使两个 ‘r’ 对齐，如下：</li></ol><pre><code>substring searching algorithm　　　　        search　　　　　　　   ^</code></pre><ol start="4"><li>匹配成功。</li></ol><p>回顾整个过程，我们只移动了两次模式串就找到了匹配位置，缘于 Sunday 算法每一步的移动量都比较大，效率很高。完。</p><h2 id="一点点碎碎念"><a href="#一点点碎碎念" class="headerlink" title="一点点碎碎念"></a>一点点碎碎念</h2><p>学院现在的课程设置问题非常严重，图灵机、有限状态自动机、算法优化、通信原理、量子物理各方面的课程缺乏严重，导致学生学习专业课程时出现了极大的知识断层，课外各种杂事颇多，时间非常紧张，需要学生花大量课后时间充电。</p><p>本来计算机相关行业，知识更新速度快，入门门槛高、相对复杂，基础知识要求广泛，现在却这样，大学真的很忙。每天都是高压锅生活。为了光明的未来和亲爱的钰，还是更加努力吧！</p><p>关于昨天的汇编文章：其实用什么平台并不重要，作为入门者，你需要明白的只是老师为什么让你这样做，这样做背后的计算机原理是什么。在具体实践上，如何把本来 Windows 上的东西尽量在 Linux 上完美复现或者找到替代品。这样就好了。我知道 Windows 开发的公司仍然是绝大多数，但是在 Linux 平台写代码给了很多人一种专注于代码实现本身的感觉（虽然初始状态的学习曲线非常抖），不用像 Windows 一样各种折腾环境。更何况，Arch Linux 的系统设计注重代码正确、优雅和极简主义，期待用户能够愿意去理解系统的操作，这样的系统正是我们有一点点基础的初学者所需要的。日常用 Linux 多学点底层的东西同时又提高效率又何妨？</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><p><a href="https://blog.csdn.net/ns_code/article/details/19286279" target="_blank" rel="noopener">https://blog.csdn.net/ns_code/article/details/19286279</a></p></li><li><p><a href="https://zh.m.wikipedia.org/zh-cn/%E5%85%8B%E5%8A%AA%E6%96%AF-%E8%8E%AB%E9%87%8C%E6%96%AF-%E6%99%AE%E6%8B%89%E7%89%B9%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">https://zh.m.wikipedia.org/zh-cn/%E5%85%8B%E5%8A%AA%E6%96%AF-%E8%8E%AB%E9%87%8C%E6%96%AF-%E6%99%AE%E6%8B%89%E7%89%B9%E7%AE%97%E6%B3%95</a></p></li><li><p><a href="http://saturnman.blog.163.com/blog/static/5576112010969957130/" target="_blank" rel="noopener">http://saturnman.blog.163.com/blog/static/5576112010969957130/</a></p></li><li><p><a href="https://blog.csdn.net/v_july_v/article/details/7041827" target="_blank" rel="noopener">https://blog.csdn.net/v_july_v/article/details/7041827</a>    Strongly Recommended</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;字符串模式匹配算法&quot;&gt;&lt;a href=&quot;#字符串模式匹配算法&quot; class=&quot;headerlink&quot; title=&quot;字符串模式匹配算法&quot;&gt;&lt;/a&gt;字符串模式匹配算法&lt;/h1&gt;&lt;p&gt;这里讨论两种常见的字符串模式匹配算法，不讨论字符串的预处理。&lt;/p&gt;
&lt;p&gt;关于对字
      
    
    </summary>
    
    
      <category term="Tech" scheme="https://www.kmahyyg.xyz/tags/Tech/"/>
    
      <category term="Datastru" scheme="https://www.kmahyyg.xyz/tags/Datastru/"/>
    
  </entry>
  
</feed>
