---
title: 数据结构与算法课程 - Chap 9 查找
date: 2019-01-05T20:00:44
description: "数据结构与算法课程期末复习记录 Chapter 9"
featuredImage: "https://alicdn.kmahyyg.xyz/asset_files/aether/cat_school.webp"
categories: ["school"]
draft: false
displayInMenu: false
displayInList: true
dropCap: false
---

# 数据结构复习 - Chapter 9 查找

## 基本概念

查找表是由同一类型的具有相同可辨认特性/属性的数据元素（或记录）构成的集合。查找操作的数据结构。

基础操作：
- 查询是否在表
- 查询数据属性
- 插入数据元素
- 删除数据元素

根据是否修改查找表，分为 静态查找表 和 动态查找表 。

平均查找长度 Average Search Length：关键字对应的期望值 之和 = 第 i 个关键字 == 给定值时经过的比较次数 × 查找表中第 i 个记录的概率。

## 静态查找
 
### 静态顺序查找

1. 逐个比较
2. 数组第 0 位存储最后一个数据元素，称为 “监视哨”，避免每步都去判断是否结束。

ASL：

> Part 1: 查找成功 `n+1/2`
> Part 2: 查找失败 `n+1`
> Total: `3(n+1)/4`

### 静态二分查找 Bisect

1. low=0,high=n,mid=(low+high)/2
2. 待查找 key < mid, high = mid - 1，重新计算 mid
3. 待查找 key > mid, low = mid + 1，重新计算 mid
4. 直到 mid == key (成功) 或 low/high == mid != key (失败)

mid 作为根节点，左子区间作为左子树，右子区间作为右子树，建立判定树。

**具有n个结点的完全二叉树的高度为 `[log2n] + 1` **

ASL = `(1+1/n)log2(n+1)`

### 静态分块查找

特点：块间有序，块内无序。

索引表的建立： `MAX KEY | POINTER`, `POINTER` -> 索引表中的各项关键字有序，指针指向块内的第一个记录的位置。

稠密索引：数据表中的一个对象对应一个索引， **不一定** 有序存放。

步骤：确定待查记录所在块，再在块内查找。

分块查找的 ASL 取决于 查找所在块 的算法：

数据表长为 n 均分成 b 块，每块含 s 个记录，每块查找的概率： 1/b，每个记录的查找概率是 1/s。

- 顺序查找： `1/2 * (n/s + s) + 1`
- 二分查找： `log2(b+1) - 1 + (s+1)/2`

分块查找的 ASL：小于顺序、大于二分。

## 动态查找

### 动态查找表

特点：表结构在查找过程中，存在则返回，不存在则插入

#### 二叉排序树

左子树 < 根节点，右子树 > 根节点

查找：从根节点出发，直至找到。否则逐层向下直至指空。

插入：空树则直接插入为根节点，非空则比较后插入。

**中序遍历** 可得到关键字的有序序列

删除： 左右子树都存在时，用直接前驱或者直接后继取代。其他则直接继承。

#### 平衡二叉树 AVL

重点：左右子树平衡，深度之差绝对值 <= 1

节点的数据域： 左右子树深度之差，只能取 0、1、-1，否则不平衡

查找性能：复杂度 O(log2n)

##### 平衡旋转

在左子树的左子树插入 左边过剩： LL 平衡旋转： 最上方节点顺时针旋转 pi/2。
在右子树的右子树插入 右边过剩： RR 平衡旋转： 最上方节点逆时针旋转 pi/2。
在左子树的右子树插入： LR 平衡旋转： 最上方节点做 LL 旋转，新插入的节点成为新根。
在右子树的左子树插入： RL 平衡旋转： 最上方节点做 RR 旋转，新插入的节点成为新根。

### B- Tree

至多有 m 棵子树，共计 m 阶， m 分叉，是一种二叉查找树的推广。

非终端节点： `关键字个数 | 子树根节点指针Pk | 关键字 Ki`，每一棵子树的 Pk 中的所有关键字小于 Ki 元素。

插入： 根据定义判断是否大于 m 分叉，大于则分裂为新节点。根据定义判断即可。

删除： 合并子节点至双亲节点（如果必要）。保证符合定义。

### B+ Tree

n 棵子树的节点含有 n 个关键字，是一种多路索引表的体现。

所有关键字都在叶子节点的链节点出现，中间节点仅作为索引指针。

### 哈希表

存储位置由 Hash 函数计算得知，数字关键字的常用构造方法：

- 直接定址：地址 == ax+b
- 数字分析：各种符号出现的频率大致相同，且关键字位数比地址数大，基本关键字可以提前预知。选用 key 中的某几位作为关键字。
- 平方取中：平方 key，取中间几位，适合部分数字高频重复。

#### 折叠： 

移位叠加：分割后低位对齐相加。（切成部分后相加）

间界叠加：分割之后，蛇形对齐相加（在高位切割，切割相邻位为低位；以此类推）

### 哈希表

- 除留余数：key mod p，p 一般选 小于等于最大长度的质数或不含 20 以下的质数因子的合数。
- 乘余取整：key × A （A为0～1之间的小数），取小数部分；用 m 乘以小数，取整数部分为 index。
- 随机数： index = random(key)

构造的原则是冲突可能尽量小。

#### 冲突处理

- 开放地址——线性探测： index + 1
- 开放地址——二次探测： index +- n^2 (n为大于0常数)
- 伪随机： index + randint()
- 链地址： 同 index，数据域使用链表存储。
- 再哈希： 使用另一个 Hash 函数 R，再次计算 R(index)。
- 溢出区法：发生冲突时存入单独的溢出表。

ASL = 探查次数之和 / 元素个数

哈希表的 ASL 依赖于 Hash 表的装填程度，不论多大的装填程度，总有一个适合值可将 ASL 限定在合理范围内。
