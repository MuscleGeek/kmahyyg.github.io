---
title: 操作系统原理 - PV原语与互斥锁、信号量
description: "A reference list about PV signal and mutex"
date: 2019-04-13T23:19:40
featuredImage: "https://alicdn.kmahyyg.xyz/asset_files/aether/cat_school.webp"
categories: ["school"]
draft: false
displayInMenu: false
displayInList: true
dropCap: false
---

## Reference

https://blog.csdn.net/Tanswer_/article/details/71083602
https://www.cnblogs.com/cocowool/archive/2012/06/11/2544823.html
https://www.jianshu.com/p/67c536ad4efe
http://timothyqiu.com/archives/spinlock-mutex-condition-variable-readers-writer-lock/
https://www.zhihu.com/question/40562993/answer/87204567

全文转载了原作者的文章，因为国内网络环境差，不知道什么时候就 404 了，还请原作者谅解。版权归原作者所有，如有疑问，请与我联系。

# PV 原语 - 文献 1

## 信号量S的物理含义

S>0：表示有S个资源可用；S=0表示无资源可用；S<0绝对值表示等待队列或链表中的进程个数。信号量的初值应大于等于0。

## PV原语小结

通过操作信号量来处理进程间的同步与互斥的问题。其核心就是一段不可分割不可中断的程序。

信号量是由操作系统来维护的，用户进程只能通过初始化和两个标准原语（P、V原语）来访问，它们在执行时是不可中断的。初始化可指定一个非负整数，即空闲资源总数。

P原语：P是荷兰语Proberen（测试）的首字母。为阻塞原语，负责把当前进程由运行状态转换为阻塞状态，直到另外一个进程唤醒它。操作为：申请一个空闲资源（把信号量减1），则若成功，则退出；若失败，则该进程被阻塞；

V原语：V是荷兰语Verhogen（增加）的首字母。为唤醒原语，负责把一个被阻塞的进程唤醒，它有一个参数表，存放着等待被唤醒的进程信息。操作为：释放一个被占用的资源（把信号量加1），如果发现有被阻塞的进程，则选择一个唤醒之。

P(S)：表示申请一个资源，S减 1；若 减1 后仍S>=0，则该进程继续执行；若 减1 后 S<0，表示已无资源可用，需要将自己阻塞起来。

V(S)：表示释放一个资源，S加 1；若 加1 后S>0，则该进程继续执行；若 加1 后 S<=0，表示等待队列上有等待进程，需要将第一个等待的进程唤醒。

PV原语对信号量的操作可以分为三种情况：

1. 把信号量视为一个加锁标志位，实现对一个共享变量的互斥访问。

实现过程：

```
P(mutex); // mutex的初始值为1
访问该共享数据
V(mutex);
非临界区
```

互斥信号量是根据临界资源的类型设置的。有几种类型的临界资源就设置几个互斥信号量。它代表该类临界资源的数量，或表示是否可用，其初值一般为“1”。


2. 把信号量视为是某种类型的共享资源的剩余个数，实现对一类共享资源的访问。

实现过程：

```
P(resource); // resource的初始值为该资源的个数N
使用该资源；
V(resource);
非临界区
```

3. 把信号量作为进程间的同步工具

实现过程：

```
临界区C1； 
P(S);
V(S);     
临界区C2；
```

同步信号量是根据进程的数量设置的。一般情况下，有几个进程就设置几个同步信号量，表示该进程是否可以执行，或表示该进程是否执行结束，其初值一般为“0”。

## 同步与互斥的解题思路

分清哪些是互斥问题（互斥访问临界资源的），哪些是同步问题（具有前后执行顺序要求的）。

对互斥问题要设置互斥信号量，不管有互斥关系的进程有几个或几类，通常只设置一个互斥信号量，且初值为1，代表一次只允许一个进程对临界资源访问。

对同步问题要设置同步信号量，通常同步信号量的个数与参与同步的进程种类有关，即同步关系涉及几类进程，就有几个同步信号量。同步信号量表示该进程是否可以开始或该进程是否已经结束。

在每个进程中用于实现互斥的PV操作必须成对出现；用于实现同步的PV操作也必须成对出现，但可以分别出现在不同的进程中；在某个进程中如果同时存在互斥与同步的P操作，则其顺序不能颠倒，必须先执行对同步信号量的P操作，再执行对互斥信号量的P操作，但V操作的顺序没有严格要求。

## 为什么P操作不能颠倒？

解进程同步和互斥问题的方法步骤

1) 关系分析。找出问题中的进程数，并且分析它们之间的同步和互斥关系。同步、互斥关系直接按照上面的经典范式改写。

2) 整理思路。找出解决问题的关键点，并且根据做过的题目找出解决的思路。根据进程的操作流程确定P操作、V操作的大致顺序。

3) 设置信号量。根据上面两步，设置需要的信号量，确定初值，完善整理。

### 生产者消费者问题

问题描述

一组生产者进程和一组消费者进程共享一个初始为空、大小为n的缓冲区，只有缓冲区没满时，生产者才能把消息放入到缓冲区，否则必须等待；只有缓冲区不空时，消费者才能从中取出消息，否则必须等待。由于缓冲区是临界资源，它只允许一个生产者放入消息，或者一个消费者从中取出消息。

问题分析

关系分析：生产者往缓冲区写消息，，消费者从缓冲区取消息必须分开进行，所以两者是互斥关系；同时只有生产者放入消息后，消费者才能从中取出消息，所以两者还是同步关系。

整理思路：两个进程，既是互斥关系，又是同步关系。此时需要注意互斥同步PV操作的位置。

信号量设置：互斥信号量mutex，初值为1，保证互斥的访问缓冲池；信号量full记录当前缓冲池中满缓冲区个数，初值为0，信号量empty记录当前缓冲池空缓冲区个数，初值为n。

类C语言代码

```c
semaphore mutex=1; //临界区互斥信号量
semaphore empty=n;  //空闲缓冲区
semaphore full=0;  //缓冲区初始化为空
producer () { //生产者进程
    while(1){
        produce an item in nextp;  //生产数据
        P(empty);  //获取空缓冲区单元
        P(mutex);  //进入临界区.
        add nextp to buffer;  //将数据放入缓冲区
        V(mutex);  //离开临界区,释放互斥信号量
        V(full);  //满缓冲区数加1
    }
}

consumer () {  //消费者进程
    while(1){
        P(full);  //获取满缓冲区单元
        P(mutex);  // 进入临界区
        remove an item from buffer;  //从缓冲区中取出数据
        V (mutex);  //离开临界区，释放互斥信号量
        V (empty) ;  //空缓冲区数加1
        consume the item;  //消费数据
    }
}
```

## 生产者消费者问题扩展

问题描述

桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等吃盘子中的橘子，女儿专等吃盘子中的苹果。只有盘子为空时，爸爸或妈妈就可向盘子中放一个水果；仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出。

问题分析

关系分析：爸妈往盘子里放水果，必须互斥进行，所以爸妈是互斥关系；爸爸和女儿、妈妈和儿子是同步关系，类似生产者和消费者；儿子和女儿没有什么关系，有相应需求的水果就拿走

整理思路：有四个进程：爸爸放苹果、女儿吃苹果、妈妈放橘子、儿子吃橘子，可抽象为两对生产者消费者对一个缓冲区（盘子）进行操作

信号量设置：盘子plate为互斥信号量，表示是否允许向盘子中放置水果，初值为1， 表示允许放入。同步信号量设置两个，分别为apple、orange，因为两类进程：爸爸和女儿取放苹果、妈妈和儿子取放橘子。apple表示盘中是否有苹果，初值为0，表示盘子为空，不可取，若apple为1可以取；orange类似。

类C语言代码

```c
semaphore plate=1, apple=0, orange=0;
father()  //父亲进程
{
    while(1)
    {
        P(plate);   //互斥向盘中放水果  
        向盘中放苹果;
        V(apple);   //放好后，此时可以取苹果
    }
}
mother()  //母亲进程
{
    while(1)
    {
        P(plate);   //互斥向盘中放水果
        向盘中放橘子;
        V(orange);   //放好后，此时可以取橘子
    }
}
sun()  //儿子进程
{
    while(1)
    {
        P(orange);   //互斥从盘中取橘子
        从盘中取橘子;
        V(plate);   //取完后盘子可用
    }
}
daughter()  //女儿进程
{
    while(1)
    {
        P(apple);   //互斥从盘中取苹果
        从盘中取苹果;
        V(plate);   //取完后盘子可用
    }
}
```

## PV原语第二种类型示例

问题描述

某超市门口为顾客准备了100辆手推车，每位顾客在进去买东西时取一辆推车，在买完东西结完帐以后再把推车还回去。试用P、V操作正确实现顾客进程的同步互斥关系。

问题分析

把手推车视为某种资源，每个顾客为一个要互斥访问该资源的进程。因此这个例子为PV原语的第二种应用类型。

类C代码

```c
semaphore num=100;
consumer()
{
    P(num); 
    买东西;
    结帐;
    V(num);
}
```

## 哲学家就餐问题

问题描述

一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭，如图所示。哲学家们倾注毕生精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿的时候，才试图拿起左、 右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿到了两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。

问题分析

关系分析：5名哲学家与左右邻居对其中间筷子的访问是互斥关系。

整理思路：这里有五个进程。本题的关键是如何让一个哲学家拿到左右两个筷子而不造成死锁或者饥饿现象。那么解决方法有两个，一个是让他们同时拿两个筷子；二是对每个哲学家的动作制定规则，避免饥饿或者死锁现象的发生。为了防止死锁的发生，可以对哲学家进程施加一些限制条件，比如至多允许四个哲学家同时进餐;仅当一个哲学家左右两边的筷子都可用时才允许他抓起筷子;对哲学家顺序编号，要求奇数号哲学家先抓左边的筷子，然后再转他右边的筷子，而偶数号哲学家刚好相反。正解制定规则如下：假设釆用第二种方法，当一个哲学家左右两边的筷子都可用时，才允许他抓起筷子。

信号量设置：定义互斥信号量数组Chopstick[5] = {l, 1, 1, 1, 1}用于对5个筷子的互斥访问。取筷子的信号量mutex，初值为1

类C语言代码

```c
semaphore chopstick[5] = {1,1,1,1,1}; //初始化信号量
semaphore mutex=1;  //设置取筷子的信号量
Pi(){ //i号哲学家的进程
    while(1)
    {
        P (mutex) ; //在取筷子前获得互斥量
        P (chopstick [i]) ; //取左边筷子
        P (chopstick[ (i+1) %5]) ;  //取右边筷子
        V (mutex) ; //释放取筷子的信号量
        eat;  //进餐
        V(chopstick[i] ) ;  //放回左边筷子
        V(chopstick[ (i+l)%5]) ;  //放回右边筷子
        think;  // 思考
    }
}
```

会发生死锁的算法

```c
semaphore chopstick[5] = {1,1,1,1,1}; //初始化信号量
Pi(){ //i号哲学家的进程
    while(1)
    {
        P (chopstick [i]) ; //取左边筷子
        P (chopstick[ (i+1) %5]) ;  //取右边筷子
        eat;  //进餐
        V(chopstick[i] ) ;  //放回左边筷子
        V(chopstick[ (i+l)%5]) ;  //放回右边筷子
        think;  // 思考
    }
}
/*当每个哲学家同时拿起同一侧的筷子时，会发生死锁*/
```

# 信号量与互斥锁 - 文献 5 

1. 信号量（Semaphore）

信号量就是一个停车场。

当前值是停车场里还剩下多少个空车位。最大值是停车场里最多能容纳多少个车位。

当汽车进入停车场时，首先要在门口排队(sem_wait)，得到进入许可后才能进入。排队顺序原则上先到先得。每进一辆车，停车场就少了1个停车位，即信号量当前值-1。当前值为0时，停车场停满了，所有车不得进入统统在门口排队等。当一辆车离开后，释放其所占据的停车位(sem_post)，信号量当前值+1信号量值得到释放后，如果门口有正在排队的车，那么就放进来，每放进来一个就重复前面的步骤。

2. 互斥锁（Mutex）

Mutex就是厕所的隔间，门开着的时候谁都可以进，但是一次只能进一个人。进去后，就从里面锁上门。厕所里有人的时候其他人就要排队等，直到里面的人出来。

# 各类锁的详细描述 - 文献 4

自旋锁（spinlock）很好理解。对自旋锁加锁的操作，你可以认为是类似这样的：

```
while (抢锁(lock) == 没抢到) {
}
```

只要没有锁上，就不断重试。显然，如果别的线程长期持有该锁，那么你这个线程就一直在 `while while while` 地检查是否能够加锁，浪费 CPU 做无用功。

仔细想想，其实没有必要一直去尝试加锁，因为只要锁的持有状态没有改变，加锁操作就肯定是失败的。所以，抢锁失败后只要锁的持有状态一直没有改变，那就让出 CPU 给别的线程先执行好了。这就是互斥器（mutex）也就是题目里的互斥锁（不过个人觉得既然英语里本来就不带 lock，就不要称作锁了吧）。对互斥器加锁的操作你可以认为是类似这样的：

```
while (抢锁(lock) == 没抢到) {
    本线程先去睡了请在这把锁的状态发生改变时再唤醒(lock);
}
```

操作系统负责线程调度，为了实现「锁的状态发生改变时再唤醒」就需要把锁也交给操作系统管理。所以互斥器的加锁操作通常都需要涉及到上下文切换，操作花销也就会比自旋锁要大。

以上两者的作用是加锁互斥，保证能够排它地访问被锁保护的资源。

不过并不是所有场景下我们都希望能够独占某个资源，很快你可能就会不得不写出这样的代码：

```
// 这是「生产者消费者问题」中的消费者的部分逻辑
// 等待队列非空，再从队列中取走元素进行处理

加锁(lock);  // lock 保护对 queue 的操作
while (queue.isEmpty()) {  // 队列为空时等待
    解锁(lock);
    // 这里让出锁，让生产者有机会往 queue 里安放数据
    加锁(lock);
}
data = queue.pop();  // 至此肯定非空，所以能对资源进行操作
解锁(lock);
消费(data);  // 在临界区外做其它处理
```

你看那个 while，这不就是自己又搞了一个自旋锁么？区别在于这次你不是在 while 一个抽象资源是否可用，而是在 while 某个被锁保护的具体的条件是否达成。

有了前面自旋锁、互斥器的经验就不难想到：「只要条件没有发生改变，`while` 里就没有必要再去加锁、判断、条件不成立、解锁，完全可以让出 CPU 给别的线程」。不过由于「条件是否达成」属于业务逻辑，操作系统没法管理，需要让能够作出这一改变的代码来手动「通知」，比如上面的例子里就需要在生产者往 `queue` 里 `push_back` 后「通知」!`queue.isEmpty()` 成立。

也就是说，我们希望把上面例子中的 `while` 循环变成这样：

```
while (queue.isEmpty()) {
    解锁后等待通知唤醒再加锁(用来收发通知的东西, lock);
}
```

生产者只需在往 `queue` 中 `push_back` 数据后这样，就可以完成协作：

```
触发通知(用来收发通知的东西);
// 一般有两种方式：
//   通知所有在等待的（notifyAll / broadcast）
//   通知一个在等待的（notifyOne / signal）
这就是条件变量（condition variable），也就是问题里的条件锁。它解决的问题不是「互斥」，而是「等待」。
```

至于读写锁（readers-writer lock），看英文可以顾名思义，在执行加锁操作时需要额外表明读写意图，复数读者之间并不互斥，而写者则要求与任何人互斥。读写锁不需要特殊支持就可以直接用之前提到的几个东西实现，比如可以直接用两个 spinlock 或者两个 mutex 实现：

```
void 以读者身份加锁(rwlock) {
    加锁(rwlock.保护当前读者数量的锁);
    rwlock.当前读者数量 += 1;
    if (rwlock.当前读者数量 == 1) {
        加锁(rwlock.保护写操作的锁);
    }
    解锁(rwlock.保护当前读者数量的锁);
}

void 以读者身份解锁(rwlock) {
    加锁(rwlock.保护当前读者数量的锁);
    rwlock.当前读者数量 -= 1;
    if (rwlock.当前读者数量 == 0) {
        解锁(rwlock.保护写操作的锁);
    }
    解锁(rwlock.保护当前读者数量的锁);
}

void 以写者身份加锁(rwlock) {
    加锁(rwlock.保护写操作的锁);
}

void 以写者身份解锁(rwlock) {
    加锁(rwlock.保护写操作的锁);
}
```

如果整个场景中只有一个读者、一个写者，那么其实可以等价于直接使用互斥器。不过由于读写锁内部是至少需要用一把锁来保护当前读者数的，所以，如果你的临界区很小，读写锁相比一般的锁并不能带来很大的优势，甚至可能性能更低。

另一方面，读写锁要真正发挥效能，条件也比较麻烦。比如实际的读写锁通常不用例子里两把锁的实现，而是用一把锁、一个条件变量来实现，好处是可以缓解写者饥饿的情况（一旦有写者在等锁，后续读者都需要等写者离开后才能继续），但这样一来，如果读者的临界区没有明显小于写者的临界区，阻塞情况可能会变得比较不理想……

所以你可以认为读写锁是针对某种特定情景的「优化」。不是说不要用读写锁，而是读写锁往往没有看上去那么理想。个人建议是可以优先用 mutex，如果遇到瓶颈后可以选择替换为读写锁，看看能否带来性能提升。

以上。

# 进程的同步、互斥以及PV原语 - 文献 2

在处理进程间的同步与互斥问题时，我们离不开信号量和PV原语，使用这两个工具的目的在于打造一段不可分割不可中断的程序。应当注意的是，信号量和PV原语是解决进程间同步与互斥问题的一种机制，但并不是唯一的机制。

## 信号量：

信号量的概念1965年由著名的荷兰计算机科学家 Edsger Wybe Dijkstra 艾兹格·迪科斯彻 提出。

其核心思想是用一种新的变量类型（Semaphore）来记录可用资源的数量。有两种实现方式：

1、Semaphore的取值必须大于或等于0。0表示当前已经没有空闲资源，而正数表示当前空闲资源的数量；

2、Semaphore的取值可正可负，负数的绝对值表示正在等待进入临界区的进程个数；

信号量是一个二元组（S，Q）。S是一个具有非负初值的整型变量，Q是一个初始状态为空的队列。

## PV原语

P原语：P是荷兰语Proberen（测试）的首字母。为阻塞原语，负责把当前进程由运行状态转换为阻塞状态，直到另一个进程唤醒它。具体操作为：申请一个空闲资源（把信号量减1），若成功，则退出；若失败，则该进程被阻塞。

V原语：V是荷兰语Verhogen（增加）的首字母。为唤醒原语，负责把一个被阻塞的进程唤醒，他有一个参数表，存放着等待被唤醒的进程信息。具体操作为：释放一个被占用的资源（把信号量加1），如果发现有被阻塞的进程，则选择一个唤醒。

## 表示方法

P(S)：表示将信号量S的值减一，即S=S-1；如果S>=0，则该进程继续执行，否则该进程置为等待状态，排入等待队列（队列Q）。

V(S)：表示将信号量S的值加一，即S=S+1；如果S>0，则该进程继续执行，否则释放队列（Q）中第一个等待信号量的进程。

### 实现互斥模型

在互斥模型中，多个进程对可用资源进行争用，使用信号量S表示可用资源的数量。一般来说，信号量S>=0时，S表示可用资源的数量。执行一次P操作意味着请求分配一个单位资源，因此S的值减1；当S<0时，表示已经没有可用资源，请求者必须等待别的进程释放该类资源，它才能运行下去。而执行一个V操作意味着释放一个单位资源，因此S的值加1；若S<=0，表示有某些进程正在等待该资源，因此要唤醒一个等待状态的进程，使之运行下去。

进程互斥是进程之间发生的一种间接性作用，一般是程序不希望的。

如下表所示，我们使用S=1做为初值，表示当前系统资源只有一个，多个进程需要轮流使用这个资源。

![](https://alicdn.kmahyyg.xyz/asset_files/2019-pv-coolwolf1.webp)

在互斥模型的问题中，关键的问题在于使用PV操作来保证有限的系统资源被正常的使用和释放，而不是多人争抢谁都抢不到，或者某人独占而不释放的情况。有点类似于北京现在的摇号制度，实际上资源就是两万个号牌，每个申请的人都执行了一次P操作，表示自己想要使用资源，在摇号结果出来之前没有资源可用，大家都进入Q队列等候，放号之时，获得资格的用户执行V操作，释放一个等待位置，其他人可以进入下一次的排号等候队列。

### 实现同步模型

所谓同步，是指多个相互合作的进程，在一些关键点上可能需要相互等待或相互交换信息，这种互相制约的关系称为进程同步。例如系统中有两个合作的进程，他们共用一个单缓冲区。这两个进程一个是计算进程，负责对数据进行计算；另一个为打印进程，负责对计算结果进行打印。当计算进程没有计算完毕，计算结果没有送到缓冲区的时候，打印进程就不能打印。一旦计算进程把计算结果送入缓冲区，就应该给打印进程发送一个信号，打印进程收到信号后就可以从缓冲区中取出计算结果进行打印。

之前我在想这个同步模型的时候，考虑可以使用定时轮询的方式，计算进程定时查询缓冲区，可用即开始写入；打印进程定时查询缓冲区，有内容即开始打印。但是这种没有相互合作沟通的方式，非常容易出现问题，比如计算进程内容还没有写完，打印进程就开始读取打印，造成分页的不正确或者数据的不完整。实际上，一般我们都会有多个计算进程，这种情况下就会同时存在资源争用的问题。

进程同步是进程之间直接的相互作用，是合做进程间有意识的行为。与互斥模型不同，进程同步时的信号量只与制约进程、被制约进程有关而不是与所有的同类并发进程有关，所以同步模型中的信号量为私有信号量。

生产者-消费者模型是同步模型的典型代表，其也存在多种情况，分别叙述如下：

1、一个生产者，一个消费者，共用一个缓冲区。

定义两个同步信号量，生产者需要一个EMPTY信号量来判断当前是否能够写入，设置初值为1，消费者需要一个FULL信号量，来判断当前是否能够读取，设置初值为0。

![](https://alicdn.kmahyyg.xyz/asset_files/2019-pv-coolwolf2.webp)

2、一个生产者，一个消费者，共用N个缓冲区。

与上面的例子不同的是，EMPTY的初值为N，则生产者的阻塞时间会减少很多。

![](https://alicdn.kmahyyg.xyz/asset_files/2019-pv-coolwolf3.webp)

3、多个生产者，多个消费者，共用N个缓冲区。

在这种场景下，除了同步之外，还需要在生产者之间、消费者之间进行互斥的访问缓冲区，所以需要设置四个信号量，分别是EMPTY、FULL、生产者之间的互斥信号量Mutex1、消费者之间的互斥信号量Mutex2。

非生产者、消费者模型的例子有一个司机和售票员的。设置RUN信号量供司机判断是否应该开车，初始值为0；设置STOP信号量供售票员判断是否可以开门，初始值为0。描述如下：

![](https://alicdn.kmahyyg.xyz/asset_files/2019-pv-coolwolf4.webp)

前驱图（Precedence Graph）是一种有向无循环图，记为DAG（Directed Acyclic Graph），用于描述进程间执行的前后关系。如下图：

![](https://alicdn.kmahyyg.xyz/asset_files/2019-pv-coolwolf5.webp)

图中的每个结点可用于描述一个进程段或进程，乃至一条语句；结点间的有向边则用于表示两个结点之间存在的偏序（Partial Order）或前驱关系。可以使用PV原语，来描述前驱图。

PS：互斥的问题可以用硬件方法解决，如何解决，不太清楚。

# 常见习题 - 文献 2

太大，文件太多，懒得搬运了，直接截长图了。

麻烦自己下载之后查看吧。  [Click here to download](https://alicdn.kmahyyg.xyz/asset_files/2019-pv-jianshuqa.zip)

(END)
