---
title: 数据结构与算法课程 - Chap 10 排序
date: 2019-01-06 14:49:29
tags:
  - School
  - Datastru
---

# 数据结构复习 - Chapter 10 排序

## 相关概念：

按主关键字排序：结果唯一；按次关键字可以结果不唯一。

排序稳定性：同样的重复数据，排序前后的重复数据的相对顺序不变。

内部排序：在计算机的内存即可完成（RAM），外部排序由于数据过大，必须访问外部存储才可以解决。

排序的两种基本操作：比较大小，移动数据。

存储方式：

- 存储在数组中，排序时按需移动。
- 存储在静态链表中，只需修改指针。
- 存储在地址连续的一组存储单元中，另设向量用于记录数据的存储位置，只需修改向量中的存储地址即可。

## 各种排序算法

- 直接插入排序：数组的 [0] 位用于临时存储数据以备交换之用。在 r[1.. i-1]中查找 r[i] 的插入位置; 对于在查找过程中找到的那些关键字不小于 r[i].key 的记录，在查找的同时实现记录向后移动；之后插入 r[i] 即可。
- 折半插入排序：对原数据进行二分查找，当出现 low > high OR low == high OR high < low （此处均指指针的所在位置而非元素）时，根据元素大小关系插入到对应指针的前后。

### 二路插入排序

用空间换时间，需要存储 n 个记录的辅助空间数组 D。将初始数据数组 L[1] = D[1]，然后比较大小，将 L 视为环形数组，D 其中的数据大于 L 中的最大元素，则插入到尾部；若小于 L 中最小的元素则插入至头部，否则折半查找，移动一部分的元素。

其中 L 中的第一个是 min， 最后一个是 max。 初始状态 `first = final = 1` ，修改：`first = (first - 1 + length) % length`, `final += 1`。

### 表插入排序

使用静态链表保存排序，排序完成后一次性调整所在位置。数据节点与头节点构成循环列表，头节点： `index = 0 | data = MAXINT | nextidx = SMALLEST ONE`，然后将剩下的数据根据非递减排序，依次修改各数据节点的 nextidx 域，确保各节点对应的 nextidx 值指向下一个更大的量，头节点保存数据最小的节点所在的指针。

### 希尔排序

分割所有元素为若干个子序列，不断缩小子序列之间的间隔。每产生一次子序列就插入排序一次。数组的第 0 位用于插入排序的暂存。

eg. 按照子序列中各元素大小不停交换： 

| 在原数据中相隔x个取出一个构成子序列 |  1   |  2   |  3   |  4   |  5   |  6   |
| :---------------------------------: | :--: | :--: | :--: | :--: | :--: | :--: |
|                  0                  |  65  |  49  |  97  |  25  | 25^  |  13  |
|                  3                  | 65A  | 49B  | 97C  | 25A  | 25^B | 13C  |
|                  2                  | 25A  | 25^B | 13AC | 65BD | 49C  | 97D  |
|                  1                  |  13  | 25^  |  25  |  65  |  49  |  97  |


### 冒泡排序

实质：双重嵌套循环，从第 i 个数据起，与之后的 i + 1 个数据比较，i++，若更大或更小就交换;
对 i 进行长度为 len 的循环，重复比较。

```python
for i in range(len(L1)-1, 0, -1):
    for j in range(0, i):
        if L1[j] > L1[j + 1]:
            L1[j], L1[j + 1] = L1[j + 1], L1[j]
        else:
            pass
```

### 快速排序

- 选择枢轴，以枢轴作为基准值。
- 设指针 low 、high 指向第一个和最后一个记录
- 从 high 开始向前搜索，找到一个 <= 基准值的记录，并与之交换
- 从 low 开始向后搜索，找到一个 >= 基准值的记录，并与之交换
- 重复直到 low == high

### 简单选择排序

选择排序的思想在于：每次循环都选出一个最记录并与 i 位置交换。需要用的一个数据暂存单元。

实质仍然是冒泡排序，区别在于：找到最值之后再交换，而不是每次都交换。

### 树形选择排序

类似 Huffman Tree：

- 将各数据置于底层，
- 选出较小者依次向上构建排序二叉树。
- 输出最小或最大数据之后，将输出的数据在底层叶子节点的数据置为 INTMAX。
- 重复上述过程，直至底层叶子节点全为 INTMAX。

需要注意的是： **该排序是稳定排序，左右相同左者先。**

### 堆排序

堆：对应的每个数据，DATA[i] <= DATA[2i] AND DATA[i+1] <= DATA[2i+1]，反之亦成立。

解释：上述数据元素依次排成完全二叉树，堆顶（ROOT）必然最大（MAX 大根堆）或最小（MIN 小根堆），树中所有节点的值均大于（OR 均小于）左右孩子。

依然满足 **先左后右，左大右小，恒小于根** 的原则。建堆和筛选过程注意：向上、向下双重比较。

堆排序使用 BFS 遍历，得到的结果就是排序字符串。

### 归并排序

- deltax = 2; 每 deltax 个元素形成一个子序列，并进行内部排序。
- deltax ×= 2; 重复排序过程，组合子序列。
- 最终组合成完整序列。

### 基数排序

分类：

- Most Significant Digit first (MSD)
- Least Significant Digit first (LSD)

根据存储结构分为：普通基数排序和链式基数排序。

关键字按不同的位值进行排序。本质是多关键字排序思想在单逻辑关键字上的应用。实际是一种嵌套排序。

这里没有太好的归纳，直接上例子吧：

------- 普通的 基数排序 --------

- 每个记录的 关键码 长度 为 n，视为 n 元组， 每一位的取值 有 r 种，称 r 为基数。
- 设置 r 个队列，将 n 中元素的最低位按照要求，（以 LSD 为例），按 LSD 放入对应队列，然后顺序出队  **分配再收集**
- 将 n 中的剩余元素重复上述过程，继续 **分配再收集** ，直到排序完成。

-----------------------------

-------- 链式 基数排序 --------

- 数据使用链表存储。
- 每一队列置一队头、一队尾指针，然后按照上述 步骤重复排序。
- 出队过程改为将队头队尾指针链接起来。

-----------------------------

## 各种算法的时间复杂度

![时间复杂度表](/asset_files/2019-sort-complexity.png)

